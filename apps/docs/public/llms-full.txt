# ng-forge Dynamic Forms — Full Documentation

> Generated from 45 documentation files.
> Source: https://ng-forge.com/dynamic-forms/

--- advanced/custom-integrations ---

> Prerequisites: [Installation](../../installation), [Field Types](../schema-fields/field-types), [Type Safety](../type-safety)

Create custom UI integrations for ng-forge dynamic forms using any component library or design system.

## Package Structure

The `@ng-forge/dynamic-forms` package is organized into multiple entrypoints to keep the core abstract and provide specialized utilities for integration authors:

| Entrypoint                            | Purpose                                                    |
| ------------------------------------- | ---------------------------------------------------------- |
| `@ng-forge/dynamic-forms`             | Core types, components, and configuration (for all users)  |
| `@ng-forge/dynamic-forms/integration` | Field types, mappers, and utilities for UI library authors |

When building a custom integration, you'll primarily import from the `/integration` entrypoint:

```typescript
// Core types (used by everyone)
import { DynamicForm, provideDynamicForm, FormConfig, DynamicText } from '@ng-forge/dynamic-forms';

// Integration utilities (for UI library authors)
import {
  InputField,
  SelectField,
  CheckboxField,
  valueFieldMapper,
  checkboxFieldMapper,
  createResolvedErrorsSignal,
} from '@ng-forge/dynamic-forms/integration';
```

## Integration Overview

UI integrations map field types to your components using `FieldTypeDefinition` objects. Each definition specifies the field type name, component loader, and mapper function.

## Basic Steps

### 1. Define Field Type Interface

Create a type interface extending the base field type:

```typescript
import { ValueFieldComponent, DynamicText } from '@ng-forge/dynamic-forms';
import { InputField } from '@ng-forge/dynamic-forms/integration';

// Define your custom props
export interface CustomInputProps extends Record<string, unknown> {
  appearance?: 'outline' | 'fill';
  hint?: DynamicText;
  type?: 'text' | 'email' | 'password' | 'number';
}

// Extend the base InputField with your props
export type CustomInputField = InputField<CustomInputProps>;

// Define the component interface (used for type checking)
export type CustomInputComponent = ValueFieldComponent<CustomInputField>;
```

### 2. Create Field Component

Implement the component using Angular's signal forms:

```typescript
import { Component, input } from '@angular/core';
import { Field, FieldTree } from '@angular/forms/signals';
import { DynamicText, DynamicTextPipe } from '@ng-forge/dynamic-forms';
import { CustomInputComponent, CustomInputProps } from './custom-input.type';
import { AsyncPipe } from '@angular/common';

@Component({
  selector: 'custom-input',
  imports: [Field, DynamicTextPipe, AsyncPipe],
  template: `
    @let f = field();

    <div class="custom-field" [class.custom-outline]="props()?.appearance === 'outline'">
      @if (label()) {
      <label [for]="key() + '-input'">{% raw %}{{ label() | dynamicText | async }}{% endraw %}</label>
      }

      <input
        [id]="key() + '-input'"
        [field]="f"
        [type]="props()?.type || 'text'"
        [placeholder]="{% raw %}(placeholder() | dynamicText | async) ?? ''{% endraw %}"
        [disabled]="f().disabled()"
        [attr.tabindex]="tabIndex()"
      />

      @if (props()?.hint; as hint) {
      <div class="hint">{% raw %}{{ hint | dynamicText | async }}{% endraw %}</div>
      } @if (f().touched() && f().invalid()) {
      <div class="error">{% raw %}{{ f().errors() | json }}{% endraw %}</div>
      }
    </div>
  `,
  host: {
    '[id]': '`${key()}`',
    '[class]': 'className()',
  },
})
export default class CustomInputFieldComponent implements CustomInputComponent {
  // Required inputs
  readonly field = input.required<FieldTree<string>>();
  readonly key = input.required<string>();

  // Standard inputs
  readonly label = input<DynamicText>();
  readonly placeholder = input<DynamicText>();
  readonly className = input<string>('');
  readonly tabIndex = input<number>();

  // Custom props
  readonly props = input<CustomInputProps>();
}
```

### 3. Create Field Type Definition

Define the field type registration:

```typescript
import { FieldTypeDefinition } from '@ng-forge/dynamic-forms';
import { valueFieldMapper } from '@ng-forge/dynamic-forms/integration';

export const CustomInputType: FieldTypeDefinition = {
  name: 'input',
  loadComponent: () => import('./custom-input.component'),
  mapper: valueFieldMapper,
};
```

### 4. Create Provider Function

Export a function that returns all your field type definitions:

```typescript
import { FieldTypeDefinition } from '@ng-forge/dynamic-forms';
import { CustomInputType } from './fields/input';
import { CustomSelectType } from './fields/select';
import { CustomCheckboxType } from './fields/checkbox';

export function withCustomFields(): FieldTypeDefinition[] {
  return [
    CustomInputType,
    CustomSelectType,
    CustomCheckboxType,
    // ... more field types
  ];
}
```

### 5. Configure App

Add your fields to the app configuration:

```typescript name="app.config.ts"
import { ApplicationConfig } from '@angular/core';
import { provideDynamicForm } from '@ng-forge/dynamic-forms';
import { withCustomFields } from './custom-fields';

export const appConfig: ApplicationConfig = {
  providers: [provideDynamicForm(...withCustomFields())],
};
```

## Component Interface Types

ng-forge provides component interface types for different field categories:

### ValueFieldComponent

For fields that collect user input (input, select, textarea, datepicker, radio, slider):

```typescript
import { ValueFieldComponent } from '@ng-forge/dynamic-forms';
import { InputField } from '@ng-forge/dynamic-forms/integration';

export type CustomInputComponent = ValueFieldComponent<CustomInputField>;
```

The component must implement these inputs:

- `field: FieldTree<TValue>` - The form field from Angular's signal forms
- `key: string` - Unique field identifier
- `label?: DynamicText` - Field label
- `placeholder?: DynamicText` - Placeholder text
- `className?: string` - CSS classes
- `tabIndex?: number` - Tab order
- `props?: TProps` - Custom field-specific props
- `meta?: FieldMeta` - Native HTML attributes (data-_, aria-_, autocomplete, etc.)

### CheckedFieldComponent

For checkbox and toggle fields:

```typescript
import { CheckedFieldComponent } from '@ng-forge/dynamic-forms';
import { CheckboxField } from '@ng-forge/dynamic-forms/integration';

export type CustomCheckboxComponent = CheckedFieldComponent<CustomCheckboxField>;
```

Similar to ValueFieldComponent but specifically for boolean checkbox fields.

## Field Binding with [field]

The key to connecting your component to Angular's signal forms is the `[field]` binding. Import `Field` and `FieldTree` from Angular's signal forms package:

```typescript
import { Field, FieldTree } from '@angular/forms/signals';
```

Then use the `[field]` directive on form controls:

```typescript
<input [field]="f" ... />
<mat-checkbox [field]="f" ... />
<select [field]="f" ... />
```

This directive automatically:

- Binds the form control value
- Handles value changes
- Manages validation state
- Syncs disabled/readonly states

## Field Mappers

Mappers convert field definitions to component input bindings. ng-forge provides built-in mappers:

### valueFieldMapper

For standard value-bearing fields:

```typescript
import { FieldTypeDefinition } from '@ng-forge/dynamic-forms';
import { valueFieldMapper } from '@ng-forge/dynamic-forms/integration';

export const CustomInputType: FieldTypeDefinition = {
  name: 'input',
  loadComponent: () => import('./custom-input.component'),
  mapper: valueFieldMapper, // Maps value fields
};
```

### checkboxFieldMapper

For checkbox/toggle fields:

```typescript
import { FieldTypeDefinition } from '@ng-forge/dynamic-forms';
import { checkboxFieldMapper } from '@ng-forge/dynamic-forms/integration';

export const CustomCheckboxType: FieldTypeDefinition = {
  name: 'checkbox',
  loadComponent: () => import('./custom-checkbox.component'),
  mapper: checkboxFieldMapper, // Maps checkbox fields
};
```

### Custom Mappers

For specialized fields (like buttons), create custom mappers:

```typescript
import { Binding, inputBinding } from '@angular/core';
import { FieldTypeDefinition } from '@ng-forge/dynamic-forms';
import { ButtonField } from '@ng-forge/dynamic-forms/integration';

export function buttonFieldMapper(fieldDef: ButtonField<unknown, unknown>): Binding[] {
  return [
    inputBinding('key', () => fieldDef.key),
    inputBinding('label', () => fieldDef.label),
    inputBinding('disabled', () => fieldDef.disabled ?? false),
    inputBinding('event', () => fieldDef.event),
    inputBinding('props', () => fieldDef.props),
    inputBinding('className', () => fieldDef.className),
  ];
}

export const CustomButtonType: FieldTypeDefinition = {
  name: 'button',
  loadComponent: () => import('./custom-button.component'),
  mapper: buttonFieldMapper,
  valueHandling: 'exclude', // Buttons don't contribute to form value
};
```

## Value Handling

The `valueHandling` property controls whether a field contributes to the form value:

- `'include'` (default) - Field value included in form data
- `'exclude'` - Field excluded from form data (for buttons, text fields, etc.)

```typescript
export const ButtonType: FieldTypeDefinition = {
  name: 'button',
  loadComponent: () => import('./button.component'),
  mapper: buttonFieldMapper,
  valueHandling: 'exclude', // Buttons don't have values
};
```

## Type Safety with Module Augmentation

Register your field types with TypeScript for full type inference:

```typescript
// In your field types file
declare module '@ng-forge/dynamic-forms' {
  interface FieldRegistryLeaves {
    input: CustomInputField;
    select: CustomSelectField;
    checkbox: CustomCheckboxField;
  }
}
```

This enables:

- IntelliSense for field properties
- Type checking in form configurations
- Compile-time validation of field definitions

## Handling Meta Attributes

`meta` attributes are native HTML attributes that should be applied to the underlying form element. They differ from `props` (which control UI library behavior). See [Props vs Meta](../schema-fields/field-types#props-vs-meta) for detailed usage guidance.

### Props vs Meta Summary

| Attribute Type     | Example                 | Use `props` | Use `meta` |
| ------------------ | ----------------------- | ----------- | ---------- |
| UI appearance      | `appearance: 'outline'` | ✅          | ❌         |
| Component behavior | `multiple: true`        | ✅          | ❌         |
| Browser autofill   | `autocomplete: 'email'` | ❌          | ✅         |
| Testing IDs        | `data-testid: 'email'`  | ❌          | ✅         |
| Accessibility      | `aria-describedby`      | ❌          | ✅         |

### Using setupMetaTracking

ng-forge provides the `setupMetaTracking` utility to apply meta attributes to native elements. This uses Angular's `afterRenderEffect` for efficient DOM updates.

```typescript
import { Component, ElementRef, inject, input } from '@angular/core';
import { FieldMeta, setupMetaTracking } from '@ng-forge/dynamic-forms/integration';

@Component({
  template: ` <input [field]="f" /> `,
})
export default class CustomInputComponent {
  private readonly elementRef = inject(ElementRef<HTMLElement>);
  readonly meta = input<FieldMeta>();

  constructor() {
    // Apply meta attributes to the native input element
    setupMetaTracking(this.elementRef, this.meta, { selector: 'input' });
  }
}
```

**Parameters:**

- `elementRef`: Reference to the host element
- `meta`: Signal containing the meta attributes
- `options.selector`: CSS selector to find the target element(s) within the host

### Components with Dynamic Options

For components with dynamic options (radio groups, multi-checkbox), pass a `dependents` array to ensure meta updates when options change:

```typescript
@Component({
  template: `
    @for (option of options(); track option.value) {
      <label>
        <input type="radio" [value]="option.value" />
        {% raw %}{{ option.label }}{% endraw %}
      </label>
    }
  `,
})
export default class CustomRadioComponent {
  private readonly elementRef = inject(ElementRef<HTMLElement>);
  readonly meta = input<FieldMeta>();
  readonly options = input<Option[]>([]);

  constructor() {
    // Re-apply meta when options change (new inputs are rendered)
    setupMetaTracking(this.elementRef, this.meta, {
      selector: 'input[type="radio"]',
      dependents: [this.options],
    });
  }
}
```

### Shadow DOM Considerations

For components using Shadow DOM (like Ionic), you cannot access the internal input. Apply meta to the host element by omitting the `selector`:

```typescript
@Component({
  template: `
    <ion-checkbox [checked]="value()">
      {% raw %}{{ label() }}{% endraw %}
    </ion-checkbox>
  `,
})
export default class IonicCheckboxComponent {
  private readonly elementRef = inject(ElementRef<HTMLElement>);
  readonly meta = input<FieldMeta>();

  constructor() {
    // No selector: applies meta to the host element itself
    setupMetaTracking(this.elementRef, this.meta);
  }
}
```

## Best Practices

**Use proper component interfaces:**

- Implement `ValueFieldComponent<T>` for value fields
- Implement `CheckedFieldComponent<T>` for checkboxes/toggles
- Define clear prop interfaces

**Handle meta attributes:**

- All components must accept a `meta` input
- Use `setupMetaTracking` with a selector for native elements
- Pass `dependents` for components with dynamic options
- Omit selector for Shadow DOM components (applies to host)

**Leverage [field] binding:**

- Use `[field]="f"` on form controls
- Automatic value and validation handling
- No manual form control management needed

**Support DynamicText:**

- Accept `DynamicText` for labels, hints, placeholders
- Use `DynamicTextPipe` for rendering
- Enables i18n with any translation library

**Handle validation state:**

- Show errors when `f().touched() && f().invalid()`
- Display validation messages from `f().errors()`
- Clear, accessible error presentation

**Accessibility:**

- Proper ARIA attributes
- Keyboard navigation
- Focus management
- Screen reader support

**Lazy loading:**

- Use dynamic imports in `loadComponent`
- Keeps initial bundle size small
- Components load on-demand

## Reference Implementations

See complete integrations:

- [Material Design](../../ui-libs-integrations/material) - Full Material implementation with 12+ field types
- [Bootstrap](../../ui-libs-integrations/bootstrap)
- [PrimeNG](../../ui-libs-integrations/primeng)
- [Ionic](../../ui-libs-integrations/ionic)

The Material integration source code is the most comprehensive example of implementing custom field types.

## Related Topics

- **[Material Integration](../../ui-libs-integrations/material)** - Complete reference implementation
- **[Field Types](../schema-fields/field-types)** - Understanding all available field types
- **[Type Safety](../type-safety)** - Module augmentation for custom types
- **[Validation](../validation/basics)** - Displaying validation errors in custom fields

--- advanced/events ---

The events API provides two complementary services for working with form events. Which one you use depends on **where your code lives** relative to the `dynamic-form` element.

## Choosing the right API

|                   | `EventBus`                            | `EventDispatcher`                                          |
| ----------------- | ------------------------------------- | ---------------------------------------------------------- |
| **Where to use**  | Inside DynamicForm (field components) | Outside DynamicForm (host components)                      |
| **How to get it** | `inject(EventBus)`                    | `providers: [EventDispatcher]` + `inject(EventDispatcher)` |
| **Dispatches**    | Constructor + args                    | Pre-built event instances                                  |
| **Subscribes**    | Yes — `.on()` method                  | No                                                         |

> **Important:** `EventBus` is scoped to the `DynamicForm` component's injector tree. It is **only available to components rendered inside DynamicForm** (i.e. custom field components). If you inject `EventBus` in a parent or host component, you get a completely separate, disconnected instance that the form knows nothing about. Use `EventDispatcher` instead.

---

## EventDispatcher — dispatching from outside DynamicForm

Use `EventDispatcher` when you need to drive form behaviour **from the host component** — for example, appending array items in response to a field value change, triggering a form reset from a toolbar button, or reacting to external application state.

### Setup

Provide `EventDispatcher` at the **host component** level (not root). `DynamicForm` automatically detects it and connects its internal event bus.

```typescript
import { Component, effect, inject, signal } from '@angular/core';
import { DynamicForm, EventDispatcher, FormConfig, arrayEvent } from '@ng-forge/dynamic-forms';

@Component({
  providers: [EventDispatcher], // Provide at host component level
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" [(value)]="formValue"></form>`,
})
export class MyFormComponent {
  protected readonly config = { fields: [...] } as const satisfies FormConfig;
  readonly formValue = signal<Record<string, unknown>>({});

  private readonly dispatcher = inject(EventDispatcher);

  constructor() {
    effect(() => {
      const category = this.formValue()?.['category'] as string | undefined;
      if (category) {
        this.dispatcher.dispatch(
          arrayEvent('tasks').append([{ key: 'name', type: 'input', label: 'Task', value: category }])
        );
      }
    });
  }
}
```

### Dispatching events

`EventDispatcher.dispatch()` accepts any `FormEvent` instance. Use the `arrayEvent()` builder for array operations:

```typescript
// Array manipulation
this.dispatcher.dispatch(arrayEvent('contacts').append(contactTemplate));
this.dispatcher.dispatch(arrayEvent('contacts').removeAt(0));
this.dispatcher.dispatch(arrayEvent('contacts').pop());

// Form lifecycle
this.dispatcher.dispatch(new FormResetEvent());
this.dispatcher.dispatch(new FormClearEvent());

// Custom events
this.dispatcher.dispatch(new MyCustomEvent());
```

### Multi-form note

If multiple `DynamicForm` instances exist under the same provider scope, **all forms** receive dispatched events. To target a specific form, scope the `EventDispatcher` provider to a wrapper component that contains only that form.

---

## Listening to events from outside DynamicForm

For observing events from a host component, use the output bindings exposed directly on the `dynamic-form` element. This avoids any DI scoping concerns and works with standard Angular event binding syntax.

### Output bindings

| Output                          | Emits                                                     |
| ------------------------------- | --------------------------------------------------------- |
| `(events)`                      | Every form event (full stream)                            |
| `(submitted)`                   | Form value when submitted **and valid** (SubmitEvent)     |
| `(reset)`                       | When the form is reset to default values                  |
| `(cleared)`                     | When the form is cleared to empty state                   |
| `(onPageChange)`                | PageChangeEvent on each wizard page navigation            |
| `(onPageNavigationStateChange)` | Navigation state changes (canGoNext, canGoPrevious, etc.) |
| `(validityChange)`              | Boolean — whenever form validity changes                  |
| `(dirtyChange)`                 | Boolean — whenever form dirty state changes               |
| `(initialized)`                 | Once all field components are rendered and ready          |

### Examples

**React to specific well-known events via dedicated outputs:**

```typescript
@Component({
  imports: [DynamicForm],
  template: `
    <form [dynamic-form]="config" (submitted)="onSubmit($event)" (reset)="onReset()" (onPageChange)="onPageChange($event)"></form>
  `,
})
export class MyFormComponent {
  onSubmit(value: Record<string, unknown>) {
    console.log('Valid submission:', value);
  }

  onReset() {
    console.log('Form reset to defaults');
  }

  onPageChange(event: PageChangeEvent) {
    console.log(`Now on page ${event.currentPageIndex + 1} of ${event.totalPages}`);
  }
}
```

**React to custom or less common events via `(events)`:**

```typescript
@Component({
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" (events)="onEvent($event)"></form>`,
})
export class MyFormComponent {
  onEvent(event: FormEvent) {
    if (event.type === 'save-draft') {
      this.saveDraft();
    }
  }
}
```

> **Note:** `(submitted)` only fires when the form is valid. To handle submit events regardless of validity, use `(events)` and filter for `event.type === 'submit'`.

---

## EventBus — dispatching from inside DynamicForm

`EventBus` is the internal event bus scoped to each `DynamicForm` instance. Inject it inside **custom field components** to communicate with the parent form or other fields within the same form.

> **Scoping reminder:** `EventBus` is provided by `DynamicForm` via its component injector. It is only resolvable from within field components rendered by that form. Do not inject it in host or parent components — you will get a disconnected, standalone instance.

### Usage in custom field components

```typescript
import { Component, inject } from '@angular/core';
import { EventBus, SubmitEvent } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-custom-submit-button',
  template: `<button (click)="submit()">Submit Form</button>`,
})
export class CustomSubmitButton {
  private readonly eventBus = inject(EventBus);

  submit() {
    this.eventBus.dispatch(SubmitEvent);
  }
}
```

### Subscribing to events

```typescript
export class CustomFieldComponent {
  private readonly eventBus = inject(EventBus);

  ngOnInit() {
    this.eventBus.on<PageChangeEvent>('page-change').subscribe((event) => {
      console.log(`Navigated to page ${event.currentPageIndex + 1}`);
    });
  }
}
```

---

## Built-in Events

### SubmitEvent

Fired when form is submitted.

```typescript
eventBus.on<SubmitEvent>('submit').subscribe(() => {
  console.log('Form submitted');
});
```

### PageChangeEvent

Fired when navigating between wizard pages.

```typescript
eventBus.on<PageChangeEvent>('page-change').subscribe((event) => {
  console.log(`Page ${event.currentPageIndex + 1} of ${event.totalPages}`);
  console.log(`Previous page: ${event.previousPageIndex}`);
});
```

**Properties:**

- `currentPageIndex: number` - Current page (0-based)
- `totalPages: number` - Total number of pages
- `previousPageIndex?: number` - Previous page index

### NextPageEvent

Navigate to next page in wizard.

```typescript
eventBus.dispatch(NextPageEvent);
```

### PreviousPageEvent

Navigate to previous page in wizard.

```typescript
eventBus.dispatch(PreviousPageEvent);
```

### FormResetEvent

Reset form to default values.

```typescript
// Dispatch reset event
eventBus.dispatch(FormResetEvent);

// Listen for reset
eventBus.on<FormResetEvent>('form-reset').subscribe(() => {
  console.log('Form was reset to defaults');
});
```

### FormClearEvent

Clear all form values (empty state, not defaults).

```typescript
// Dispatch clear event
eventBus.dispatch(FormClearEvent);

// Listen for clear
eventBus.on<FormClearEvent>('form-clear').subscribe(() => {
  console.log('Form was cleared');
});
```

### Array Events

The `arrayEvent()` builder provides a fluent API for array field manipulation. Import it from the main package:

```typescript
import { arrayEvent } from '@ng-forge/dynamic-forms';
```

#### Adding Items

**Important:** A template is required for all add operations. The template defines the structure of the new item:

- **Single FieldDef** → creates a **primitive item** (field value extracted directly)
- **Array of FieldDefs** → creates an **object item** (fields merged into object)

```typescript
// Define templates
const tagTemplate = { key: 'tag', type: 'input', label: 'Tag' }; // Primitive item
const contactTemplate = [
  // Object item
  { key: 'name', type: 'input', label: 'Name' },
  { key: 'email', type: 'input', label: 'Email' },
];

// Append item at end (most common)
eventBus.dispatch(arrayEvent('tags').append(tagTemplate));
eventBus.dispatch(arrayEvent('contacts').append(contactTemplate));

// Prepend item at beginning
eventBus.dispatch(arrayEvent('contacts').prepend(contactTemplate));

// Insert at specific index
eventBus.dispatch(arrayEvent('contacts').insertAt(2, contactTemplate));
```

#### Removing Items

```typescript
// Remove last item (stack pop)
eventBus.dispatch(arrayEvent('contacts').pop());

// Remove first item (queue shift)
eventBus.dispatch(arrayEvent('contacts').shift());

// Remove item at specific index
eventBus.dispatch(arrayEvent('contacts').removeAt(2));
```

#### Internal Event Classes

For advanced use cases (extending events or type-checking), you can import the underlying event classes:

```typescript
import {
  AppendArrayItemEvent,
  PrependArrayItemEvent,
  InsertArrayItemEvent,
  PopArrayItemEvent,
  ShiftArrayItemEvent,
  RemoveAtIndexEvent,
} from '@ng-forge/dynamic-forms';

// Example: extend for a pre-filled template
export class AddContactEvent extends AppendArrayItemEvent {
  constructor() {
    super('contacts', [
      { key: 'name', type: 'input', label: 'Name' },
      { key: 'phone', type: 'input', label: 'Phone' },
    ]);
  }
}

// Usage with EventDispatcher (from outside)
dispatcher.dispatch(new AddContactEvent());

// Usage with EventBus (from inside a field component)
eventBus.dispatch(AddContactEvent);
```

**Event types:**

| Event                   | Description                    |
| ----------------------- | ------------------------------ |
| `AppendArrayItemEvent`  | Add item at end of array       |
| `PrependArrayItemEvent` | Add item at beginning of array |
| `InsertArrayItemEvent`  | Add item at specific index     |
| `PopArrayItemEvent`     | Remove last item               |
| `ShiftArrayItemEvent`   | Remove first item              |
| `RemoveAtIndexEvent`    | Remove item at specific index  |

---

## Multiple Event Subscriptions

Subscribe to multiple event types by passing an array of type strings:

```typescript
eventBus.on<SubmitEvent | PageChangeEvent | NextPageEvent>(['submit', 'page-change', 'next-page']).subscribe((event) => {
  switch (event.type) {
    case 'submit':
      handleSubmit();
      break;
    case 'page-change':
      handlePageChange(event);
      break;
    case 'next-page':
      handleNextPage();
      break;
  }
});
```

---

## Custom Events

Create custom events for your forms:

```typescript
import { FormEvent } from '@ng-forge/dynamic-forms';

// Simple event
export class SaveDraftEvent implements FormEvent {
  readonly type = 'save-draft' as const;
}

// Event with payload
export class ValidationErrorEvent implements FormEvent {
  readonly type = 'validation-error' as const;

  constructor(
    public readonly fieldKey: string,
    public readonly errorMessage: string,
  ) {}
}
```

Usage inside a field component (via `EventBus`):

```typescript
// Dispatch
eventBus.dispatch(SaveDraftEvent);
eventBus.dispatch(ValidationErrorEvent, 'email', 'Invalid email format');

// Subscribe
eventBus.on<SaveDraftEvent>('save-draft').subscribe(() => saveDraft());
eventBus.on<ValidationErrorEvent>('validation-error').subscribe((event) => {
  showError(event.fieldKey, event.errorMessage);
});
```

Usage from a host component (via `EventDispatcher`):

```typescript
// Dispatch a pre-built instance
dispatcher.dispatch(new SaveDraftEvent());
dispatcher.dispatch(new ValidationErrorEvent('email', 'Invalid email format'));
```

---

## Attaching Form Values to Events

By default, events don't include the form's current value. You can opt-in to automatically attach the form value to all dispatched events using `withEventFormValue()`.

### Global Opt-in

Enable for all forms in your application:

```typescript
import { provideDynamicForm, withEventFormValue } from '@ng-forge/dynamic-forms';

provideDynamicForm(...withMaterialFields(), withEventFormValue());
```

### Per-Form Control

Override the global setting for specific forms:

```typescript
const config = {
  fields: [...],
  options: {
    // Enable for this form (even if globally disabled)
    emitFormValueOnEvents: true,
    // Or disable for this form (even if globally enabled)
    // emitFormValueOnEvents: false,
  },
} as const satisfies FormConfig;
```

### Accessing the Form Value

Use the `hasFormValue()` type guard to safely access the attached value:

```typescript
import { hasFormValue } from '@ng-forge/dynamic-forms';

eventBus.on<SubmitEvent>('submit').subscribe((event) => {
  if (hasFormValue(event)) {
    // TypeScript knows event.formValue exists
    console.log('Form value at submission:', event.formValue);
    sendToApi(event.formValue);
  }
});
```

This is useful when you need the complete form state at the time an event occurred, such as:

- Logging form values on submission
- Auto-saving on page changes
- Analytics tracking

--- advanced/expression-parser ---

Dynamic forms use expressions for conditional logic and dynamic values. When you use JavaScript expressions with `type: 'javascript'`, the expression parser evaluates them safely, preventing code injection attacks while maintaining the flexibility you need.

## How JavaScript Expressions Work

When you configure JavaScript expressions in your form:

```typescript
{
  key: 'driverLicense',
  type: 'input',
  value: '',
  label: 'Driver License',
  logic: [
    {
      type: 'required',
      condition: {
        type: 'javascript',
        expression: 'formValue.age >= 18 && formValue.needsTransport === true'
      },
    }
  ]
}
```

The expression `'formValue.age >= 18 && formValue.needsTransport === true'` is evaluated by the parser, which has access to:

```typescript
{
  fieldValue: currentFieldValue,
  formValue: { age: 25, needsTransport: true, ... },
  fieldPath: 'driverLicense'
}
```

## Security Model

The parser uses different rules for methods and properties:

### Methods: Whitelist Only

Only safe methods can be called in expressions:

```typescript
// ✅ Works - safe string methods
{
  type: 'hidden',
  condition: {
    type: 'javascript',
    expression: 'formValue.email.includes("@company.com")'
  }
}

// ✅ Works - safe array methods
{
  type: 'hidden',
  condition: {
    type: 'javascript',
    expression: 'formValue.roles.some((role) => role === "admin")'
  }
}

// ❌ Blocked - not whitelisted
{
  type: 'hidden',
  condition: {
    type: 'javascript',
    expression: 'formValue.text.link("url")' // Error: Method "link" is not allowed
  }
}
```

### Whitelisted Methods Reference

| Category   | Methods                                                                                                                                                           |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **String** | `toUpperCase`, `toLowerCase`, `trim`, `includes`, `startsWith`, `endsWith`, `slice`, `substring`, `charAt`, `indexOf`, `lastIndexOf`, `split`, `replace`, `match` |
| **Array**  | `map`, `filter`, `some`, `every`, `find`, `findIndex`, `includes`, `indexOf`, `join`, `slice`, `flat`, `flatMap`                                                  |
| **Number** | `toFixed`, `toString`, `valueOf`                                                                                                                                  |
| **Object** | `hasOwnProperty`, `toString`, `valueOf`                                                                                                                           |

### Properties: Open Access (Except Dangerous Ones)

All properties in the form data are accessible, except prototype properties:

```typescript
// ✅ Works - access any form field
expression: 'formValue.firstName';
expression: 'formValue._internalFlag';
expression: 'formValue.nested.deeply.property';

// ❌ Blocked - prototype pollution risks
expression: 'formValue.constructor'; // Error: Property "constructor" is not accessible
expression: 'formValue.__proto__'; // Error: Property "__proto__" is not accessible
```

**Why?** Dynamic forms need to access any field name you define. The parser blocks only the dangerous properties that could break security.

### Safe Member Access (Built-in)

**Important**: Member access is safe by default - accessing properties on `null` or `undefined` returns `undefined` instead of throwing errors:

```typescript
// ✅ All of these work safely, even when intermediate values are null/undefined
expression: 'formValue.user.profile.firstName';
expression: 'formValue.address.city.toLowerCase()';
expression: 'formValue.settings.notifications.email';

// If formValue.user is null, the expression returns undefined (no error thrown)
// If formValue.user.profile is null, the expression returns undefined (no error thrown)
// No manual null checks needed!
```

**This means you don't need to write defensive null checks:**

```typescript
// ❌ Unnecessary - Don't do this
expression: '!formValue.user || !formValue.user.profile || !formValue.user.profile.firstName || fieldValue !== formValue.user.profile.firstName';

// ✅ Better - Safe by default
expression: '!formValue.user.profile.firstName || fieldValue !== formValue.user.profile.firstName';
```

The parser automatically handles null/undefined at every level of property access, making expressions cleaner and more maintainable.

## Available Context Variables

When expressions are evaluated, they have access to:

```typescript
{
  fieldValue: 'current field value',
  formValue: { /* entire form state */ },
  fieldPath: 'fieldName',
  externalData: { /* external application state, if configured */ }
}
```

### External Data

When you configure `externalData` in your FormConfig, it becomes available in expressions:

```typescript
const config = {
  externalData: {
    userRole: computed(() => authService.role()),
    permissions: computed(() => authService.permissions()),
  },
  fields: [
    {
      key: 'adminField',
      type: 'input',
      logic: [
        {
          type: 'hidden',
          condition: {
            type: 'javascript',
            expression: "externalData.userRole !== 'admin'",
          },
        },
      ],
    },
  ],
} as const satisfies FormConfig;
```

## Common Form Use Cases

### Dynamic Visibility

```typescript
{
  key: 'companyName',
  type: 'input',
  value: '',
  label: 'Company Name',
  // Show only if user selects "Employed"
  logic: [
    {
      type: 'hidden',
      condition: {
        type: 'javascript',
        expression: 'formValue.employmentStatus !== "employed"'
      }
    }
  ]
}
```

### Conditional Required

```typescript
{
  key: 'taxId',
  type: 'input',
  value: '',
  label: 'Tax ID',
  // Required only for business accounts
  logic: [
    {
      type: 'required',
      condition: {
        type: 'javascript',
        expression: 'formValue.accountType === "business"'
      },
    }
  ]
}
```

### Complex Conditions

```typescript
{
  key: 'personalConcierge',
  type: 'checkbox',
  value: false,
  label: 'Request Personal Concierge Service',
  logic: [
    {
      type: 'hidden',
      condition: {
        type: 'javascript',
        expression: 'formValue.membershipLevel !== "vip" || formValue.annualIncome < 100000'
      }
    }
  ]
}
```

### String Methods in Expressions

```typescript
{
  key: 'discountCode',
  type: 'input',
  value: '',
  label: 'Discount Code',
  logic: [
    {
      type: 'required',
      condition: {
        type: 'javascript',
        expression: 'formValue.email.endsWith("@company.com")'
      },
    }
  ]
}
```

## What the Parser Prevents

For dynamic forms, the parser prevents:

- ✅ **Code Injection**: Can't execute arbitrary code or create new code
- ✅ **Prototype Pollution**: Can't access `constructor` or `__proto__`
- ✅ **Unsafe Operations**: Can't call methods that modify state or access globals

## Custom Functions

When providing custom functions for use in expressions, register them with the FunctionRegistryService:

```typescript
// ✅ GOOD - Pure functions
import { FunctionRegistryService } from '@ng-forge/dynamic-forms';

const functionRegistry = inject(FunctionRegistryService);

functionRegistry.registerCustomFunction('isValidEmail', (ctx) => {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(ctx.fieldValue);
});

functionRegistry.registerCustomFunction('isAdult', (ctx) => {
  return ctx.formValue.age >= 18;
});
```

Then use them with `type: 'custom'`:

```typescript
{
  key: 'adultContent',
  type: 'checkbox',
  value: false,
  label: 'Access Adult Content',
  logic: [
    {
      type: 'hidden',
      condition: {
        type: 'custom',
        expression: 'isAdult'
      }
    }
  ]
}
```

**Important**: Only provide pure functions without side effects:

```typescript
// ❌ BAD - Side effects
functionRegistry.registerCustomFunction('logValue', (ctx) => {
  console.log(ctx.fieldValue); // Side effect!
  trackAnalytics(ctx); // Side effect!
  return true;
});
```

## Supported Expression Features

In JavaScript expressions (`type: 'javascript'`), you can use:

| Feature               | Examples                                                        |
| --------------------- | --------------------------------------------------------------- |
| **Property access**   | `formValue.name`, `formValue.user.profile.email`                |
| **Comparisons**       | `===`, `!==`, `>`, `<`, `>=`, `<=`                              |
| **Logical operators** | `&&`, `\|\|`, `!`                                               |
| **Arithmetic**        | `+`, `-`, `*`, `/`, `%`                                         |
| **String methods**    | See [Whitelisted Methods](#whitelisted-methods-reference) above |
| **Array methods**     | See [Whitelisted Methods](#whitelisted-methods-reference) above |

**Example**:

```typescript
expression: 'formValue.age >= 18 && formValue.email.includes("@example.com")';
```

**Not Supported**: Object literals `{}`, ternary `a ? b : c`, assignment `x = 5`, `new` keyword, function declarations

## Summary

The expression parser lets you write flexible conditional logic while preventing code injection attacks:

1. **Form state is accessible** - Any field in `formValue` can be read
2. **Methods are restricted** - Only safe, non-mutating methods allowed
3. **Prototype is protected** - Can't access dangerous properties
4. **Custom functions supported** - Register pure functions for reusable logic

--- advanced/type-safety/basics ---

Complete type inference for form configurations using TypeScript's type system and Angular signal forms.

## Overview

Dynamic Forms provides compile-time type inference for form configurations, eliminating manual type definitions and catching errors before runtime. All form values are automatically inferred from your configuration using TypeScript's advanced type features.

## Basic Type Inference

Use `as const satisfies FormConfig` to enable type inference:

```typescript
import { FormConfig } from '@ng-forge/dynamic-forms';

const formConfig = {
  fields: [
    { key: 'firstName', type: 'input', value: '' },
    { key: 'email', type: 'input', value: '' },
    { key: 'age', type: 'input', value: 0, props: { type: 'number' } },
    { key: 'newsletter', type: 'checkbox', value: false },
  ],
} as const satisfies FormConfig;

// Type is automatically inferred based on value property:
// { firstName?: string; email?: string; age?: number; newsletter?: boolean }
```

**How it works:**

1. `as const` makes the configuration deeply readonly, preserving literal types
2. `satisfies FormConfig` validates the config structure without widening types
3. TypeScript infers the form value type from the `value` properties

## The `value` Property

The `value` property is critical for type inference - its type determines the inferred field type:

```typescript
const config = {
  fields: [
    { key: 'name', type: 'input', value: '' }, // string
    { key: 'age', type: 'input', value: 0 }, // number
    { key: 'active', type: 'checkbox', value: false }, // boolean
    { key: 'tags', type: 'multi-checkbox', value: [] }, // string[]
  ],
} as const satisfies FormConfig;

// Inferred type:
// {
//   name?: string;
//   age?: number;
//   active?: boolean;
//   tags?: string[];
// }
```

## Field Registry System

UI integrations register their field types via `provideDynamicForm`. For example, with Material Design:

```typescript
// app.config.ts
import { provideDynamicForm } from '@ng-forge/dynamic-forms';
import { withMaterialFields } from '@ng-forge/dynamic-forms-material';

export const appConfig: ApplicationConfig = {
  providers: [
    provideDynamicForm(...withMaterialFields()),
    // other providers
  ],
};
```

Material fields augment the `FieldRegistryLeaves` interface for type safety:

```typescript
// From @ng-forge/dynamic-forms-material (already included)
declare module '@ng-forge/dynamic-forms' {
  interface FieldRegistryLeaves {
    input: MatInputField;
    select: MatSelectField<unknown>;
    checkbox: MatCheckboxField;
    // ... other Material fields
  }
}
```

This determines:

- What field `type` values are valid (e.g., `'input'`, `'select'`)
- How each field type is structured
- What props are available for each field

**Example - Wrong field type:**

```typescript
const config = {
  fields: [
    { key: 'name', type: 'invalid', value: '' }, // TypeScript error!
  ],
} as const satisfies FormConfig;
```

## Required vs Optional Fields

The `required` flag affects whether fields include `undefined` in their type:

```typescript
const config = {
  fields: [
    { key: 'email', type: 'input', value: '', required: true }, // string (required)
    { key: 'name', type: 'input', value: '' }, // string | undefined
    { key: 'age', type: 'input', value: 0, required: false }, // number | undefined
  ],
} as const satisfies FormConfig;

// Inferred type:
// {
//   email: string;           // Required - no undefined
//   name?: string;           // Optional - includes undefined
//   age?: number;            // Optional - includes undefined
// }
```

**In practice:**

```typescript
function handleSubmit(value: InferFormValue<typeof config.fields>) {
  console.log(value.email.toUpperCase()); // ✓ Safe - always defined
  console.log(value.name?.toUpperCase()); // ✓ Must use optional chaining
  console.log(value.age + 1); // ✗ Error - might be undefined
}
```

## Using InferFormValue

Extract the inferred type for use in your component:

```typescript
import { signal } from '@angular/core';
import { InferFormValue } from '@ng-forge/dynamic-forms';

@Component({...})
export class UserFormComponent {
  config = {
    fields: [
      { key: 'username', type: 'input', value: '', required: true },
      { key: 'age', type: 'input', value: 0 },
    ]
  } as const satisfies FormConfig;

  // Extract type for signal
  formValue = signal<InferFormValue<typeof this.config.fields>>({
    username: '',
  });

  onSubmit() {
    const value = this.formValue();
    console.log(value.username);  // ✓ Type: string (required)
    console.log(value.age);       // ✓ Type: number | undefined (optional)
  }
}
```

## IntelliSense Support

TypeScript provides autocomplete for form values throughout your code:

```typescript
const config = {
  fields: [
    { key: 'firstName', type: 'input', value: '' },
    { key: 'lastName', type: 'input', value: '' },
    { key: 'email', type: 'input', value: '', required: true },
  ],
} as const satisfies FormConfig;

type FormValue = InferFormValue<typeof config.fields>;

function processForm(value: FormValue) {
  // IntelliSense suggests: firstName, lastName, email
  value.firstName; // ✓ Autocomplete works
  value.lastName; // ✓ Autocomplete works
  value.email; // ✓ Autocomplete works
  value.invalid; // ✗ TypeScript error - property doesn't exist
}
```

## Best Practices

### Always Use `as const satisfies FormConfig`

This enables type inference and validates your configuration:

```typescript
// ✓ Correct - enables inference + type checking
const config = { fields: [...] } as const satisfies FormConfig;

// ✗ Wrong - no inference
const config = { fields: [...] };

// ✗ Wrong - too wide, loses precision
const config: FormConfig = { fields: [...] };
```

### Define Configs as Constants

Export form configs as constants for reuse and consistent typing:

```typescript
// form-configs.ts
export const USER_FORM = {
  fields: [
    { key: 'name', type: 'input', value: '', required: true },
    { key: 'email', type: 'input', value: '', required: true },
  ],
} as const satisfies FormConfig;

// user-form.component.ts
import { USER_FORM } from './form-configs';

@Component({...})
export class UserFormComponent {
  config = USER_FORM;
}
```

### Always Include `value` Property

Type inference requires the `value` property to determine field types:

```typescript
// ✓ Good - type inferred from value
const config = {
  fields: [
    { key: 'age', type: 'input', value: 0 }, // number
    { key: 'name', type: 'input', value: '' }, // string
    { key: 'active', type: 'checkbox', value: false }, // boolean
  ],
} as const satisfies FormConfig;

// ✗ Bad - without value, type inference may not work correctly
const config = {
  fields: [
    { key: 'age', type: 'input' }, // Type unclear
  ],
} as const satisfies FormConfig;
```

### Extract Types When Needed

Create type aliases for complex form values:

```typescript
import { InferFormValue } from '@ng-forge/dynamic-forms';

const REGISTRATION_FORM = {
  fields: [
    { key: 'username', type: 'input', value: '', required: true },
    { key: 'email', type: 'input', value: '', required: true },
    { key: 'password', type: 'input', value: '', required: true },
  ],
} as const satisfies FormConfig;

// Export type for reuse
export type RegistrationFormValue = InferFormValue<(typeof REGISTRATION_FORM)['fields']>;

// Use in functions
function registerUser(data: RegistrationFormValue) {
  console.log(data.username, data.email, data.password);
}
```

## Troubleshooting

### Type inference not working

Type inference requires `as const` - without it, TypeScript treats your config as mutable:

```typescript
// ✗ No inference - types are too wide
const config = {
  fields: [{ key: 'name', type: 'input', value: '' }],
};
// Type: { fields: { key: string; type: string; value: string }[] }

// ✓ With as const - precise inference
const config = {
  fields: [{ key: 'name', type: 'input', value: '' }],
} as const satisfies FormConfig;
// Type inferred: { name?: string }
```

### `satisfies` vs type annotation

Don't use type annotation (`const config: FormConfig = ...`) as it widens types:

```typescript
// ✗ Wrong - type is widened, inference fails
const config: FormConfig = {
  fields: [{ key: 'name', type: 'input', value: '' }],
} as const;

// ✓ Correct - satisfies validates without widening
const config = {
  fields: [{ key: 'name', type: 'input', value: '' }],
} as const satisfies FormConfig;
```

### Dynamic form configs

Type inference only works for **static**, **compile-time constant** configurations:

```typescript
// ✗ Dynamic - no inference possible
const fields = getFieldsFromAPI(); // Returns field array at runtime
const config = { fields } as const satisfies FormConfig;
// Can't infer - TypeScript doesn't know what getFieldsFromAPI() returns

// For dynamic forms, manually type your form values:
interface MyFormValue {
  name: string;
  email: string;
}

const formValue = signal<MyFormValue>({ name: '', email: '' });
```

If your form configuration is built dynamically (from API data, conditional logic, or runtime calculations), you'll need to manually define the form value type.

## Container Fields

Understanding how container fields affect type inference and form value structure.

### Container Fields Overview

Container fields organize form layout and structure without directly contributing values. There are three types:

- **Group Fields** - Nest children under a single key
- **Row Fields** - Organize fields horizontally, flatten children to parent level
- **Page Fields** - Multi-step forms, flatten children to parent level

Each container type has different behavior for type inference and form values.

### Group Fields

Groups nest children under a single key, creating nested objects in the form value:

```typescript
const config = {
  fields: [
    {
      type: 'group',
      key: 'address',
      label: 'Address Information',
      fields: [
        { key: 'street', type: 'input', value: '' },
        { key: 'city', type: 'input', value: '' },
        { key: 'zip', type: 'input', value: '' },
      ],
    },
  ],
} as const satisfies FormConfig;

// Inferred type:
// {
//   address: {
//     street?: string;
//     city?: string;
//     zip?: string;
//   }
// }
```

**Use groups when:**

- You want nested form values (e.g., `address.street`)
- Grouping related fields logically
- Creating reusable field sections

**Example - Nested address:**

```typescript
const config = {
  fields: [
    { key: 'name', type: 'input', value: '', required: true },
    {
      type: 'group',
      key: 'address',
      fields: [
        { key: 'street', type: 'input', value: '', required: true },
        { key: 'city', type: 'input', value: '', required: true },
        { key: 'state', type: 'select', value: '', required: true, options: [] },
        { key: 'zip', type: 'input', value: '' },
      ],
    },
  ],
} as const satisfies FormConfig;

// Form value structure:
// {
//   name: string;
//   address: {
//     street: string;
//     city: string;
//     state: string;
//     zip?: string;
//   }
// }

function onSubmit(value: InferFormValue<typeof config.fields>) {
  console.log(value.name); // string
  console.log(value.address.street); // string
  console.log(value.address.city); // string
  console.log(value.address.zip); // string | undefined
}
```

### Row Fields

Rows organize fields horizontally for layout purposes, but flatten children to the parent level in form values:

```typescript
const config = {
  fields: [
    {
      type: 'row',
      fields: [
        { key: 'firstName', type: 'input', value: '' },
        { key: 'lastName', type: 'input', value: '' },
      ],
    },
  ],
} as const satisfies FormConfig;

// Inferred type (flattened):
// {
//   firstName?: string;
//   lastName?: string;
// }
```

**Use rows when:**

- You want horizontal layout (grid columns)
- Fields should be at the parent level (not nested)
- Creating responsive multi-column forms

**Row vs Group:**

```typescript
// Row - fields are flattened
{
  type: 'row',
  fields: [
    { key: 'firstName', type: 'input', value: '' },
    { key: 'lastName', type: 'input', value: '' },
  ],
}
// Result: { firstName?: string, lastName?: string }

// Group - fields are nested
{
  type: 'group',
  key: 'name',
  fields: [
    { key: 'firstName', type: 'input', value: '' },
    { key: 'lastName', type: 'input', value: '' },
  ],
}
// Result: { name: { firstName?: string, lastName?: string } }
```

### Page Fields

Pages organize multi-step forms, flattening all children to the root level:

```typescript
const config = {
  fields: [
    {
      key: 'page1',
      type: 'page',
      fields: [
        { key: 'page1Title', type: 'text', label: 'Personal Information', props: { elementType: 'h3' } },
        { key: 'email', type: 'input', value: '' },
        { key: 'password', type: 'input', value: '' },
      ],
    },
    {
      key: 'page2',
      type: 'page',
      fields: [
        { key: 'page2Title', type: 'text', label: 'Profile Details', props: { elementType: 'h3' } },
        { key: 'firstName', type: 'input', value: '' },
        { key: 'lastName', type: 'input', value: '' },
      ],
    },
  ],
} as const satisfies FormConfig;

// Inferred type (all pages flattened):
// {
//   email?: string;
//   password?: string;
//   firstName?: string;
//   lastName?: string;
// }
```

**Use pages when:**

- Creating multi-step forms (wizard-style)
- Fields from all steps should be at root level
- You want step-by-step validation

### Nesting Rules

Container fields enforce nesting constraints at compile-time to prevent invalid structures.

**Visual Reference:**

```
┌─────────────────────────────────────────────────────────────┐
│                      NESTING RULES                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  PAGE ──────┬──► ROW ────────┬──► GROUP ──┬──► LEAF FIELD  │
│             │                │            │                 │
│             ├──► GROUP ──────┼──► ROW ────┴──► LEAF FIELD  │
│             │                │                              │
│             └──► LEAF FIELD  └──► LEAF FIELD               │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│  ✗ PAGE cannot contain PAGE                                 │
│  ✗ ROW cannot contain ROW or PAGE                          │
│  ✗ GROUP cannot contain GROUP or PAGE                      │
└─────────────────────────────────────────────────────────────┘
```

**Valid Nesting:**

- **Pages** can contain: rows, groups, leaf fields (not other pages)
- **Rows** can contain: groups, leaf fields (not pages or rows)
- **Groups** can contain: rows, leaf fields (not pages or other groups)

**Invalid Nesting:**

TypeScript will prevent these invalid structures:

```typescript
// ✗ Invalid: page inside page
const config1 = {
  fields: [
    {
      type: 'page',
      fields: [
        { type: 'page', fields: [] }, // TypeScript error!
      ],
    },
  ],
} as const satisfies FormConfig;

// ✗ Invalid: row inside row
const config2 = {
  fields: [
    {
      type: 'row',
      fields: [
        { type: 'row', fields: [] }, // TypeScript error!
      ],
    },
  ],
} as const satisfies FormConfig;
```

### Value-Bearing vs Display Fields

Fields are categorized by whether they contribute to form values:

**Value-Bearing Fields:**

Fields with a `value` property contribute to the form output:

- `input`, `select`, `checkbox`, `textarea`, `datepicker`, `slider`, `toggle`, etc.

**Display-Only Fields:**

Fields without values are excluded from form values:

- `text` - displays content
- `page`, `row`, `group` - container fields (children may have values)
- Buttons - `submit`, `reset`, navigation buttons
- Custom display components

```typescript
const config = {
  fields: [
    { type: 'text', label: 'Enter your details:' }, // ✗ Excluded
    { key: 'name', type: 'input', value: '' }, // ✓ Included
    { type: 'submit', label: 'Save' }, // ✗ Excluded
    {
      type: 'row', // ✗ Excluded (container)
      fields: [
        { key: 'city', type: 'input', value: '' }, // ✓ Included
      ],
    },
  ],
} as const satisfies FormConfig;

// Only value-bearing fields:
// {
//   name?: string;
//   city?: string;
// }
```

### Array Fields

Multi-select fields and multi-checkbox fields return arrays:

```typescript
const config = {
  fields: [
    {
      key: 'skills',
      type: 'select',
      value: [],
      props: { multiple: true },
      options: [
        { value: 'js', label: 'JavaScript' },
        { value: 'ts', label: 'TypeScript' },
        { value: 'go', label: 'Go' },
      ],
    },
    {
      key: 'interests',
      type: 'multi-checkbox',
      value: [],
      options: [
        { value: 'sports', label: 'Sports' },
        { value: 'music', label: 'Music' },
        { value: 'reading', label: 'Reading' },
      ],
    },
  ],
} as const satisfies FormConfig;

// Type: { skills?: string[]; interests?: string[] }
```

## Advanced Patterns

### Runtime Validation

Form values are typed at compile-time via `InferFormValue`, but runtime validation may be needed:

#### Type Assertion (Trust Form Structure)

If you trust the form structure, cast the value:

```typescript
import { InferFormValue } from '@ng-forge/dynamic-forms';

const USER_FORM = {
  fields: [
    { key: 'username', type: 'input', value: '', required: true },
    { key: 'email', type: 'input', value: '', required: true },
    { key: 'age', type: 'input', value: 0 },
  ],
} as const satisfies FormConfig;

type UserFormValue = InferFormValue<(typeof USER_FORM)['fields']>;

function onSubmit(value: unknown) {
  // Cast to inferred type
  const data = value as UserFormValue;

  console.log(data.username); // string
  console.log(data.email); // string
  console.log(data.age); // number | undefined
}
```

#### Runtime Validation with Zod

For runtime guarantees, use a validation library like Zod:

```typescript
import { z } from 'zod';
import { InferFormValue } from '@ng-forge/dynamic-forms';

const USER_FORM = {
  fields: [
    { key: 'username', type: 'input', value: '', required: true },
    { key: 'email', type: 'input', value: '', required: true },
    { key: 'age', type: 'input', value: 0 },
  ],
} as const satisfies FormConfig;

// Define Zod schema matching form structure
const userSchema = z.object({
  username: z.string().min(1),
  email: z.string().email(),
  age: z.number().optional(),
});

function onSubmit(value: unknown) {
  // Runtime validation
  const result = userSchema.safeParse(value);

  if (!result.success) {
    console.error('Validation failed:', result.error);
    return;
  }

  // Type-safe access
  const data = result.data;
  console.log(data.username); // string
  console.log(data.email); // string
  console.log(data.age); // number | undefined
}
```

#### Combining Compile-Time and Runtime

Use both for maximum safety:

```typescript
import { z } from 'zod';
import { InferFormValue } from '@ng-forge/dynamic-forms';

const REGISTRATION_FORM = {
  fields: [
    { key: 'username', type: 'input', value: '', required: true },
    { key: 'email', type: 'input', value: '', required: true },
    { key: 'password', type: 'input', value: '', required: true },
    { key: 'confirmPassword', type: 'input', value: '', required: true },
  ],
} as const satisfies FormConfig;

// Compile-time type
type RegistrationValue = InferFormValue<typeof REGISTRATION_FORM['fields']>;

// Runtime schema (with additional validation)
const registrationSchema = z.object({
  username: z.string().min(3).max(20),
  email: z.string().email(),
  password: z.string().min(8),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ['confirmPassword'],
});

@Component({...})
export class RegistrationComponent {
  config = REGISTRATION_FORM;

  // Compile-time type for signal
  formValue = signal<RegistrationValue>({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
  });

  onSubmit() {
    const value = this.formValue();

    // Runtime validation with cross-field check
    const result = registrationSchema.safeParse(value);

    if (!result.success) {
      console.error('Validation failed:', result.error);
      return;
    }

    // Safe to use
    this.register(result.data);
  }
}
```

### Type-Safe Validation

ng-forge integrates validation with the type system. Validators affect the inferred type:

#### Shorthand Validators

Shorthand validators are simple and affect type inference:

```typescript
const config = {
  fields: [
    {
      key: 'email',
      type: 'input',
      value: '',
      required: true, // Removes undefined from type
      email: true, // Email validation
      minLength: 5, // Min length validation
    },
  ],
} as const satisfies FormConfig;

// Type inferred: { email: string } (required, so no undefined)
```

#### Validator Array

For complex validation, use the `validators` array:

```typescript
const config = {
  fields: [
    {
      key: 'discount',
      type: 'input',
      value: 0,
      validators: [
        {
          type: 'min',
          value: 0,
        },
        {
          type: 'max',
          value: 100,
          when: {
            type: 'fieldValue',
            fieldPath: 'discountType',
            operator: 'equals',
            value: 'percentage',
          },
        },
      ],
    },
  ],
} as const satisfies FormConfig;
```

#### Conditional Required

Use the `logic` array for conditional required fields:

```typescript
const config = {
  fields: [
    { key: 'accountType', type: 'select', value: '', options: [] },
    {
      key: 'taxId',
      type: 'input',
      value: '',
      logic: [
        {
          type: 'required',
          condition: {
            type: 'fieldValue',
            fieldPath: 'accountType',
            operator: 'equals',
            value: 'business',
          },
        },
      ],
    },
  ],
} as const satisfies FormConfig;

// Type: { accountType?: string; taxId?: string }
// Note: Conditional required doesn't affect type inference
```

## Related

- **[Validation](../../validation/basics/)** - How validators affect inferred types
- **[Field Types](../../schema-fields/field-types/)** - Understanding available field types
- **[Form Layout](../../prebuilt/form-groups/)** - Visual guide to container fields

--- advanced/value-exclusion ---

Value exclusion controls which field values are included in the form submission output based on the field's reactive state (hidden, disabled, readonly).

## Overview

By default, field values are **excluded** from the `(submitted)` output when the field is hidden, disabled, or readonly. This prevents stale or irrelevant data from being sent to the server.

**Key point:** Value exclusion only affects the submission output. Internal form controls retain their values so they can be restored when a field becomes visible, enabled, or editable again. Two-way binding via `[value]` / `[(value)]` is **not affected**.

## Default Behavior

When no configuration is specified, the defaults are:

| Rule                     | Default | Effect                                              |
| ------------------------ | ------- | --------------------------------------------------- |
| `excludeValueIfHidden`   | `true`  | Hidden field values are excluded from submission    |
| `excludeValueIfDisabled` | `true`  | Disabled field values are excluded from submission  |
| `excludeValueIfReadonly` | `true`  | Read-only field values are excluded from submission |

> **Breaking change from pre-1.0:** Previously, all field values were always included. To restore the old behavior, see [Migration from Previous Versions](#migration-from-previous-versions).

## 3-Tier Configuration

Value exclusion supports a 3-tier configuration hierarchy. The most specific level wins for each property:

| Priority | Level  | Where to set                                    |
| -------- | ------ | ----------------------------------------------- |
| 1 (wins) | Field  | `excludeValueIf*` on individual `FieldDef`      |
| 2        | Form   | `excludeValueIf*` on `FormOptions`              |
| 3        | Global | `withValueExclusionDefaults()` feature function |

If a property is `undefined` at a given level, the next level down is checked.

## Global Configuration

Use `withValueExclusionDefaults()` in your provider setup to configure global defaults:

```typescript
import { provideDynamicForm, withValueExclusionDefaults } from '@ng-forge/dynamic-forms';

// All exclusions enabled (same as default)
provideDynamicForm(...withMaterialFields(), withValueExclusionDefaults());

// Disable readonly exclusion globally
provideDynamicForm(...withMaterialFields(), withValueExclusionDefaults({ excludeValueIfReadonly: false }));

// Disable all exclusions globally (pre-1.0 behavior)
provideDynamicForm(
  ...withMaterialFields(),
  withValueExclusionDefaults({
    excludeValueIfHidden: false,
    excludeValueIfDisabled: false,
    excludeValueIfReadonly: false,
  }),
);
```

## Form-Level Configuration

Override the global setting for a specific form using `FormOptions`:

```typescript
const config: FormConfig = {
  fields: [...],
  options: {
    // Include hidden field values for this form only
    excludeValueIfHidden: false,
    // Use global default for disabled and readonly
  }
};
```

## Field-Level Configuration

Override both global and form settings for a specific field:

```typescript
const config: FormConfig = {
  fields: [
    {
      type: 'input',
      key: 'internalId',
      label: 'Internal ID',
      readonly: true,
      // Always include this field's value, even when readonly
      excludeValueIfReadonly: false,
    },
    {
      type: 'input',
      key: 'notes',
      label: 'Notes',
      // This field uses the form/global defaults
    },
  ],
};
```

## Resolution Example

Given these settings:

- **Global:** `excludeValueIfHidden: true`
- **Form:** `excludeValueIfHidden: false`
- **Field A:** `excludeValueIfHidden: undefined` (not set)
- **Field B:** `excludeValueIfHidden: true`

Resolution:

- **Field A** uses form-level (`false`) because field-level is `undefined` &rarr; value is **included** when hidden
- **Field B** uses field-level (`true`) &rarr; value is **excluded** when hidden

## HiddenField Type

The `HiddenField` type (`type: 'hidden'`) is **not affected** by value exclusion. These fields:

- Store values without rendering any UI
- Have a `hidden()` reactive state of `false` (they are part of the form, just not rendered)
- Are always included in submission output

Value exclusion applies to the `hidden` **property** on regular fields (e.g., `{ type: 'input', hidden: true }` or fields hidden via conditional logic), not to the `HiddenField` type.

## What's Excluded vs Retained

| Aspect                     | Affected by exclusion? | Details                                  |
| -------------------------- | ---------------------- | ---------------------------------------- |
| `(submitted)` output       | Yes                    | Excluded fields are omitted              |
| `filteredFormValue` signal | Yes                    | Same filtering as submission             |
| `formValue` signal         | No                     | Always contains all values               |
| `[(value)]` binding        | No                     | Two-way binding retains all values       |
| Internal form controls     | No                     | Fields keep their values for restoration |

## Migration from Previous Versions

If you relied on all field values being present in `(submitted)` output, disable exclusion globally:

```typescript
provideDynamicForm(
  ...withMaterialFields(),
  withValueExclusionDefaults({
    excludeValueIfHidden: false,
    excludeValueIfDisabled: false,
    excludeValueIfReadonly: false,
  }),
);
```

Or disable per-form via `FormOptions`:

```typescript
const config: FormConfig = {
  fields: [...],
  options: {
    excludeValueIfHidden: false,
    excludeValueIfDisabled: false,
    excludeValueIfReadonly: false,
  }
};
```

--- ai-integration ---

# AI Integration

The `@ng-forge/dynamic-form-mcp` package provides a [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) server that enables AI assistants to generate, validate, and work with ng-forge dynamic form configurations.

## Available Tools

The MCP server provides 4 focused tools:

| Tool               | Description                                                 | Read-only |
| ------------------ | ----------------------------------------------------------- | --------- |
| `ngforge_lookup`   | Get documentation about field types, concepts, and patterns | ✅        |
| `ngforge_examples` | Get working code examples for common form patterns          | ✅        |
| `ngforge_validate` | Validate FormConfig and get detailed error feedback         | ✅        |
| `ngforge_scaffold` | Generate valid FormConfig skeletons                         | ✅        |

## Get Started

### Cursor

Add to your Cursor MCP settings:

```json
{
  "ng-forge": {
    "command": "npx",
    "args": ["-y", "@ng-forge/dynamic-form-mcp"]
  }
}
```

### VS Code with Copilot

Create `.vscode/mcp.json` in your project:

```json
{
  "servers": {
    "ng-forge": {
      "command": "npx",
      "args": ["-y", "@ng-forge/dynamic-form-mcp"]
    }
  }
}
```

### Claude Desktop

Add to `~/Library/Application Support/Claude/claude_desktop_config.json` (macOS):

```json
{
  "mcpServers": {
    "ng-forge": {
      "command": "npx",
      "args": ["-y", "@ng-forge/dynamic-form-mcp"]
    }
  }
}
```

### JetBrains IDEs

Go to **Settings > Tools > AI Assistant > Model Context Protocol (MCP)** and add:

| Field     | Value                         |
| --------- | ----------------------------- |
| Name      | ng-forge                      |
| Command   | npx                           |
| Arguments | -y @ng-forge/dynamic-form-mcp |

---

## Tool Reference

### ngforge_lookup

Get documentation about any ng-forge topic.

| Parameter       | Type                                                      | Default    | Description             |
| --------------- | --------------------------------------------------------- | ---------- | ----------------------- |
| `topic`         | string                                                    | (required) | Topic to look up        |
| `depth`         | `"brief"` \| `"full"` \| `"schema"`                       | `"full"`   | Level of detail         |
| `uiIntegration` | `"material"` \| `"bootstrap"` \| `"primeng"` \| `"ionic"` | -          | Filter UI-specific info |

**Available Topics:**

| Category    | Topics                                                                                                                                                                                                                                                     |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Field Types | `input`, `select`, `radio`, `checkbox`, `textarea`, `datepicker`, `slider`, `toggle`, `hidden`, `text`, `button`, `submit`, `next`, `previous`, `addArrayItem`, `prependArrayItem`, `insertArrayItem`, `removeArrayItem`, `popArrayItem`, `shiftArrayItem` |
| Containers  | `group`, `row`, `array`, `page`                                                                                                                                                                                                                            |
| Concepts    | `validation`, `conditional`, `derivation`, `options-format`, `expression-variables`, `async-validators`, `validation-messages`                                                                                                                             |
| Patterns    | `golden-path`, `multi-page-gotchas`, `pitfalls`, `workflow`                                                                                                                                                                                                |

**Examples:**

```
ngforge_lookup topic="hidden" depth="brief"
ngforge_lookup topic="conditional" depth="full"
ngforge_lookup topic="input" depth="schema" uiIntegration="material"
```

---

### ngforge_examples

Get working code examples for common patterns.

| Parameter | Type                                                  | Default    | Description     |
| --------- | ----------------------------------------------------- | ---------- | --------------- |
| `pattern` | string                                                | (required) | Pattern name    |
| `depth`   | `"minimal"` \| `"brief"` \| `"full"` \| `"explained"` | `"full"`   | Level of detail |

**Available Patterns:**

| Pattern               | Description                              | Lines |
| --------------------- | ---------------------------------------- | ----- |
| `minimal-multipage`   | Simplest 2-page wizard form              | ~50   |
| `minimal-array`       | Array with add/remove buttons            | ~30   |
| `minimal-conditional` | Show/hide field based on condition       | ~25   |
| `minimal-validation`  | Password confirmation validation         | ~20   |
| `minimal-hidden`      | Hidden fields in multi-page form         | ~15   |
| `derivation`          | Value derivation (computed fields)       | -     |
| `conditional`         | Conditional visibility patterns          | -     |
| `multi-page`          | Multi-step wizard forms                  | -     |
| `validation`          | Form validation patterns                 | -     |
| `complete`            | Full form with all major features        | -     |
| `mega`                | Kitchen sink demonstrating every feature | -     |

**Examples:**

```
ngforge_examples pattern="minimal-multipage" depth="minimal"
ngforge_examples pattern="conditional" depth="explained"
```

---

### ngforge_validate

Validate FormConfig and get detailed error feedback.

| Parameter       | Type                                                      | Default      | Description                    |
| --------------- | --------------------------------------------------------- | ------------ | ------------------------------ |
| `config`        | string \| object                                          | (required)   | File path or JSON config       |
| `uiIntegration` | `"material"` \| `"bootstrap"` \| `"primeng"` \| `"ionic"` | `"material"` | UI library to validate against |

**Input Detection:**

| Input                    | Treated As         |
| ------------------------ | ------------------ |
| Ends with `.ts` or `.js` | File path          |
| Starts with `{` or `[`   | JSON string        |
| Object                   | Validated directly |

**Example Errors:**

- "Hidden field missing REQUIRED value property"
- "options MUST be at FIELD level, NOT inside props"
- "row containers do NOT support logic blocks"

**Examples:**

```
ngforge_validate config="/path/to/form.config.ts"
ngforge_validate config='{"fields":[...]}' uiIntegration="bootstrap"
```

---

### ngforge_scaffold

Generate valid FormConfig skeletons.

| Parameter       | Type     | Default      | Description                           |
| --------------- | -------- | ------------ | ------------------------------------- |
| `pages`         | number   | `0`          | Number of pages (0 = single-page)     |
| `arrays`        | string[] | `[]`         | Array field names                     |
| `groups`        | string[] | `[]`         | Group field names                     |
| `hidden`        | string[] | `[]`         | Hidden fields as `"name:value"` pairs |
| `fields`        | string[] | `[]`         | Fields as `"name:type"` pairs         |
| `uiIntegration` | enum     | `"material"` | UI library                            |

**Supported Types for `fields`:**

`input`, `select`, `radio`, `checkbox`, `textarea`, `datepicker`, `slider`, `toggle`

**Examples:**

```
ngforge_scaffold pages=0 fields=["name:input","email:input"]
ngforge_scaffold pages=3 arrays=["contacts"] groups=["address"]
ngforge_scaffold hidden=["userId:abc123","source:web"]
```

---

## MCP Resources

In addition to tools, the server exposes resources that AI can read:

| Resource URI               | Description                                    |
| -------------------------- | ---------------------------------------------- |
| `ng-forge://instructions`  | Best practices guide for generating FormConfig |
| `ng-forge://examples`      | Curated FormConfig examples                    |
| `ng-forge://examples/{id}` | Specific example by ID                         |
| `ng-forge://field-types`   | Field type reference                           |
| `ng-forge://validators`    | Validator reference                            |
| `ng-forge://ui-adapters`   | UI library configurations                      |
| `ng-forge://docs`          | Full documentation index                       |

---

## Feedback

Found an issue or have a suggestion? [Open an issue on GitHub](https://github.com/ng-forge/ng-forge/issues).

--- dynamic-behavior/conditional-logic/overview ---

Control field behavior dynamically based on form state. Dynamic forms provides a declarative API for conditional visibility, required state, and readonly state that maps directly to Angular's signal forms.

## Signal Forms Integration

The library integrates with Angular's signal forms logic functions:

```typescript
import { hidden, readonly, required } from '@angular/forms/signals';
```

All conditional logic configuration is applied using these functions, providing:

- **Reactive updates** when form state changes
- **Type-safe** conditional expressions
- **Automatic re-evaluation** on dependencies
- **Integration** with form validation state

## Static Properties

Use simple boolean properties for fields with fixed states.

### hidden

Hide a field from view (field still participates in form state):

```typescript
{
  key: 'internalId',
  type: 'input',
  value: '',
  label: 'Internal ID',
  hidden: true,
}
```

The field is hidden from the UI but still included in the form value.

### disabled

Disable user interaction:

```typescript
{
  key: 'systemField',
  type: 'input',
  value: 'auto-generated',
  label: 'System Field',
  disabled: true,
}
```

**Note:** The `disabled` property is handled at the component level and does not use signal forms logic functions. It's a static UI property that prevents user interaction.

### readonly

Make a field read-only (displays value but prevents modification):

```typescript
{
  key: 'createdAt',
  type: 'input',
  value: '2024-01-15',
  label: 'Created Date',
  readonly: true,
}
```

## Dynamic Conditional Logic

For conditional behavior based on form state, use the `logic` array with `LogicConfig` objects.

```typescript
interface LogicConfig {
  /** Logic type */
  type: 'hidden' | 'readonly' | 'disabled' | 'required';

  /** Boolean expression, static value, or form state condition */
  condition: ConditionalExpression | boolean | FormStateCondition;
}
```

`FormStateCondition` values (`'formInvalid'`, `'formSubmitting'`, `'pageInvalid'`) are primarily used for button disabled logic.

### Conditional Visibility (hidden)

Show or hide fields based on other field values.

#### Show Email When Contact Method is Email

```typescript
{
  key: 'contactMethod',
  type: 'select',
  value: '',
  options: [
    { value: 'email', label: 'Email' },
    { value: 'phone', label: 'Phone' },
  ],
}
{
  key: 'email',
  type: 'input',
  value: '',
  label: 'Email Address',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'contactMethod',
      operator: 'notEquals',
      value: 'email',
    },
  }],
}
```

When `contactMethod !== 'email'`, the email field is hidden.

### Conditional Required

Make fields required based on conditions.

#### Tax ID Required for Business Accounts

```typescript
{
  key: 'accountType',
  type: 'radio',
  value: 'personal',
  options: [
    { value: 'personal', label: 'Personal' },
    { value: 'business', label: 'Business' },
  ],
}
{
  key: 'taxId',
  type: 'input',
  value: '',
  label: 'Tax ID',
  logic: [{
    type: 'required',
    condition: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'equals',
      value: 'business',
    },
  }],
}
```

### Conditional Readonly

Make fields read-only based on conditions.

#### Lock Field After Submission

```typescript
{
  key: 'status',
  type: 'select',
  value: 'draft',
  options: [
    { value: 'draft', label: 'Draft' },
    { value: 'submitted', label: 'Submitted' },
  ],
}
{
  key: 'documentNumber',
  type: 'input',
  value: '',
  label: 'Document Number',
  logic: [{
    type: 'readonly',
    condition: {
      type: 'fieldValue',
      fieldPath: 'status',
      operator: 'equals',
      value: 'submitted',
    },
  }],
}
```

Once status is "submitted", the document number becomes read-only.

## Basic Conditional Expression

The most common conditional expression checks a specific field's value:

```typescript
{
  type: 'fieldValue',
  fieldPath: 'fieldKey',
  operator: 'equals',
  value: 'expectedValue',
}
```

**Components:**

- `type: 'fieldValue'` - Check a specific field
- `fieldPath` - The field key to check
- `operator` - Comparison operator (see [All Operators](#all-operators))
- `value` - Value to compare against

## Quick Example

Show a field only when another field has a specific value:

```typescript
{
  key: 'email',
  type: 'input',
  value: '',
  label: 'Email Address',
  logic: [
    {
      type: 'hidden',
      condition: {
        type: 'fieldValue',
        fieldPath: 'contactMethod',
        operator: 'notEquals',
        value: 'email',
      },
    },
    {
      type: 'required',
      condition: {
        type: 'fieldValue',
        fieldPath: 'contactMethod',
        operator: 'equals',
        value: 'email',
      },
    },
  ],
}
```

This field is hidden unless `contactMethod === 'email'`, and required when visible. See the [Examples](/examples) page for complete form implementations.

## When Logic Runs

Conditional logic is evaluated:

- **On form value change** - Any time a dependent field changes
- **On initialization** - When the form is created
- **Reactively** - Uses Angular's signal forms for automatic updates

### Evaluation Flow

```
┌─────────────────────────────────────────────────────────────┐
│                    LOGIC EVALUATION FLOW                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Form Value Changes                                         │
│         │                                                   │
│         ▼                                                   │
│  ┌─────────────────┐                                       │
│  │ Signal Updates  │◄──── Angular's reactive system        │
│  └────────┬────────┘                                       │
│           │                                                 │
│           ▼                                                 │
│  ┌─────────────────┐                                       │
│  │ Evaluate logic  │                                       │
│  │    conditions   │                                       │
│  └────────┬────────┘                                       │
│           │                                                 │
│     ┌─────┴─────┐                                          │
│     ▼           ▼                                          │
│  ┌──────┐   ┌──────┐                                       │
│  │ true │   │false │                                       │
│  └──┬───┘   └──┬───┘                                       │
│     │          │                                            │
│     ▼          ▼                                            │
│  Apply      Remove                                          │
│  effect     effect                                          │
│  (hide,     (show,                                          │
│  require,   optional,                                       │
│  readonly)  editable)                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## Expression Types

### fieldValue

Check a specific field's value - the most common expression type.

```typescript
{
  type: 'fieldValue',
  fieldPath: 'accountType',
  operator: 'equals',
  value: 'business',
}
```

**Use when:** Checking a single field's value

**Example:**

```typescript
{
  key: 'companyName',
  type: 'input',
  value: '',
  logic: [{
    type: 'required',
    condition: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'equals',
      value: 'business',
    },
  }],
}
```

### formValue

Compare the entire form value object against a specific value using operators.

```typescript
{
  type: 'formValue',
  operator: 'equals',
  value: { status: 'active', role: 'admin' },
}
```

**Use when:** Checking if the entire form matches a specific state

**Note:** This type is rarely useful in practice — deep equality on an entire form object is an unusual requirement. For conditions that involve multiple specific fields, use `javascript` or `custom` expressions instead (e.g. `formValue.status === 'active' && formValue.role === 'admin'`).

### javascript

JavaScript expressions with access to `fieldValue` (current field) and `formValue` (entire form).

```typescript
{
  type: 'javascript',
  expression: 'new Date(fieldValue) > new Date()',
}
```

**Use when:** Custom logic on field value or complex multi-field conditions

**Examples:**

```typescript
// Check current field value
{
  key: 'eventDate',
  type: 'datepicker',
  value: null,
  logic: [{
    type: 'readonly',
    condition: {
      type: 'javascript',
      expression: 'new Date(fieldValue) < new Date()',
    },
  }],
}

// Check multiple form fields (replaces old formValue expression pattern)
{
  key: 'stateProvince',
  type: 'select',
  value: '',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'javascript',
      expression: 'formValue.country !== "US" && formValue.country !== "CA"',
    },
  }],
}
```

**Safe member access:** Accessing nested properties on `null` or `undefined` returns `undefined` (no errors thrown):

```typescript
{
  type: 'javascript',
  // Safe even when user, profile, or preferences is null/undefined
  expression: 'formValue.user.profile.preferences.notifications === true',
}
```

### custom

Advanced custom expressions with access to both field and form values.

```typescript
{
  type: 'custom',
  expression: 'fieldValue > formValue.minAge && fieldValue < formValue.maxAge',
}
```

**Safe member access:** Like `formValue` expressions, nested property access is safe:

```typescript
{
  type: 'custom',
  // Safe even when nested values are null/undefined
  expression: 'fieldValue !== formValue.user.profile.firstName',
}
```

### Field State in Expressions

`javascript` and `custom` expressions have access to two additional variables for querying field interaction state:

- **`fieldState`** — the current field's own state
- **`formFieldState`** — state of any field in the form, by key

#### fieldState

Use `fieldState` to react to the current field's own interaction state:

```typescript
// Lock the field as soon as the user edits it
{
  key: 'accountNumber',
  type: 'input',
  logic: [{
    type: 'readonly',
    condition: {
      type: 'javascript',
      expression: 'fieldState.dirty',
    },
  }],
}
```

**Available properties:**

| Property   | Type      | Description                         |
| ---------- | --------- | ----------------------------------- |
| `touched`  | `boolean` | User has focused and left the field |
| `dirty`    | `boolean` | User has changed the field value    |
| `pristine` | `boolean` | Equivalent to `!dirty`              |
| `valid`    | `boolean` | Field has no validation errors      |
| `invalid`  | `boolean` | Field has validation errors         |
| `pending`  | `boolean` | Async validation is in progress     |
| `hidden`   | `boolean` | Field is currently hidden           |
| `readonly` | `boolean` | Field is currently readonly         |
| `disabled` | `boolean` | Field is currently disabled         |

#### formFieldState

Use `formFieldState` to react to another field's state. Access by field key:

```typescript
// Make a field readonly once a related field has been touched
{
  key: 'billingAddress',
  type: 'input',
  logic: [{
    type: 'readonly',
    condition: {
      type: 'javascript',
      expression: 'formFieldState.shippingAddress.dirty',
    },
  }],
}
```

`formFieldState` has the same properties as `fieldState`, keyed by field name.

**Example — show a confirmation field only after the primary field is dirty:**

```typescript
{
  key: 'confirmEmail',
  type: 'input',
  label: 'Confirm Email',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'javascript',
      expression: '!formFieldState.email.dirty',
    },
  }],
}
```

### http

Evaluate a condition by sending an HTTP request and inspecting the response. The request fires automatically when declared query params change, with built-in debouncing.

```typescript
{
  type: 'http',
  http: {
    url: '/api/permissions',
    queryParams: {
      role: 'formValue.userRole',
    },
  },
  responseExpression: 'response.canEdit',
  pendingValue: false,
}
```

**Use when:** Field visibility or state must be determined server-side (permissions, feature flags, country-specific rules).

**Full example — hide an admin panel based on server permissions:**

```typescript
{
  key: 'adminPanel',
  type: 'input',
  label: 'Admin Panel Access Code',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'http',
      http: {
        url: '/api/permissions',
        queryParams: {
          role: 'formValue.userRole',
        },
      },
      responseExpression: 'response.hideAdminPanel',
      pendingValue: true, // Hide while checking
    },
  }],
}
```

**HTTP condition properties:**

| Property             | Type                | Required | Default      | Description                                                              |
| -------------------- | ------------------- | -------- | ------------ | ------------------------------------------------------------------------ |
| `type`               | `'http'`            | Yes      | —            | Identifies this as an HTTP condition                                     |
| `http`               | `HttpRequestConfig` | Yes      | —            | Request configuration (see below)                                        |
| `responseExpression` | `string`            | No       | `!!response` | Expression evaluated with `{ response }` in scope. Must return a boolean |
| `pendingValue`       | `boolean`           | No       | `false`      | Value returned while the request is in-flight                            |
| `cacheDurationMs`    | `number`            | No       | `30000`      | How long to cache responses (ms)                                         |
| `debounceMs`         | `number`            | No       | `300`        | Debounce delay before re-sending (ms)                                    |

**`HttpRequestConfig` quick reference:**

| Property                  | Description                                                                         |
| ------------------------- | ----------------------------------------------------------------------------------- |
| `url`                     | Request URL. Use `:key` placeholders for path parameters                            |
| `method`                  | HTTP method. Defaults to `'GET'`                                                    |
| `params`                  | Path parameters. `:key` placeholders in the URL replaced with evaluated expressions |
| `queryParams`             | Key/value map. Values are expressions evaluated against form context                |
| `body`                    | Request body for POST/PUT/PATCH                                                     |
| `evaluateBodyExpressions` | When `true`, top-level `body` string values are evaluated as expressions            |
| `headers`                 | Request headers                                                                     |

**HTTP condition on `required` — server-driven required fields:**

```typescript
{
  key: 'taxId',
  type: 'input',
  logic: [{
    type: 'required',
    condition: {
      type: 'http',
      http: {
        url: '/api/tax-rules',
        queryParams: { country: 'formValue.country' },
      },
      responseExpression: 'response.taxIdRequired',
      pendingValue: false, // Optional while checking
    },
  }],
}
```

### async

Evaluate a condition using a custom async function registered in `customFnConfig.asyncConditions`. Functions receive the full form context and must return a `Promise<boolean>` or `Observable<boolean>`.

```typescript
{
  type: 'async',
  asyncFunctionName: 'checkPermission',
  pendingValue: false,
}
```

**Use when:** Condition logic involves Angular service injection, complex async operations, or anything that `http` conditions cannot express directly.

> **Why `inject()` works here:** `customFnConfig` functions are called within an Angular injection context, so Angular's `inject()` API is available — the same way it works in a constructor or field initializer. Import `inject` from `@angular/core` as usual.

**Registration and usage:**

```typescript
import { inject } from '@angular/core';

const formConfig = {
  customFnConfig: {
    asyncConditions: {
      checkReadonly: (context) => {
        return inject(PermissionsService).canEdit(context.formValue.resourceId as string);
      },
    },
  },

  fields: [
    {
      key: 'salary',
      type: 'input',
      label: 'Salary',
      logic: [
        {
          type: 'readonly',
          condition: {
            type: 'async',
            asyncFunctionName: 'checkReadonly',
            pendingValue: false, // Editable while checking
          },
        },
      ],
    },
  ],
} as const satisfies FormConfig;
```

**Async condition properties:**

| Property            | Type      | Required | Default | Description                                         |
| ------------------- | --------- | -------- | ------- | --------------------------------------------------- |
| `type`              | `'async'` | Yes      | —       | Identifies this as an async condition               |
| `asyncFunctionName` | `string`  | Yes      | —       | Name registered in `customFnConfig.asyncConditions` |
| `pendingValue`      | `boolean` | No       | `false` | Value returned while the function is resolving      |
| `debounceMs`        | `number`  | No       | `300`   | Debounce delay before re-evaluating (ms)            |

**Choosing `pendingValue`:**

The right `pendingValue` depends on the logic type and desired UX:

| Logic type | `pendingValue: false`   | `pendingValue: true`    |
| ---------- | ----------------------- | ----------------------- |
| `hidden`   | Visible while checking  | Hidden while checking   |
| `required` | Optional while checking | Required while checking |
| `readonly` | Editable while checking | Readonly while checking |
| `disabled` | Enabled while checking  | Disabled while checking |

## All Operators

### Equality Operators

#### equals

Exact match comparison.

```typescript
{
  type: 'fieldValue',
  fieldPath: 'status',
  operator: 'equals',
  value: 'active',
}
```

#### notEquals

Not equal to comparison.

```typescript
{
  type: 'fieldValue',
  fieldPath: 'status',
  operator: 'notEquals',
  value: 'archived',
}
```

### Comparison Operators

#### greater

Greater than comparison (numbers/dates).

```typescript
{
  type: 'fieldValue',
  fieldPath: 'age',
  operator: 'greater',
  value: 18,
}
```

#### less

Less than comparison.

```typescript
{
  type: 'fieldValue',
  fieldPath: 'quantity',
  operator: 'less',
  value: 100,
}
```

#### greaterOrEqual

Greater than or equal to.

```typescript
{
  type: 'fieldValue',
  fieldPath: 'age',
  operator: 'greaterOrEqual',
  value: 21,
}
```

#### lessOrEqual

Less than or equal to.

```typescript
{
  type: 'fieldValue',
  fieldPath: 'discount',
  operator: 'lessOrEqual',
  value: 100,
}
```

### String Operators

#### contains

Check if string/array contains value.

```typescript
{
  type: 'fieldValue',
  fieldPath: 'email',
  operator: 'contains',
  value: '@company.com',
}
```

#### startsWith

Check if string starts with value.

```typescript
{
  type: 'fieldValue',
  fieldPath: 'url',
  operator: 'startsWith',
  value: 'https://',
}
```

#### endsWith

Check if string ends with value.

```typescript
{
  type: 'fieldValue',
  fieldPath: 'email',
  operator: 'endsWith',
  value: '.gov',
}
```

#### matches

Regular expression match.

```typescript
{
  type: 'fieldValue',
  fieldPath: 'zipCode',
  operator: 'matches',
  value: '^[0-9]{5}$',
}
```

## Combining Conditions

### AND Logic

All conditions must be true.

```typescript
{
  type: 'and',
  conditions: [
    {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'equals',
      value: 'business',
    },
    {
      type: 'fieldValue',
      fieldPath: 'hasTeam',
      operator: 'equals',
      value: true,
    },
    {
      type: 'fieldValue',
      fieldPath: 'teamSize',
      operator: 'greater',
      value: 5,
    },
  ],
}
```

**Use case:** Field required when all conditions are met.

```typescript
{
  key: 'enterpriseFeatures',
  type: 'checkbox',
  label: 'Enable Enterprise Features',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'and',
      conditions: [
        {
          type: 'fieldValue',
          fieldPath: 'accountType',
          operator: 'equals',
          value: 'business',
        },
        {
          type: 'fieldValue',
          fieldPath: 'plan',
          operator: 'equals',
          value: 'enterprise',
        },
      ],
    },
  }],
}
```

### OR Logic

At least one condition must be true.

```typescript
{
  type: 'or',
  conditions: [
    {
      type: 'fieldValue',
      fieldPath: 'role',
      operator: 'equals',
      value: 'admin',
    },
    {
      type: 'fieldValue',
      fieldPath: 'role',
      operator: 'equals',
      value: 'owner',
    },
  ],
}
```

**Use case:** Show field for multiple roles — hide unless role is `admin` or `owner`.

```typescript
// Hide the panel when role is neither 'admin' nor 'owner'
// (i.e. hidden when notEquals 'admin' AND notEquals 'owner')
{
  key: 'adminPanel',
  type: 'group',
  label: 'Administration',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'and',
      conditions: [
        {
          type: 'fieldValue',
          fieldPath: 'role',
          operator: 'notEquals',
          value: 'admin',
        },
        {
          type: 'fieldValue',
          fieldPath: 'role',
          operator: 'notEquals',
          value: 'owner',
        },
      ],
    },
  }],
}
```

### Nested Logic

Combine AND/OR logic for complex conditions.

```typescript
{
  type: 'and',
  conditions: [
    {
      type: 'fieldValue',
      fieldPath: 'country',
      operator: 'equals',
      value: 'US',
    },
    {
      type: 'or',
      conditions: [
        {
          type: 'fieldValue',
          fieldPath: 'age',
          operator: 'greaterOrEqual',
          value: 21,
        },
        {
          type: 'fieldValue',
          fieldPath: 'hasParentalConsent',
          operator: 'equals',
          value: true,
        },
      ],
    },
  ],
}
```

This means: "Country must be US AND (age >= 21 OR has parental consent)"

## Practical Examples

### Show Field Based on Multiple Conditions

```typescript
{
  key: 'internationalShipping',
  type: 'checkbox',
  label: 'Enable International Shipping',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'or',
      conditions: [
        {
          type: 'fieldValue',
          fieldPath: 'accountType',
          operator: 'equals',
          value: 'free',
        },
        {
          type: 'fieldValue',
          fieldPath: 'verified',
          operator: 'equals',
          value: false,
        },
      ],
    },
  }],
}
```

Hidden for free accounts OR unverified accounts.

### Required Field with Complex Logic

```typescript
{
  key: 'taxExemptionNumber',
  type: 'input',
  value: '',
  label: 'Tax Exemption Number',
  logic: [{
    type: 'required',
    condition: {
      type: 'and',
      conditions: [
        {
          type: 'fieldValue',
          fieldPath: 'accountType',
          operator: 'equals',
          value: 'business',
        },
        {
          type: 'fieldValue',
          fieldPath: 'claimsTaxExemption',
          operator: 'equals',
          value: true,
        },
        {
          type: 'or',
          conditions: [
            {
              type: 'fieldValue',
              fieldPath: 'country',
              operator: 'equals',
              value: 'US',
            },
            {
              type: 'fieldValue',
              fieldPath: 'country',
              operator: 'equals',
              value: 'CA',
            },
          ],
        },
      ],
    },
  }],
}
```

### Dynamic Read-Only Based on Status

```typescript
{
  key: 'orderItems',
  type: 'group',
  label: 'Order Items',
  logic: [{
    type: 'readonly',
    condition: {
      type: 'or',
      conditions: [
        {
          type: 'fieldValue',
          fieldPath: 'orderStatus',
          operator: 'equals',
          value: 'shipped',
        },
        {
          type: 'fieldValue',
          fieldPath: 'orderStatus',
          operator: 'equals',
          value: 'delivered',
        },
        {
          type: 'fieldValue',
          fieldPath: 'orderStatus',
          operator: 'equals',
          value: 'cancelled',
        },
      ],
    },
  }],
}
```

Order items become read-only once order is shipped, delivered, or cancelled.

## Best Practices

**Keep conditions readable:**

```typescript
// ✅ Good - Easy to understand
{
  type: 'fieldValue',
  fieldPath: 'accountType',
  operator: 'equals',
  value: 'business',
}

// ❌ Avoid - Hard to maintain
{
  type: 'formValue',
  expression: 'formValue.accountType === "business" && formValue.country !== null && formValue.hasTeam',
}
```

## ConditionalExpression Interface

`ConditionalExpression` is a discriminated union of all expression types:

```typescript
// Sync expressions
type ConditionalExpression =
  | { type: 'fieldValue'; fieldPath: string; operator: Operator; value: unknown }
  | { type: 'formValue'; operator: Operator; value: unknown }
  | { type: 'javascript'; expression: string }
  | { type: 'custom'; expression: string }
  | { type: 'and'; conditions: ConditionalExpression[] }
  | { type: 'or'; conditions: ConditionalExpression[] }
  // Async expressions
  | HttpCondition
  | AsyncCondition;

type Operator =
  | 'equals'
  | 'notEquals'
  | 'greater'
  | 'less'
  | 'greaterOrEqual'
  | 'lessOrEqual'
  | 'contains'
  | 'startsWith'
  | 'endsWith'
  | 'matches';

interface HttpCondition {
  type: 'http';
  http: HttpRequestConfig;
  responseExpression?: string; // Evaluated with { response }. Defaults to !!response
  pendingValue?: boolean; // Default: false
  cacheDurationMs?: number; // Default: 30000
  debounceMs?: number; // Default: 300
}

interface AsyncCondition {
  type: 'async';
  asyncFunctionName: string;
  pendingValue?: boolean; // Default: false
  debounceMs?: number; // Default: 300
}
```

**Expression types summary:**

| Type         | Sync/Async | Key properties                   | Purpose                                                               |
| ------------ | ---------- | -------------------------------- | --------------------------------------------------------------------- |
| `fieldValue` | Sync       | `fieldPath`, `operator`, `value` | Compare a specific field's value                                      |
| `formValue`  | Sync       | `operator`, `value`              | Compare entire form object                                            |
| `javascript` | Sync       | `expression`                     | Custom JS with `fieldValue`/`formValue`/`fieldState`/`formFieldState` |
| `custom`     | Sync       | `expression`                     | Inline expression with `fieldValue`/`formValue` (safe member access)  |
| `and`/`or`   | Sync       | `conditions`                     | Combine multiple conditions                                           |
| `http`       | Async      | `http`, `responseExpression`     | Server-driven condition via HTTP request                              |
| `async`      | Async      | `asyncFunctionName`              | Custom async function registered in config                            |

## Common Patterns

### Show/Hide Field Pattern

```typescript
logic: [
  {
    type: 'hidden',
    condition: {
      /* when to hide */
    },
  },
];
```

### Conditional Required Pattern

```typescript
logic: [
  {
    type: 'hidden',
    condition: {
      /* when to hide */
    },
  },
  {
    type: 'required',
    condition: {
      /* when to require */
    },
  },
];
```

### Multiple Conditions Pattern

```typescript
logic: [
  {
    type: 'hidden',
    condition: {
      type: 'and', // or 'or'
      conditions: [
        {
          /* condition 1 */
        },
        {
          /* condition 2 */
        },
      ],
    },
  },
];
```

## External Data in Conditions

Access external application state (user roles, permissions, feature flags) in conditions using `externalData`:

```typescript
const config = {
  externalData: {
    userRole: computed(() => authService.role()),
    featureFlags: computed(() => ({
      advancedMode: featureService.isAdvanced(),
    })),
  },
  fields: [
    {
      key: 'adminNotes',
      type: 'textarea',
      label: 'Admin Notes',
      logic: [
        {
          type: 'hidden',
          condition: {
            type: 'javascript',
            expression: "externalData.userRole !== 'admin'",
          },
        },
      ],
    },
    {
      key: 'advancedSettings',
      type: 'input',
      label: 'Advanced Settings',
      logic: [
        {
          type: 'hidden',
          condition: {
            type: 'javascript',
            expression: 'externalData.featureFlags.advancedMode !== true',
          },
        },
      ],
    },
  ],
} as const satisfies FormConfig;
```

**Key points:**

- Each property in `externalData` must be a Signal (`signal()` or `computed()`)
- Changes to external signals automatically re-evaluate conditions
- Access values via `externalData.propertyName` in JavaScript expressions

## Related

- **[Value Derivation](../value-derivation/basics/)** — Computed field values
- **[Async Derivation](../value-derivation/async/)** — HTTP and async function derivations, stopOnUserOverride
- **[Validation](../../validation/basics/)** — Conditional validation
- **[Custom Validators](../../validation/custom-validators/)** — Async and HTTP validators
- **[Type Safety](../../advanced/type-safety/basics/)** — TypeScript integration
- **[Examples](/examples)** — Real-world form patterns

--- dynamic-behavior/i18n ---

Dynamic Forms supports internationalization through Angular's reactive primitives: **Observables** and **Signals**. It's framework-agnostic - use any translation library that provides these types.

## How i18n Works

Dynamic Forms uses the `DynamicText` type for all text properties:

```typescript
type DynamicText = string | Observable<string> | Signal<string>;
```

Any property that accepts text (`label`, `placeholder`, `validationMessages`, and UI-integration specific props like `hint`) accepts:

- Static strings
- Observables (from translation libraries like Transloco, ngx-translate, etc.)
- Signals

## Basic Example

With any translation service that returns Observables:

```typescript
import { Component, inject } from '@angular/core';

@Component({...})
export class MyFormComponent {
  translationService = inject(YourTranslationService);

  config = {
    fields: [
      {
        key: 'firstName',
        type: 'input',
        label: this.translationService.translate('form.firstName'), // Observable<string>
        value: '',
      },
      {
        key: 'email',
        type: 'input',
        label: this.translationService.translate('form.email'),
        email: true,
        validationMessages: {
          required: this.translationService.translate('validation.required'),
          email: this.translationService.translate('validation.email'),
        },
        value: '',
      },
    ],
  };
}
```

The form automatically updates when translations change.

## Default Validation Messages

Define common validation messages once at the form level using `defaultValidationMessages`. These act as fallback messages when fields don't have their own custom `validationMessages`:

```typescript
import { Component, inject } from '@angular/core';

@Component({...})
export class MyFormComponent {
  translationService = inject(YourTranslationService);

  config = {
    // Define default messages for all fields
    defaultValidationMessages: {
      required: this.translationService.translate('validation.required'),
      email: this.translationService.translate('validation.email'),
      minLength: this.translationService.translate('validation.minLength'),
      maxLength: this.translationService.translate('validation.maxLength'),
    },
    fields: [
      {
        key: 'email',
        type: 'input',
        label: this.translationService.translate('form.email'),
        email: true,
        required: true,
        // Uses defaultValidationMessages for required and email errors
      },
      {
        key: 'password',
        type: 'input',
        label: this.translationService.translate('form.password'),
        required: true,
        minLength: 8,
        // Override default for this field only
        validationMessages: {
          required: this.translationService.translate('validation.password.required'),
          minLength: this.translationService.translate('validation.password.minLength'),
        },
      },
      {
        key: 'username',
        type: 'input',
        label: this.translationService.translate('form.username'),
        required: true,
        minLength: 3,
        // Uses default for both required and minLength
      },
    ],
  };
}
```

The message resolution priority is:

1. **Field-level** `validationMessages` (highest priority)
2. **Form-level** `defaultValidationMessages` (fallback)
3. **No message** - If neither is provided, the error is not displayed and a warning is logged to the console

This approach is especially useful when you have many fields with the same validation rules - define the translations once instead of repeating them for each field.

## Example with Transloco

Here's a complete example using [@jsverse/transloco](https://jsverse.github.io/transloco/):

```typescript name="app.config.ts"
import { ApplicationConfig } from '@angular/core';
import { provideHttpClient } from '@angular/common/http';
import { provideTransloco } from '@jsverse/transloco';
import { provideDynamicForm } from '@ng-forge/dynamic-forms';
import { withMaterialFields } from '@ng-forge/dynamic-forms-material';

export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(),
    provideTransloco({
      config: {
        availableLangs: ['en', 'es'],
        defaultLang: 'en',
        reRenderOnLangChange: true,
      },
      loader: TranslocoHttpLoader,
    }),
    provideDynamicForm(...withMaterialFields()),
  ],
};
```

```typescript name="my-form.component.ts"
import { Component, inject } from '@angular/core';
import { TranslocoService } from '@jsverse/transloco';
import { DynamicForm } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-my-form',
  imports: [DynamicForm],
  template: ` <form [dynamic-form]="formConfig"></form> `,
})
export class MyFormComponent {
  transloco = inject(TranslocoService);

  formConfig = {
    // Define default validation messages for all fields
    defaultValidationMessages: {
      required: this.transloco.selectTranslate('validation.required'),
      email: this.transloco.selectTranslate('validation.email'),
    },
    fields: [
      {
        key: 'username',
        type: 'input',
        label: this.transloco.selectTranslate('form.username'),
        value: '',
        required: true,
        // Uses defaultValidationMessages for required
      },
      {
        key: 'email',
        type: 'input',
        label: this.transloco.selectTranslate('form.email'),
        value: '',
        required: true,
        email: true,
        // Uses defaultValidationMessages for required and email
      },
    ],
  };

  // Optional: Switch languages
  changeLanguage(lang: string) {
    this.transloco.setActiveLang(lang);
    // Form automatically updates due to reRenderOnLangChange: true
  }
}
```

## Example with Signals

Use Angular signals for translations by wrapping the config in `computed()`:

```typescript
import { Component, signal, computed } from '@angular/core';

@Component({...})
export class MyFormComponent {
  currentLang = signal<'en' | 'es'>('en');

  translations = computed(() => ({
    en: {
      username: 'Username',
      email: 'Email',
      required: 'This field is required',
      email_format: 'Please enter a valid email address',
    },
    es: {
      username: 'Nombre de usuario',
      email: 'Correo electrónico',
      required: 'Este campo es obligatorio',
      email_format: 'Por favor ingrese una dirección de correo válida',
    },
  }[this.currentLang()]));

  // Wrap entire config in computed() - rebuilds when language changes
  formConfig = computed(() => ({
    defaultValidationMessages: {
      required: this.translations().required,
      email: this.translations().email_format,
    },
    fields: [
      {
        key: 'username',
        type: 'input',
        label: this.translations().username,
        value: '',
        required: true,
      },
      {
        key: 'email',
        type: 'input',
        label: this.translations().email,
        value: '',
        required: true,
        email: true,
      },
    ],
  }));

  switchLanguage(lang: 'en' | 'es') {
    this.currentLang.set(lang);
    // Config recomputes → form updates with new translations
  }
}
```

**How it works:** The `computed()` wrapper tracks the `currentLang` signal dependency. When `currentLang` changes, the entire config is recomputed with new translation values, and the form updates automatically.

## Translated Select Options

Options also support `DynamicText`:

```typescript
{
  key: 'country',
  type: 'select',
  label: translationService.translate('form.country'),
  value: '',
  options: translationService.translate('countries').pipe(
    map(countries => [
      { value: 'us', label: countries.us },
      { value: 'es', label: countries.es },
    ])
  ),
}
```

## Other Translation Libraries

Dynamic Forms works with any library that provides Observables or Signals:

**ngx-translate:**

```typescript
label: this.translate.get('form.username'); // Observable<string>
```

**Custom service:**

```typescript
label: this.myTranslationService.translate('key'); // Observable<string> or Signal<string>
```

The key is that your translation method returns `Observable<string>` or `Signal<string>`.

--- dynamic-behavior/submission ---

Form submission in dynamic forms integrates with Angular Signal Forms' native `submit()` function, providing automatic button disabling, loading states, and server error handling.

## Overview

The submission system provides:

- Async form submission with automatic loading state
- Server-side validation error handling
- Automatic submit button disabling during submission
- Configurable button disabled behavior
- Custom disabled logic via `FormStateCondition`

**Note**: The submission mechanism is **optional** - you can still handle submission manually via the `(submitted)` output if you prefer.

## Basic Usage

Configure form submission with the `submission` property:

```typescript
import { Component, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { FormConfig, InferFormValue } from '@ng-forge/dynamic-forms';

const formFields = {
  fields: [
    { type: 'input', key: 'email', label: 'Email', value: '', required: true, email: true },
    { type: 'input', key: 'password', label: 'Password', value: '', required: true, props: { type: 'password' } },
    { type: 'submit', key: 'submit', label: 'Sign In' },
  ],
} as const satisfies FormConfig;

type LoginForm = InferFormValue<typeof formFields.fields>;

@Component({...})
export class LoginFormComponent {
  private http = inject(HttpClient);

  config = {
    ...formFields,
    submission: {
      action: (form: LoginForm) => this.http.post('/api/login', form),
    },
  };
}
```

## SubmissionConfig

The `submission.action` function receives the typed form value and can return an Observable or Promise:

| Return Value           | Meaning                                    |
| ---------------------- | ------------------------------------------ |
| Completes successfully | Successful submission                      |
| `TreeValidationResult` | Server validation errors (single or array) |

**Note:** `TreeValidationResult` from Angular Signal Forms supports both single errors and arrays. You can return a single error object or an array of errors.

While the action is executing, the form is in a submitting state, enabling automatic button disabling and loading states.

### Server Error Handling

Return validation errors to apply them to specific fields using `catchError`:

```typescript
import { catchError, of } from 'rxjs';

submission: {
  action: (form: FormValue) => this.http.post('/api/register', form).pipe(
    catchError((error) => {
      if (error.error?.code === 'EMAIL_EXISTS') {
        return of([{
          field: 'email',
          error: { kind: 'server', message: 'Email already exists' },
        }]);
      }
      throw error; // Re-throw unexpected errors
    }),
  ),
}
```

## Button Disabled Behavior

Submit and next page buttons are automatically disabled based on form state. Configure defaults via `options`:

```typescript
const config: FormConfig = {
  fields: [...],
  options: {
    submitButton: {
      disableWhenInvalid: true,      // Disable when form is invalid (default: true)
      disableWhileSubmitting: true,  // Disable during submission (default: true)
    },
    nextButton: {
      disableWhenPageInvalid: true,  // Disable when current page is invalid (default: true)
      disableWhileSubmitting: true,  // Disable during submission (default: true)
    }
  }
};
```

### SubmitButtonOptions

| Option                   | Type      | Default | Description                    |
| ------------------------ | --------- | ------- | ------------------------------ |
| `disableWhenInvalid`     | `boolean` | `true`  | Disable when form is invalid   |
| `disableWhileSubmitting` | `boolean` | `true`  | Disable during form submission |

### NextButtonOptions

| Option                   | Type      | Default | Description                                  |
| ------------------------ | --------- | ------- | -------------------------------------------- |
| `disableWhenPageInvalid` | `boolean` | `true`  | Disable when current page has invalid fields |
| `disableWhileSubmitting` | `boolean` | `true`  | Disable during form submission               |

## Custom Button Logic

Override form-level defaults on individual buttons using the `logic` array:

```typescript
{
  type: 'submit',
  key: 'submit',
  label: 'Submit',
  logic: [
    { type: 'disabled', condition: 'formInvalid' },
    { type: 'disabled', condition: 'formSubmitting' }
  ]
}
```

**Note:** `type: 'submit'` is a UI-integration convenience type that pre-configures the button with `SubmitEvent`. Use `type: 'button'` with `event: SubmitEvent` for the core API.

### FormStateCondition

Special condition strings for button logic:

| Condition          | Description                                                  |
| ------------------ | ------------------------------------------------------------ |
| `'formInvalid'`    | Evaluates to `true` when the form is invalid                 |
| `'formSubmitting'` | Evaluates to `true` when form submission is in progress      |
| `'pageInvalid'`    | Evaluates to `true` when the current page has invalid fields |

### Logic Precedence

Button disabled state is determined in this order:

1. **Explicit `disabled: true`** - Always wins
2. **Field-level `logic` array** - If present, overrides form-level defaults
3. **Form-level options** - Default behavior from `options.submitButton` or `options.nextButton`

### Advanced Logic Example

Combine form state conditions with custom expressions:

```typescript
{
  type: 'submit',
  key: 'submit',
  label: 'Submit',
  logic: [
    // Disable when form is invalid
    { type: 'disabled', condition: 'formInvalid' },
    // Disable when submitting
    { type: 'disabled', condition: 'formSubmitting' },
    // Also disable if terms not accepted
    {
      type: 'disabled',
      condition: {
        type: 'fieldValue',
        fieldPath: 'acceptTerms',
        operator: 'equals',
        value: false,
      }
    }
  ]
}
```

## Value Exclusion

By default, field values are excluded from the `(submitted)` output when the field is hidden, disabled, or readonly. This prevents stale or irrelevant data from being submitted.

Value exclusion supports a 3-tier configuration hierarchy: **Global > Form > Field**, where the most specific level wins. Internal form state and two-way binding are unaffected.

```typescript
// Disable hidden value exclusion for this form
const config: FormConfig = {
  fields: [...],
  options: {
    excludeValueIfHidden: false,
  }
};
```

See the **Value Exclusion** page under Recipes for full documentation on configuration tiers, per-field overrides, and migration instructions.

## Manual Submission

If you prefer manual control, use the `(submitted)` output instead:

```typescript
@Component({
  template: `<form [dynamic-form]="config" (submitted)="onSubmit($event)"></form>`,
})
export class MyFormComponent {
  onSubmit(value: FormValue) {
    this.http.post('/api/submit', value).subscribe();
  }
}
```

--- dynamic-behavior/value-derivation/basics/async-derivation ---

---
title: Async
route: async
---

Derive field values from HTTP responses or custom async functions. Async derivations are ideal for server-driven computed values, address/zip lookups, exchange rates, and any value that requires a network call.

## HTTP Derivations

Use `source: 'http'` to derive a field value from an HTTP response. The request fires when declared dependencies change, with automatic debouncing and in-flight request cancellation.

### Basic Example

```typescript
{
  key: 'exchangeRate',
  type: 'input',
  label: 'Exchange Rate',
  readonly: true,
  logic: [{
    type: 'derivation',
    source: 'http',
    http: {
      url: '/api/exchange-rate',
      method: 'GET',
      queryParams: {
        currency: 'formValue.currency',
      },
    },
    responseExpression: 'response.rate',
    dependsOn: ['currency'],
  }],
}
```

When `currency` changes, a GET request is sent and `response.rate` becomes the new field value.

### HttpRequestConfig

| Property                  | Type                      | Required | Description                                                                 |
| ------------------------- | ------------------------- | -------- | --------------------------------------------------------------------------- |
| `url`                     | `string`                  | Yes      | Request URL. Use `:key` placeholders for path parameters                    |
| `method`                  | `string`                  | No       | HTTP method. Defaults to `'GET'`                                            |
| `params`                  | `Record<string, string>`  | No       | Path parameters. Values are expressions evaluated against the form context  |
| `queryParams`             | `Record<string, string>`  | No       | Query parameters. Values are expressions evaluated against the form context |
| `body`                    | `Record<string, unknown>` | No       | Request body (for POST/PUT/PATCH)                                           |
| `evaluateBodyExpressions` | `boolean`                 | No       | When `true`, top-level string values in `body` are treated as expressions   |
| `headers`                 | `Record<string, string>`  | No       | Request headers                                                             |

### Path Parameters

Use `:key` placeholders in the URL and provide values via `params`. Values are expressions evaluated against the form context, then `encodeURIComponent`-encoded:

```typescript
http: {
  url: '/api/users/:userId/orders/:orderId',
  params: {
    userId: 'formValue.userId',
    orderId: 'formValue.orderId',
  },
}
```

### Query Params as Expressions

Values in `queryParams` are evaluated as expressions, giving you dynamic request parameters built from form values:

```typescript
http: {
  url: '/api/shipping-estimate',
  queryParams: {
    fromZip: 'formValue.originZip',
    toZip: 'formValue.destinationZip',
    weight: 'formValue.packageWeight',
  },
}
```

### POST with Dynamic Body

For `POST` requests, use `evaluateBodyExpressions: true` to build the body from form values:

```typescript
http: {
  url: '/api/calculate-tax',
  method: 'POST',
  body: {
    subtotal: 'formValue.subtotal',
    state: 'formValue.state',
    items: 'formValue.lineItems',
  },
  evaluateBodyExpressions: true,
},
```

Top-level string values in `body` are evaluated as expressions. Nested objects are passed through as-is.

### Extracting the Response Value

`responseExpression` is evaluated with `{ response }` in scope and extracts the derived value:

```typescript
responseExpression: 'response.rate'; // Simple property
responseExpression: 'response.data.price'; // Nested property
responseExpression: 'response.items[0].value'; // Array access
```

### Required Fields

`source: 'http'` enforces two fields at the TypeScript level:

- **`dependsOn: string[]`** — Explicit field dependencies. The request only re-fires when these fields change.
- **`responseExpression: string`** — Expression to extract the derived value from the response body.

### Controlling Request Timing

Use `trigger` and `debounceMs` to control when requests fire:

```typescript
{
  type: 'derivation',
  source: 'http',
  http: {
    url: '/api/username-suggest',
    queryParams: { q: 'formValue.companyName' },
  },
  responseExpression: 'response.suggestion',
  dependsOn: ['companyName'],
  trigger: 'debounced',
  debounceMs: 400,
}
```

The request waits 400ms after the user stops typing before firing.

### Conditional HTTP Derivation

Add a `condition` to only send the request when certain criteria are met:

```typescript
{
  key: 'suggestedPrice',
  type: 'input',
  readonly: true,
  logic: [{
    type: 'derivation',
    source: 'http',
    http: {
      url: '/api/price-suggest',
      queryParams: { productId: 'formValue.productId' },
    },
    responseExpression: 'response.suggestedPrice',
    dependsOn: ['productId'],
    condition: {
      type: 'fieldValue',
      fieldPath: 'productId',
      operator: 'notEquals',
      value: '',
    },
  }],
}
```

## Async Function Derivations

Use `source: 'asyncFunction'` when you need custom logic — Angular service injection, complex transformations, or any async computation not expressible as a plain HTTP config. Functions receive the full evaluation context and can return a `Promise` or `Observable`.

### Basic Example

```typescript
// 1. Define and register the function in customFnConfig
const formConfig = {
  customFnConfig: {
    asyncDerivations: {
      lookupCity: async (context) => {
        const response = await fetch(`/api/geocode?zip=${context.formValue.zipCode}`);
        const data = await response.json();
        return data.city;
      },
    },
  },

  // 2. Reference it on the target field
  fields: [
    {
      key: 'city',
      type: 'input',
      label: 'City',
      readonly: true,
      logic: [
        {
          type: 'derivation',
          source: 'asyncFunction',
          asyncFunctionName: 'lookupCity',
          dependsOn: ['zipCode'],
        },
      ],
    },
  ],
} as const satisfies FormConfig;
```

### Using RxJS Observables

Functions can return an `Observable` instead of a `Promise`, which is useful when using Angular services:

```typescript
customFnConfig: {
  asyncDerivations: {
    fetchAddress: (context) => {
      return inject(AddressService)
        .lookup(context.formValue.zipCode as string)
        .pipe(map(result => result.formattedAddress));
    },
  },
},
```

### Available Context

Async derivation functions receive the full `EvaluationContext`:

| Variable                | Description                                      |
| ----------------------- | ------------------------------------------------ |
| `context.formValue`     | All current form field values                    |
| `context.fieldValue`    | The current value of the target field            |
| `context.externalData`  | External data passed to the form (if configured) |
| `context.rootFormValue` | Entire form value when inside array fields       |

### Conditional Async Derivation

Combine with `condition` to only run the function when needed:

```typescript
{
  key: 'city',
  type: 'input',
  label: 'City',
  readonly: true,
  logic: [{
    type: 'derivation',
    source: 'asyncFunction',
    asyncFunctionName: 'lookupCity',
    dependsOn: ['zipCode'],
    condition: {
      type: 'fieldValue',
      fieldPath: 'enableLookup',
      operator: 'equals',
      value: true,
    },
  }],
}
```

The async function is only called when `enableLookup === true`.

### Required Fields

`source: 'asyncFunction'` requires:

- **`asyncFunctionName: string`** — Name of the function registered in `customFnConfig.asyncDerivations`.
- **`dependsOn: string[]`** — Explicit field dependencies. Without this, the function would re-run on every form change.

## Stop On User Override

`stopOnUserOverride` turns a derivation into a "smart default" — the field is auto-filled initially, but derivation stops once the user manually edits it.

### Basic Example

```typescript
{
  key: 'displayName',
  type: 'input',
  label: 'Display Name',
  logic: [{
    type: 'derivation',
    expression: 'formValue.firstName + " " + formValue.lastName',
    stopOnUserOverride: true,
  }],
}
```

The display name is auto-filled from first and last name. Once the user changes it directly, auto-fill stops.

### Re-Engaging on Dependency Change

Use `reEngageOnDependencyChange: true` to clear the user override when a dependency changes. The derivation respects user edits, but re-engages if the underlying data changes:

```typescript
{
  key: 'phonePrefix',
  type: 'input',
  label: 'Phone Prefix',
  logic: [
    {
      type: 'derivation',
      value: '+1',
      condition: { type: 'fieldValue', fieldPath: 'country', operator: 'equals', value: 'US' },
      stopOnUserOverride: true,
      reEngageOnDependencyChange: true,
      dependsOn: ['country'],
    },
    {
      type: 'derivation',
      value: '+44',
      condition: { type: 'fieldValue', fieldPath: 'country', operator: 'equals', value: 'UK' },
      stopOnUserOverride: true,
      reEngageOnDependencyChange: true,
      dependsOn: ['country'],
    },
  ],
}
```

When the user changes the country, the phone prefix is auto-filled again — overriding any previous manual edit.

**Without** `reEngageOnDependencyChange`: once the user edits the field, the derivation never runs again for that field instance.

**With** `reEngageOnDependencyChange`: the user override is cleared when a declared dependency changes, and the derivation re-fires.

### Works with All Sources

`stopOnUserOverride` and `reEngageOnDependencyChange` work across all derivation sources:

```typescript
// HTTP derivation with user override
{
  type: 'derivation',
  source: 'http',
  http: {
    url: '/api/suggest-price',
    queryParams: { category: 'formValue.category' },
  },
  responseExpression: 'response.suggestedPrice',
  dependsOn: ['category'],
  stopOnUserOverride: true,
  reEngageOnDependencyChange: true,
}

// Async function derivation with user override
{
  type: 'derivation',
  source: 'asyncFunction',
  asyncFunctionName: 'fetchDefaultTitle',
  dependsOn: ['template'],
  stopOnUserOverride: true,
}
```

## DerivationLogicConfig Reference (Async)

### HTTP Derivation Fields

```typescript
{
  type: 'derivation';
  source: 'http';         // Required — identifies HTTP mode

  http: HttpRequestConfig; // Required — request configuration
  dependsOn: string[];     // Required — explicit field dependencies
  responseExpression: string; // Required — expression to extract value from response

  // Shared optional fields
  trigger?: 'onChange' | 'debounced'; // Default: 'onChange'
  debounceMs?: number;                // Default: 500 (when trigger: 'debounced')
  condition?: ConditionalExpression | boolean;
  stopOnUserOverride?: boolean;
  reEngageOnDependencyChange?: boolean;
  debugName?: string;
}
```

### Async Function Derivation Fields

```typescript
{
  type: 'derivation';
  source: 'asyncFunction'; // Required — identifies async function mode

  asyncFunctionName: string; // Required — name in customFnConfig.asyncDerivations
  dependsOn: string[];       // Required — explicit field dependencies

  // Shared optional fields
  trigger?: 'onChange' | 'debounced';
  debounceMs?: number;
  condition?: ConditionalExpression | boolean;
  stopOnUserOverride?: boolean;
  reEngageOnDependencyChange?: boolean;
  debugName?: string;
}
```

## Related

- **[Values](./)** — Expression, static value, and function-based derivations
- **[Properties](./property-derivation)** — Derive component properties from form values
- **[HTTP Conditions](../../conditional-logic/overview/)** — HTTP-driven field visibility and state
- **[Custom Validators](../../../validation/custom-validators/)** — Async and HTTP validation

--- dynamic-behavior/value-derivation/basics ---

---
title: Values
---

Automatically compute and set field values based on other form values. Derivations enable calculated fields, auto-fill patterns, and value transformations.

## Quick Start

Derivations are defined ON the field that receives the computed value (self-targeting).

### Shorthand Syntax (Preferred)

```typescript
{
  key: 'total',
  type: 'input',
  label: 'Total',
  readonly: true,
  derivation: 'formValue.quantity * formValue.unitPrice',
}
```

### Logic Block Syntax

```typescript
{
  key: 'total',
  type: 'input',
  label: 'Total',
  readonly: true,
  logic: [{
    type: 'derivation',
    expression: 'formValue.quantity * formValue.unitPrice',
  }],
}
```

When `quantity` or `unitPrice` changes, `total` is automatically recalculated.

## Derivation Types

### Expression-Based

Use JavaScript expressions with access to `formValue`:

```typescript
{
  key: 'fullName',
  type: 'input',
  label: 'Full Name',
  readonly: true,
  derivation: '(formValue.firstName || "") + " " + (formValue.lastName || "")',
}
```

**Available variables:**

- `formValue` - Object containing all form field values
- `externalData` - External application state (when configured in FormConfig)

### Static Value

Set a constant value when a condition is met:

```typescript
{
  key: 'phonePrefix',
  type: 'input',
  label: 'Phone Prefix',
  readonly: true,
  logic: [{
    type: 'derivation',
    value: '+1',
    condition: {
      type: 'fieldValue',
      fieldPath: 'country',
      operator: 'equals',
      value: 'USA',
    },
  }],
}
```

### Custom Function

Use a registered function for complex logic:

```typescript
// In form config
customFnConfig: {
  derivations: {
    calculateTax: (ctx) => ctx.formValue.subtotal * getTaxRate(ctx.formValue.state),
  },
},
fields: [
  {
    key: 'tax',
    type: 'input',
    readonly: true,
    logic: [{
      type: 'derivation',
      functionName: 'calculateTax',
      dependsOn: ['subtotal', 'state'],
    }],
  },
],
```

## Trigger Timing

Control when derivations evaluate:

| Trigger     | Description                           | Use Case                              |
| ----------- | ------------------------------------- | ------------------------------------- |
| `onChange`  | Immediately on value change (default) | Computed totals, conditional prefixes |
| `debounced` | After value stabilizes                | Self-transforms, format masking       |

### Debounced Derivations

Use `trigger: 'debounced'` for self-transforming fields to avoid interrupting the user while typing:

```typescript
{
  key: 'email',
  type: 'input',
  label: 'Email',
  logic: [{
    type: 'derivation',
    expression: 'formValue.email.toLowerCase()',
    trigger: 'debounced',
    debounceMs: 500, // optional, defaults to 500
  }],
}
```

The transformation applies after the user stops typing for 500ms.

## Conditional Derivations

Only apply derivations when conditions are met:

```typescript
{
  key: 'currency',
  type: 'input',
  label: 'Currency',
  readonly: true,
  logic: [
    {
      type: 'derivation',
      value: 'USD',
      condition: {
        type: 'fieldValue',
        fieldPath: 'country',
        operator: 'equals',
        value: 'USA',
      },
    },
    {
      type: 'derivation',
      value: 'EUR',
      condition: {
        type: 'fieldValue',
        fieldPath: 'country',
        operator: 'equals',
        value: 'Germany',
      },
    },
  ],
}
```

Multiple derivations on the same field are evaluated in order.

## Dependencies

### Automatic Detection

For expressions, dependencies are automatically extracted:

```typescript
{
  key: 'total',
  type: 'input',
  label: 'Total',
  readonly: true,
  derivation: 'formValue.quantity * formValue.unitPrice',
  // Automatically depends on: quantity, unitPrice
}
```

### Explicit Dependencies

For custom functions, specify dependencies explicitly:

```typescript
{
  key: 'discount',
  type: 'input',
  label: 'Discount',
  readonly: true,
  logic: [{
    type: 'derivation',
    functionName: 'calculateDiscount',
    dependsOn: ['total', 'memberLevel'],
  }],
}
```

Without `dependsOn`, custom functions re-evaluate on any form change.

## Complete Example

```typescript
const orderForm = {
  fields: [
    {
      key: 'quantity',
      type: 'input',
      value: 1,
      label: 'Quantity',
      props: { type: 'number' },
    },
    {
      key: 'unitPrice',
      type: 'input',
      value: 10,
      label: 'Unit Price',
      props: { type: 'number' },
    },
    {
      key: 'subtotal',
      type: 'input',
      value: 0,
      label: 'Subtotal',
      readonly: true,
      derivation: 'formValue.quantity * formValue.unitPrice',
    },
    {
      key: 'tax',
      type: 'input',
      value: 0,
      label: 'Tax (10%)',
      readonly: true,
      derivation: 'formValue.subtotal * 0.1',
    },
    {
      key: 'total',
      type: 'input',
      value: 0,
      label: 'Total',
      readonly: true,
      derivation: 'formValue.subtotal + formValue.tax',
    },
  ],
} as const satisfies FormConfig;
```

## Array Field Derivations

Inside arrays, `formValue` is scoped to the current array item:

```typescript
{
  key: 'lineItems',
  type: 'array',
  fields: [
    {
      key: 'itemRow',
      type: 'row',
      fields: [
        { key: 'quantity', type: 'input', label: 'Qty', value: 1 },
        { key: 'unitPrice', type: 'input', label: 'Price', value: 0 },
        {
          key: 'lineTotal',
          type: 'input',
          label: 'Total',
          value: 0,
          readonly: true,
          // formValue is scoped to the current array item
          derivation: 'formValue.quantity * formValue.unitPrice',
        },
      ],
    },
  ],
}
```

### Accessing Root Form Value

Inside array items, `formValue` refers to the current array item. Use `rootFormValue` to access the entire form:

```typescript
{
  key: 'lineTotal',
  type: 'input',
  label: 'Total',
  readonly: true,
  // formValue = current array item { quantity, unitPrice }
  // rootFormValue = entire form { lineItems, discount, ... }
  derivation: 'formValue.quantity * formValue.unitPrice * (1 - rootFormValue.discount / 100)',
}
```

## Debugging Derivations

Enable derivation logging to troubleshoot issues:

### Configuration

Configure derivation logging via `withLoggerConfig`:

```typescript
// In your providers
provideDynamicForm(...withMaterialFields(), withLoggerConfig({ derivations: 'verbose' }));

// Or just summary level
provideDynamicForm(...withMaterialFields(), withLoggerConfig({ derivations: 'summary' }));
```

### Log Levels

| Level     | Output                            |
| --------- | --------------------------------- |
| `none`    | No logging (default)              |
| `summary` | Cycle completion with counts      |
| `verbose` | Individual derivation evaluations |

### Using debugName

Add names to derivations for easier identification in logs:

```typescript
{
  key: 'lineTotal',
  type: 'input',
  label: 'Total',
  readonly: true,
  logic: [{
    type: 'derivation',
    debugName: 'Calculate line total',
    expression: 'formValue.quantity * formValue.unitPrice',
  }],
}
```

**Console output (verbose mode):**

```
Derivation - Starting cycle (onChange) with 5 derivation(s)
Derivation - Iteration 1
Derivation - Applied "Calculate line total" { field: 'lineTotal', newValue: 150 }
Derivation - Skipped: phonePrefix (condition not met)
Derivation - Cycle complete (onChange) { applied: 1, skipped: 4, errors: 0, iterations: 1 }
```

## Bidirectional Derivations

Create two-way bindings between fields:

```typescript
// Celsius to Fahrenheit
{
  key: 'fahrenheit',
  type: 'input',
  value: 32,
  derivation: 'formValue.celsius * 9 / 5 + 32',
}

// Fahrenheit to Celsius
{
  key: 'celsius',
  type: 'input',
  value: 0,
  derivation: '(formValue.fahrenheit - 32) * 5 / 9',
}
```

### Cycle Detection

The system automatically detects derivation cycles and warns during development:

```
Bidirectional derivation detected: celsius <-> fahrenheit
Bidirectional derivations stabilize via equality check.
```

### Floating-Point Precision

Bidirectional derivations stabilize when the computed value equals the current value. For floating-point operations, consider:

1. **Rounding in expressions:**

   ```typescript
   derivation: 'Math.round(formValue.usd * exchangeRate * 100) / 100';
   ```

2. **Using integers:** Store cents instead of dollars
3. **One-way derivation:** If bidirectional isn't required

## Derivation Processing

### Evaluation Order

Derivations are topologically sorted based on dependencies:

```
quantity  ─┐
            ├── subtotal ─┐
unitPrice ─┘              ├── total
                          │
             tax ─────────┘
```

This ensures `subtotal` is computed before `total`.

### Iteration Limits

To prevent infinite loops, derivations are limited to 10 iterations per cycle. If exceeded:

```
Derivation - Max iterations reached (onChange).
This may indicate a loop in derivation logic.
```

## DerivationLogicConfig Interface

```typescript
interface DerivationLogicConfig {
  /** Logic type identifier */
  type: 'derivation';

  /** Optional name for debugging */
  debugName?: string;

  /** When to evaluate: 'onChange' (default) or 'debounced' */
  trigger?: 'onChange' | 'debounced';

  /** Debounce duration in ms (default: 500) */
  debounceMs?: number;

  /** Static value to set */
  value?: unknown;

  /** JavaScript expression (has access to formValue) */
  expression?: string;

  /** Name of registered custom function */
  functionName?: string;

  /** Explicit field dependencies */
  dependsOn?: string[];

  /** Condition for when derivation applies */
  condition?: ConditionalExpression | boolean;
}
```

## External Data in Derivations

Use external application state in derivation expressions:

```typescript
const config = {
  externalData: {
    discountRate: computed(() => pricingService.currentDiscount()),
  },
  fields: [
    {
      key: 'discountedPrice',
      type: 'input',
      label: 'Discounted Price',
      readonly: true,
      derivation: 'formValue.price * (1 - externalData.discountRate)',
    },
  ],
} as const satisfies FormConfig;
```

External data values are reactively tracked - when signals change, derivations are re-evaluated.

## Related

- **Property Derivation** (see tab above) — Derive component properties (minDate, options, label) from form values
- **Async Derivation** (see tab above) — HTTP and async function derivations, stopOnUserOverride
- **[Conditional Logic](../conditional-logic/overview/)** — Control field visibility and state
- **[Array Fields](../../prebuilt/form-arrays/simplified/)** — Working with array fields
- **[Examples](/examples)** — Real-world form patterns

--- dynamic-behavior/value-derivation/basics/property-derivation ---

---
title: Properties
route: property
---

Reactively derive field component properties (like `minDate`, `options`, `label`, `placeholder`) based on form values. While value derivations set a field's form value, property derivations set **component input properties**.

## Quick Start

Property derivations use `type: 'derivation'` with `targetProperty` in the `logic` array and are self-targeting: the logic is placed on the field whose property should be derived.

```typescript
{
  key: 'endDate',
  type: 'datepicker',
  label: 'End Date',
  logic: [{
    type: 'derivation',
    targetProperty: 'minDate',
    expression: 'formValue.startDate',
  }]
}
```

When `startDate` changes, the `minDate` property on `endDate`'s datepicker component is automatically updated.

> **Migration note:** The previous `type: 'propertyDerivation'` syntax is deprecated but still works.
> Use `type: 'derivation'` with `targetProperty` instead. Similarly, register functions via
> `customFnConfig.derivations` instead of `customFnConfig.propertyDerivations`.

## Derivation Sources

Property derivations support three mutually exclusive ways to compute a value.

### Expression-Based

Use JavaScript expressions with access to `formValue`:

```typescript
{
  key: 'endDate',
  type: 'datepicker',
  label: 'End Date',
  logic: [{
    type: 'derivation',
    targetProperty: 'minDate',
    expression: 'formValue.startDate',
  }]
}
```

**Available variables:**

- `formValue` - Object containing all form field values
- `externalData` - External application state (when configured in FormConfig)

### Static Value

Set a constant property value when a condition is met:

```typescript
{
  key: 'phone',
  type: 'input',
  label: 'Phone',
  logic: [{
    type: 'derivation',
    targetProperty: 'label',
    value: 'Mobile Phone',
    condition: {
      type: 'fieldValue',
      fieldPath: 'contactType',
      operator: 'equals',
      value: 'mobile',
    },
  }]
}
```

### Custom Function

Use a registered function for complex logic:

```typescript
// In form config
customFnConfig: {
  derivations: {
    getCitiesForCountry: (ctx) => {
      const cities: Record<string, { label: string; value: string }[]> = {
        'US': [{ label: 'New York', value: 'nyc' }, { label: 'LA', value: 'la' }],
        'DE': [{ label: 'Berlin', value: 'berlin' }],
      };
      return cities[ctx.formValue.country as string] ?? [];
    },
  },
},
fields: [
  {
    key: 'city',
    type: 'select',
    label: 'City',
    options: [],
    logic: [{
      type: 'derivation',
      targetProperty: 'options',
      functionName: 'getCitiesForCountry',
      dependsOn: ['country'],
    }],
  },
],
```

## Target Properties

### Simple Properties

Set any direct component input property:

```typescript
targetProperty: 'minDate'; // Date constraint
targetProperty: 'maxDate'; // Date constraint
targetProperty: 'options'; // Select/radio options
targetProperty: 'label'; // Field label
targetProperty: 'placeholder'; // Input placeholder
targetProperty: 'hint'; // Hint text
targetProperty: 'rows'; // Textarea rows
```

### Nested Properties (Dot Notation)

Set properties nested one level deep using dot notation:

```typescript
targetProperty: 'props.appearance'; // Material appearance
targetProperty: 'props.color'; // Material color
targetProperty: 'meta.autocomplete'; // Custom metadata
```

> **Note:** Maximum nesting depth is 2 levels (one dot). Deeper paths like `props.nested.deep` are not supported.

## Trigger Timing

Control when property derivations evaluate:

| Trigger     | Description                           | Use Case                          |
| ----------- | ------------------------------------- | --------------------------------- |
| `onChange`  | Immediately on value change (default) | Date constraints, dynamic options |
| `debounced` | After value stabilizes                | Expensive lookups, search queries |

### Debounced Property Derivations

Use `trigger: 'debounced'` for expensive operations:

```typescript
{
  key: 'productSearch',
  type: 'select',
  label: 'Product',
  options: [],
  logic: [{
    type: 'derivation',
    targetProperty: 'options',
    functionName: 'searchProducts',
    trigger: 'debounced',
    debounceMs: 300,
    dependsOn: ['searchQuery'],
  }]
}
```

## Conditional Property Derivations

Only apply property derivations when conditions are met:

```typescript
{
  key: 'email',
  type: 'input',
  label: 'Email',
  logic: [
    {
      type: 'derivation',
      targetProperty: 'label',
      value: 'Work Email',
      condition: {
        type: 'fieldValue',
        fieldPath: 'accountType',
        operator: 'equals',
        value: 'business',
      },
    },
    {
      type: 'derivation',
      targetProperty: 'label',
      value: 'Personal Email',
      condition: {
        type: 'fieldValue',
        fieldPath: 'accountType',
        operator: 'equals',
        value: 'personal',
      },
    },
  ],
}
```

## Dependencies

### Automatic Detection

For expressions, dependencies are automatically extracted:

```typescript
{
  key: 'endDate',
  type: 'datepicker',
  label: 'End Date',
  logic: [{
    type: 'derivation',
    targetProperty: 'minDate',
    expression: 'formValue.startDate',
    // Automatically depends on: startDate
  }]
}
```

### Explicit Dependencies

For custom functions, specify dependencies explicitly:

```typescript
{
  key: 'city',
  type: 'select',
  label: 'City',
  options: [],
  logic: [{
    type: 'derivation',
    targetProperty: 'options',
    functionName: 'getCitiesForCountry',
    dependsOn: ['country'],
  }]
}
```

Without `dependsOn`, custom functions re-evaluate on **any** form value change.

## Array Field Property Derivations

Inside arrays, `formValue` is scoped to the current array item:

```typescript
{
  key: 'lineItems',
  type: 'array',
  fields: [
    {
      key: 'item',
      type: 'group',
      fields: [
        { key: 'startDate', type: 'datepicker', label: 'Start' },
        {
          key: 'endDate',
          type: 'datepicker',
          label: 'End',
          logic: [{
            type: 'derivation',
            targetProperty: 'minDate',
            // formValue is scoped to the current array item
            expression: 'formValue.startDate',
          }]
        },
      ],
    },
  ],
}
```

Each array item independently derives its own `endDate.minDate` from its own `startDate`.

## Complete Example

```typescript
const travelForm = {
  customFnConfig: {
    derivations: {
      getCitiesForCountry: (ctx) => {
        const cities: Record<string, { label: string; value: string }[]> = {
          US: [
            { label: 'New York', value: 'nyc' },
            { label: 'Los Angeles', value: 'la' },
            { label: 'Chicago', value: 'chi' },
          ],
          DE: [
            { label: 'Berlin', value: 'berlin' },
            { label: 'Munich', value: 'munich' },
          ],
        };
        return cities[ctx.formValue.country as string] ?? [];
      },
    },
  },
  fields: [
    {
      key: 'country',
      type: 'select',
      label: 'Country',
      required: true,
      options: [
        { label: 'USA', value: 'US' },
        { label: 'Germany', value: 'DE' },
      ],
    },
    {
      key: 'city',
      type: 'select',
      label: 'City',
      required: true,
      options: [],
      logic: [
        {
          type: 'derivation',
          targetProperty: 'options',
          functionName: 'getCitiesForCountry',
          dependsOn: ['country'],
        },
      ],
    },
    { key: 'startDate', type: 'datepicker', label: 'Travel Start', required: true },
    {
      key: 'endDate',
      type: 'datepicker',
      label: 'Travel End',
      required: true,
      logic: [
        {
          type: 'derivation',
          targetProperty: 'minDate',
          expression: 'formValue.startDate',
        },
      ],
    },
    {
      key: 'notes',
      type: 'textarea',
      label: 'Notes',
      logic: [
        {
          type: 'derivation',
          targetProperty: 'props.appearance',
          value: 'fill',
          condition: {
            type: 'fieldValue',
            fieldPath: 'country',
            operator: 'equals',
            value: 'DE',
          },
        },
        {
          type: 'derivation',
          targetProperty: 'props.appearance',
          value: 'outline',
          condition: {
            type: 'fieldValue',
            fieldPath: 'country',
            operator: 'notEquals',
            value: 'DE',
          },
        },
      ],
    },
    { key: 'submit', type: 'submit', label: 'Book Trip' },
  ],
} as const satisfies FormConfig;
```

## Comparison with Value Derivation

| Aspect           | Value Derivation             | Property Derivation                     |
| ---------------- | ---------------------------- | --------------------------------------- |
| Logic type       | `type: 'derivation'`         | `type: 'derivation'` + `targetProperty` |
| Sets             | Field's form value           | Component input property                |
| Target           | Implicit (self)              | `targetProperty: 'minDate'`             |
| Shorthand        | `derivation: 'expr'`         | None (must use logic block)             |
| Chaining         | Topologically sorted         | No chaining (single pass)               |
| Custom functions | `customFnConfig.derivations` | `customFnConfig.derivations`            |
| Max iterations   | Configurable (default 10)    | Single pass                             |

## Debugging

Add `debugName` to property derivations for easier identification in logs:

```typescript
logic: [
  {
    type: 'derivation',
    debugName: 'endDate minDate constraint',
    targetProperty: 'minDate',
    expression: 'formValue.startDate',
  },
];
```

## DerivationLogicConfig Interface

Both value derivations and property derivations use the unified `DerivationLogicConfig`. The presence of `targetProperty` is what distinguishes a property derivation from a value derivation.

```typescript
interface DerivationLogicConfig {
  /** Logic type identifier (unified for both value and property derivations) */
  type: 'derivation';

  /** Property to set on the field component. When present, this is a property derivation. When absent, this is a value derivation. */
  targetProperty?: string;

  /** Optional name for debugging */
  debugName?: string;

  /** When to evaluate: 'onChange' (default) or 'debounced' */
  trigger?: 'onChange' | 'debounced';

  /** Debounce duration in ms (default: 500) */
  debounceMs?: number;

  /** Static value to set (mutually exclusive) */
  value?: unknown;

  /** JavaScript expression (mutually exclusive) */
  expression?: string;

  /** Name of registered custom function (mutually exclusive) */
  functionName?: string;

  /** Explicit field dependencies */
  dependsOn?: string[];

  /** Condition for when derivation applies (default: true) */
  condition?: ConditionalExpression | boolean;
}
```

## External Data in Property Derivations

Use external application state in property derivation custom functions:

```typescript
const config = {
  externalData: {
    userRegion: computed(() => this.regionService.current()),
  },
  customFnConfig: {
    derivations: {
      getCurrencyOptions: (ctx) => {
        const optionsByRegion: Record<string, { label: string; value: string }[]> = {
          EU: [
            { label: 'EUR', value: 'eur' },
            { label: 'GBP', value: 'gbp' },
          ],
          US: [
            { label: 'USD', value: 'usd' },
            { label: 'CAD', value: 'cad' },
          ],
        };
        return optionsByRegion[ctx.externalData.userRegion as string] ?? [];
      },
    },
  },
  fields: [
    {
      key: 'currency',
      type: 'select',
      label: 'Currency',
      options: [],
      logic: [
        {
          type: 'derivation',
          targetProperty: 'options',
          functionName: 'getCurrencyOptions',
        },
      ],
    },
  ],
} as const satisfies FormConfig;
```

External data values are reactively tracked - when signals change, property derivations are re-evaluated.

## Related

- **Value Derivation** (see tab above) - Compute field form values
- **[Conditional Logic](../conditional-logic/overview/)** - Control field visibility and state
- **[Array Fields](../../prebuilt/form-arrays/simplified/)** - Working with array fields

--- examples/age-conditional-form ---

[← Back to Quick Start](/examples)

Registration form demonstrating numeric comparison operators for age-based conditional logic.

## Live Demo

<iframe src="http://localhost:4201/#/examples/age-conditional-form" class="example-frame" title="Age Conditional Form Demo"></iframe>

## Overview

This example shows how to use numeric comparison operators to display different fields based on age ranges. Minors see parental consent fields, while seniors see discount options.

**Key patterns demonstrated:**

- Age-appropriate field display
- Numeric comparisons (greater than, less than)
- Multiple conditional sections based on same field

## Implementation

```typescript
import { Component, signal } from '@angular/core';
import { DynamicForm, type FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-age-conditional-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" [(value)]="formValue"></form>`,
})
export class AgeConditionalFormComponent {
  formValue = signal({});

  config = {
    fields: [
      {
        key: 'name',
        type: 'input',
        value: '',
        label: 'Full Name',
        required: true,
      },
      {
        key: 'email',
        type: 'input',
        value: '',
        label: 'Email Address',
        required: true,
        email: true,
      },
      {
        key: 'age',
        type: 'input',
        value: null,
        label: 'Age',
        required: true,
        min: 0,
        max: 120,
        props: {
          type: 'number',
          hint: 'Enter your age to see relevant options',
        },
      },
      {
        key: 'parentalConsent',
        type: 'checkbox',
        value: false,
        label: 'I have parental/guardian consent to register',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'age',
              operator: 'greaterOrEqual',
              value: 18,
            },
          },
          {
            type: 'required',
            condition: {
              type: 'fieldValue',
              fieldPath: 'age',
              operator: 'less',
              value: 18,
            },
          },
        ],
      },
      {
        key: 'parentEmail',
        type: 'input',
        value: '',
        label: 'Parent/Guardian Email',
        email: true,
        props: {
          hint: 'We will send a verification email to your parent/guardian',
        },
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'age',
              operator: 'greaterOrEqual',
              value: 18,
            },
          },
          {
            type: 'required',
            condition: {
              type: 'fieldValue',
              fieldPath: 'age',
              operator: 'less',
              value: 18,
            },
          },
        ],
      },
      {
        key: 'seniorDiscount',
        type: 'checkbox',
        value: false,
        label: 'Apply senior discount (65+)',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'age',
              operator: 'less',
              value: 65,
            },
          },
        ],
      },
      {
        key: 'aarpMember',
        type: 'checkbox',
        value: false,
        label: 'I am an AARP member (additional 5% discount)',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'age',
              operator: 'less',
              value: 65,
            },
          },
        ],
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Register',
      },
    ],
  } as const satisfies FormConfig;
}
```

## How It Works

### Age-Based Visibility

Fields for minors are hidden when age >= 18:

```typescript
{
  key: 'parentalConsent',
  type: 'checkbox',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'age',
      operator: 'greaterOrEqual',
      value: 18,
    },
  }],
}
```

Fields for seniors are hidden when age < 65:

```typescript
{
  key: 'seniorDiscount',
  type: 'checkbox',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'age',
      operator: 'less',
      value: 65,
    },
  }],
}
```

### Conditional Required for Minors

Parent email is required only for minors:

```typescript
{
  key: 'parentEmail',
  type: 'input',
  logic: [
    {
      type: 'hidden',
      condition: {
        type: 'fieldValue',
        fieldPath: 'age',
        operator: 'greaterOrEqual',
        value: 18,
      },
    },
    {
      type: 'required',
      condition: {
        type: 'fieldValue',
        fieldPath: 'age',
        operator: 'less',
        value: 18,
      },
    },
  ],
}
```

## Comparison Operators

This example uses numeric comparison operators:

| Operator         | Description                |
| ---------------- | -------------------------- |
| `greater`        | Greater than (>)           |
| `less`           | Less than (<)              |
| `greaterOrEqual` | Greater than or equal (>=) |
| `lessOrEqual`    | Less than or equal (<=)    |

## Use Cases

- Age-gated registration
- Tiered pricing forms
- Compliance forms with age requirements
- Membership applications

## Related Documentation

- **[Conditional Logic](../../dynamic-behavior/conditional-logic/overview/)** - Full conditional logic guide
- **[Validation](../../validation/basics/)** - Min/max validation
- **[User Registration](../user-registration/)** - Basic registration example

--- examples/array-form ---

[← Back to Quick Start](/examples)

Dynamic form arrays using the complete API with declarative add/remove buttons, custom button placement, and full control over item structure.

## Live Demo

<iframe src="http://localhost:4201/#/examples/array" class="example-frame" title="Array Field Demo"></iframe>

## Overview

This example demonstrates the complete array API with:

- **Flat arrays** with row-based items (input + remove button)
- **Object arrays** with multiple fields per item
- **Declarative buttons** for add, prepend, and remove operations
- **Custom button placement** outside the array container
- **Template-based item creation**

## Implementation

```typescript
import { Component, signal } from '@angular/core';
import { DynamicForm, FormConfig } from '@ng-forge/dynamic-forms';

// Template for new tags — a row with an input and remove button
const tagTemplate = {
  key: 'tag',
  type: 'row',
  fields: [
    {
      key: 'value',
      type: 'input',
      label: 'Tag',
      required: true,
      minLength: 2,
      props: { placeholder: 'Enter a tag', hint: 'Tags must be at least 2 characters' },
    },
    {
      key: 'removeTag',
      type: 'removeArrayItem',
      label: 'Remove',
      className: 'remove-tag-button',
      props: { color: 'warn' },
    },
  ],
} as const;

// Template for new contacts — includes remove button inside each item
const contactTemplate = [
  {
    key: 'name',
    type: 'input',
    label: 'Contact Name',
    required: true,
    minLength: 2,
    props: { placeholder: 'Enter contact name', hint: 'Full name of the emergency contact' },
  },
  {
    key: 'phone',
    type: 'input',
    label: 'Phone Number',
    required: true,
    pattern: /^\d{10}$/,
    validationMessages: { pattern: 'Please enter a valid 10-digit phone number' },
    props: { type: 'tel', placeholder: '5551234567' },
  },
  {
    key: 'relationship',
    type: 'select',
    label: 'Relationship',
    required: true,
    options: [
      { label: 'Family', value: 'family' },
      { label: 'Friend', value: 'friend' },
      { label: 'Colleague', value: 'colleague' },
      { label: 'Other', value: 'other' },
    ],
  },
  {
    key: 'removeContact',
    type: 'removeArrayItem',
    label: 'Remove Contact',
    className: 'remove-contact-button',
    props: { color: 'warn' },
  },
] as const;

@Component({
  selector: 'app-array-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" [(value)]="formValue"></form>`,
})
export class ArrayFormComponent {
  formValue = signal({});

  config = {
    fields: [
      // Flat array with row-based items
      {
        key: 'tags',
        type: 'array',
        fields: [
          [
            {
              key: 'tag',
              type: 'row',
              fields: [
                { key: 'value', type: 'input', label: 'Tag', value: 'angular', required: true, minLength: 2 },
                { key: 'removeTag', type: 'removeArrayItem', label: 'Remove', props: { color: 'warn' } },
              ],
            },
          ],
          [
            {
              key: 'tag',
              type: 'row',
              fields: [
                { key: 'value', type: 'input', label: 'Tag', value: 'typescript', required: true, minLength: 2 },
                { key: 'removeTag', type: 'removeArrayItem', label: 'Remove', props: { color: 'warn' } },
              ],
            },
          ],
        ],
      },
      // Add button placed outside the array
      {
        key: 'addTagButton',
        type: 'addArrayItem',
        label: 'Add Tag',
        arrayKey: 'tags',
        template: [tagTemplate],
        props: { color: 'primary' },
      },

      // Object array with multiple fields per item
      {
        key: 'contacts',
        type: 'array',
        fields: [
          [
            { key: 'name', type: 'input', label: 'Contact Name', value: 'Jane Smith', required: true, minLength: 2 },
            { key: 'phone', type: 'input', label: 'Phone Number', value: '5551234567', required: true },
            {
              key: 'relationship',
              type: 'select',
              label: 'Relationship',
              value: 'family',
              required: true,
              options: [
                { label: 'Family', value: 'family' },
                { label: 'Friend', value: 'friend' },
                { label: 'Colleague', value: 'colleague' },
                { label: 'Other', value: 'other' },
              ],
            },
            { key: 'removeContact', type: 'removeArrayItem', label: 'Remove Contact', props: { color: 'warn' } },
          ],
        ],
      },
      // Multiple add buttons with different behaviors
      {
        key: 'contactButtons',
        type: 'row',
        fields: [
          {
            key: 'prependContactButton',
            type: 'prependArrayItem',
            label: 'Add First',
            arrayKey: 'contacts',
            template: contactTemplate,
            props: { color: 'accent' },
          },
          {
            key: 'addContactButton',
            type: 'addArrayItem',
            label: 'Add Contact',
            arrayKey: 'contacts',
            template: contactTemplate,
            props: { color: 'primary' },
          },
        ],
      },

      { key: 'submit', type: 'submit', label: 'Save All', props: { color: 'primary' } },
    ],
  } as const satisfies FormConfig;
}
```

## Key Features

### Declarative Add/Remove Buttons

Use `addArrayItem`, `prependArrayItem`, and `removeArrayItem` button types directly in your config:

```typescript
// Add button outside the array
{
  key: 'addTag',
  type: 'addArrayItem',
  label: 'Add Tag',
  arrayKey: 'tags',        // Points to the array field
  template: tagTemplate,   // Defines the new item structure
}

// Remove button inside each array item
{
  key: 'removeTag',
  type: 'removeArrayItem',
  label: 'Remove',
}
```

### Custom Button Placement

Place add/prepend buttons anywhere in the form layout:

```typescript
{
  key: 'contactButtons',
  type: 'row',
  fields: [
    { key: 'prepend', type: 'prependArrayItem', label: 'Add First', arrayKey: 'contacts', template: contactTemplate },
    { key: 'append', type: 'addArrayItem', label: 'Add Last', arrayKey: 'contacts', template: contactTemplate },
  ],
}
```

### Templates for New Items

Each add button defines its own template for what to insert:

```typescript
const contactTemplate = [
  { key: 'name', type: 'input', label: 'Name' },
  { key: 'phone', type: 'input', label: 'Phone' },
  { key: 'remove', type: 'removeArrayItem', label: 'Remove' },
];
```

## Use Cases

- Forms requiring custom button placement
- Arrays with multiple add operations (append, prepend, insert)
- Heterogeneous arrays with different item structures
- Complex layouts with row-based array items

## Related Examples

- **[Simplified Array Form](../simplified-array-form/)** - Simpler API with auto-generated buttons
- **[Paginated Form](../paginated-form/)** - Multi-step wizard form
- **[Contact Form](../contact-form/)** - Basic contact form

## Related Documentation

- **[Complete Array API](../../prebuilt/form-arrays/complete/)** - Full API reference
- **[Simplified Array API](../../prebuilt/form-arrays/simplified/)** - Simpler alternative
- **[Validation](../../validation/basics/)** - Form validation guide

--- examples/business-account-form ---

[← Back to Quick Start](/examples)

Account registration form that shows different fields based on whether the user selects personal or business account type.

## Live Demo

<iframe src="http://localhost:4201/#/examples/business-account-form" class="example-frame" title="Business Account Form Demo"></iframe>

## Overview

This example demonstrates how to conditionally show business-specific fields only when the user selects a business account type.

**Key patterns demonstrated:**

- Personal name field hidden for business accounts
- Business fields (company name, tax ID) hidden for personal accounts
- Required validation tied to visibility

## Implementation

```typescript
import { Component, signal } from '@angular/core';
import { DynamicForm, type FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-business-account-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" [(value)]="formValue"></form>`,
})
export class BusinessAccountFormComponent {
  formValue = signal({});

  config = {
    fields: [
      {
        key: 'accountType',
        type: 'radio',
        value: 'personal',
        label: 'Account Type',
        required: true,
        options: [
          { value: 'personal', label: 'Personal Account' },
          { value: 'business', label: 'Business Account' },
        ],
      },
      {
        key: 'name',
        type: 'input',
        value: '',
        label: 'Full Name',
        required: true,
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'accountType',
              operator: 'equals',
              value: 'business',
            },
          },
        ],
      },
      {
        key: 'companyName',
        type: 'input',
        value: '',
        label: 'Company Name',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'accountType',
              operator: 'notEquals',
              value: 'business',
            },
          },
          {
            type: 'required',
            condition: {
              type: 'fieldValue',
              fieldPath: 'accountType',
              operator: 'equals',
              value: 'business',
            },
          },
        ],
      },
      {
        key: 'taxId',
        type: 'input',
        value: '',
        label: 'Tax ID',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'accountType',
              operator: 'notEquals',
              value: 'business',
            },
          },
          {
            type: 'required',
            condition: {
              type: 'fieldValue',
              fieldPath: 'accountType',
              operator: 'equals',
              value: 'business',
            },
          },
        ],
      },
      {
        key: 'numberOfEmployees',
        type: 'input',
        value: null,
        label: 'Number of Employees',
        props: { type: 'number' },
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'accountType',
              operator: 'notEquals',
              value: 'business',
            },
          },
        ],
      },
      {
        key: 'email',
        type: 'input',
        value: '',
        label: 'Email Address',
        required: true,
        email: true,
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Create Account',
      },
    ],
  } as const satisfies FormConfig;
}
```

## How It Works

### Account Type Toggle

The form uses radio buttons to switch between personal and business accounts:

```typescript
{
  key: 'accountType',
  type: 'radio',
  value: 'personal',
  options: [
    { value: 'personal', label: 'Personal Account' },
    { value: 'business', label: 'Business Account' },
  ],
}
```

### Personal vs Business Fields

Personal fields are hidden when business is selected:

```typescript
{
  key: 'name',
  type: 'input',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'equals',
      value: 'business',
    },
  }],
}
```

Business fields are hidden when personal is selected:

```typescript
{
  key: 'companyName',
  type: 'input',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'notEquals',
      value: 'business',
    },
  }],
}
```

## Use Cases

- User registration with account types
- Subscription forms with tiers
- Customer onboarding flows
- Multi-tenant application signup

## Related Documentation

- **[Conditional Logic](../../dynamic-behavior/conditional-logic/overview/)** - Full conditional logic guide
- **[User Registration](../user-registration/)** - Basic registration example
- **[Radio Buttons](../../schema-fields/field-types/)** - Field types reference

--- examples/contact-dynamic-fields ---

[← Back to Quick Start](/examples)

Contact form demonstrating dynamic field visibility based on preferred contact method selection.

## Live Demo

<iframe src="http://localhost:4201/#/examples/contact-dynamic-fields" class="example-frame" title="Contact Dynamic Fields Demo"></iframe>

## Overview

This example shows how to dynamically show or hide form fields based on user selection. When the user chooses their preferred contact method, only the relevant input field is displayed.

**Key patterns demonstrated:**

- Field hidden when contact method doesn't match
- Field becomes required when contact method matches
- Clean user experience - only relevant fields shown

## Implementation

```typescript
import { Component, signal } from '@angular/core';
import { DynamicForm, type FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-contact-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" [(value)]="formValue"></form>`,
})
export class ContactFormComponent {
  formValue = signal({});

  config = {
    fields: [
      {
        key: 'name',
        type: 'input',
        value: '',
        label: 'Full Name',
        required: true,
      },
      {
        key: 'contactMethod',
        type: 'select',
        value: '',
        label: 'Preferred Contact Method',
        required: true,
        options: [
          { value: 'email', label: 'Email' },
          { value: 'phone', label: 'Phone' },
          { value: 'mail', label: 'Postal Mail' },
        ],
      },
      {
        key: 'email',
        type: 'input',
        value: '',
        label: 'Email Address',
        email: true,
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'contactMethod',
              operator: 'notEquals',
              value: 'email',
            },
          },
          {
            type: 'required',
            condition: {
              type: 'fieldValue',
              fieldPath: 'contactMethod',
              operator: 'equals',
              value: 'email',
            },
          },
        ],
      },
      {
        key: 'phone',
        type: 'input',
        value: '',
        label: 'Phone Number',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'contactMethod',
              operator: 'notEquals',
              value: 'phone',
            },
          },
          {
            type: 'required',
            condition: {
              type: 'fieldValue',
              fieldPath: 'contactMethod',
              operator: 'equals',
              value: 'phone',
            },
          },
        ],
        props: { type: 'tel' },
      },
      {
        key: 'address',
        type: 'textarea',
        value: '',
        label: 'Mailing Address',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'contactMethod',
              operator: 'notEquals',
              value: 'mail',
            },
          },
          {
            type: 'required',
            condition: {
              type: 'fieldValue',
              fieldPath: 'contactMethod',
              operator: 'equals',
              value: 'mail',
            },
          },
        ],
        props: { rows: 3 },
      },
      {
        key: 'message',
        type: 'textarea',
        value: '',
        label: 'Message',
        required: true,
        minLength: 10,
        props: { rows: 4 },
      },
    ],
  } as const satisfies FormConfig;
}
```

## How It Works

### Conditional Visibility

Each contact field uses the `logic` array to control visibility:

```typescript
logic: [
  {
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'contactMethod',
      operator: 'notEquals',
      value: 'email',
    },
  },
];
```

When `contactMethod !== 'email'`, the email field is hidden.

### Conditional Required

The same `logic` array also makes fields required when visible:

```typescript
logic: [
  {
    type: 'required',
    condition: {
      type: 'fieldValue',
      fieldPath: 'contactMethod',
      operator: 'equals',
      value: 'email',
    },
  },
];
```

This ensures that visible contact fields are required.

## Use Cases

- Contact forms with multiple contact options
- Preference forms
- Survey forms with branching logic
- Customer support request forms

## Related Documentation

- **[Conditional Logic](../../dynamic-behavior/conditional-logic/overview/)** - Full conditional logic guide
- **[Validation](../../validation/basics/)** - Form validation
- **[Contact Form](../contact-form/)** - Basic contact form example

--- examples/contact-form ---

[← Back to Quick Start](/examples)

Simple contact form demonstrating basic form fields, validation, and user input.

## Live Demo

<iframe src="http://localhost:4201/#/examples/contact" class="example-frame" title="Contact Form Demo"></iframe>

## Overview

This example shows a basic contact form with:

- Text inputs (name, email, phone)
- Textarea for messages
- Date selection
- Basic validation (required, email format)
- Real-time validation feedback

## Implementation

```typescript
import { Component } from '@angular/core';
import { DynamicForm, FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-contact-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config"></form>`,
})
export class ContactFormComponent {
  config = {
    fields: [
      {
        key: 'firstName',
        type: 'input',
        label: 'First Name',
        value: '',
        required: true,
        props: { placeholder: 'Your first name' },
      },
      {
        key: 'lastName',
        type: 'input',
        label: 'Last Name',
        value: '',
        required: true,
        props: { placeholder: 'Your last name' },
      },
      {
        key: 'email',
        type: 'input',
        label: 'Email',
        value: '',
        required: true,
        email: true,
        props: {
          type: 'email',
          placeholder: 'email@example.com',
        },
      },
      {
        key: 'phone',
        type: 'input',
        label: 'Phone',
        value: '',
        props: {
          type: 'tel',
          placeholder: '+1 (555) 000-0000',
        },
      },
      {
        key: 'subject',
        type: 'select',
        label: 'Subject',
        value: '',
        required: true,
        options: [
          { value: 'general', label: 'General Inquiry' },
          { value: 'support', label: 'Technical Support' },
          { value: 'sales', label: 'Sales Question' },
          { value: 'feedback', label: 'Feedback' },
        ],
        props: { placeholder: 'Select a subject' },
      },
      {
        key: 'message',
        type: 'textarea',
        label: 'Message',
        value: '',
        required: true,
        minLength: 10,
        maxLength: 500,
        validationMessages: {
          required: 'Please enter your message',
          minLength: 'Message must be at least 10 characters',
          maxLength: 'Message cannot exceed 500 characters',
        },
        props: {
          placeholder: 'Tell us how we can help...',
          rows: 5,
        },
      },
      {
        key: 'subscribe',
        type: 'checkbox',
        label: 'Subscribe to newsletter',
        value: false,
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Send Message',
        props: { color: 'primary' },
      },
    ],
  } as const satisfies FormConfig;
}
```

## Key Features

### Field Validation

All critical fields have validation:

```typescript
{
  key: 'email',
  required: true,
  email: true,  // Built-in email validator
}

{
  key: 'message',
  required: true,
  minLength: 10,
  maxLength: 500,
}
```

### User-Friendly Placeholders

Every field includes helpful placeholder text:

```typescript
props: {
  placeholder: 'email@example.com',  // Shows expected format
}
```

### Subject Categorization

Dropdown allows users to categorize their inquiry:

```typescript
{
  key: 'subject',
  type: 'select',
  options: [
    { value: 'general', label: 'General Inquiry' },
    { value: 'support', label: 'Technical Support' },
    // ...
  ],
}
```

## Use Cases

- Customer support forms
- Lead generation
- General inquiries
- Feedback collection
- Event registration
- Newsletter signup

## Related Examples

- **[User Registration](../user-registration/)** - Multi-step form with conditional fields
- **[Login Form](../login-form/)** - Simple authentication

## Related Documentation

- **[Validation](../../validation/basics/)** - Form validation guide
- **[Material Integration](../../ui-libs-integrations/material/)** - Material Design styling

--- examples/enterprise-features ---

[← Back to Quick Start](/examples)

Complex configuration form demonstrating AND/OR logic for enterprise feature gating.

## Live Demo

<iframe src="http://localhost:4201/#/examples/enterprise-features" class="example-frame" title="Enterprise Features Demo"></iframe>

## Overview

This example shows how to use combined AND/OR conditions to control access to premium features based on account type and team size. Enterprise features are only shown when specific criteria are met.

**Key patterns demonstrated:**

- AND/OR logic for complex conditions
- Multiple fields affecting each other
- Enterprise feature gating

## Implementation

```typescript
import { Component, signal } from '@angular/core';
import { DynamicForm, type FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-enterprise-features-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" [(value)]="formValue"></form>`,
})
export class EnterpriseFeaturesFormComponent {
  formValue = signal({});

  config = {
    fields: [
      {
        key: 'accountType',
        type: 'select',
        value: '',
        label: 'Account Type',
        required: true,
        options: [
          { value: 'free', label: 'Free' },
          { value: 'pro', label: 'Pro' },
          { value: 'enterprise', label: 'Enterprise' },
        ],
      },
      {
        key: 'teamSize',
        type: 'input',
        value: null,
        label: 'Team Size',
        min: 1,
        props: {
          type: 'number',
          hint: 'Number of team members',
        },
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'accountType',
              operator: 'equals',
              value: 'free',
            },
          },
        ],
      },
      {
        key: 'basicFeaturesTitle',
        type: 'text',
        label: 'Basic Features',
        props: { elementType: 'h4' },
      },
      {
        key: 'analyticsEnabled',
        type: 'toggle',
        value: true,
        label: 'Enable Analytics',
      },
      {
        key: 'notificationsEnabled',
        type: 'toggle',
        value: true,
        label: 'Enable Notifications',
      },
      {
        key: 'proFeaturesTitle',
        type: 'text',
        label: 'Pro Features',
        props: { elementType: 'h4' },
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'accountType',
              operator: 'equals',
              value: 'free',
            },
          },
        ],
      },
      {
        key: 'apiAccess',
        type: 'toggle',
        value: false,
        label: 'Enable API Access',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'accountType',
              operator: 'equals',
              value: 'free',
            },
          },
        ],
      },
      {
        key: 'advancedReports',
        type: 'toggle',
        value: false,
        label: 'Enable Advanced Reports',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'accountType',
              operator: 'equals',
              value: 'free',
            },
          },
        ],
      },
      {
        key: 'enterpriseFeaturesTitle',
        type: 'text',
        label: 'Enterprise Features',
        props: { elementType: 'h4' },
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'or',
              conditions: [
                {
                  type: 'fieldValue',
                  fieldPath: 'accountType',
                  operator: 'notEquals',
                  value: 'enterprise',
                },
                {
                  type: 'fieldValue',
                  fieldPath: 'teamSize',
                  operator: 'less',
                  value: 10,
                },
              ],
            },
          },
        ],
      },
      {
        key: 'ssoEnabled',
        type: 'toggle',
        value: false,
        label: 'Enable SSO (Single Sign-On)',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'or',
              conditions: [
                {
                  type: 'fieldValue',
                  fieldPath: 'accountType',
                  operator: 'notEquals',
                  value: 'enterprise',
                },
                {
                  type: 'fieldValue',
                  fieldPath: 'teamSize',
                  operator: 'less',
                  value: 10,
                },
              ],
            },
          },
        ],
      },
      {
        key: 'customBranding',
        type: 'toggle',
        value: false,
        label: 'Enable Custom Branding',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'or',
              conditions: [
                {
                  type: 'fieldValue',
                  fieldPath: 'accountType',
                  operator: 'equals',
                  value: 'free',
                },
                {
                  type: 'fieldValue',
                  fieldPath: 'accountType',
                  operator: 'equals',
                  value: 'pro',
                },
              ],
            },
          },
        ],
      },
      {
        key: 'dedicatedSupport',
        type: 'toggle',
        value: false,
        label: 'Enable Dedicated Support',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'or',
              conditions: [
                {
                  type: 'fieldValue',
                  fieldPath: 'accountType',
                  operator: 'notEquals',
                  value: 'enterprise',
                },
                {
                  type: 'fieldValue',
                  fieldPath: 'teamSize',
                  operator: 'less',
                  value: 10,
                },
              ],
            },
          },
        ],
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Save Configuration',
      },
    ],
  } as const satisfies FormConfig;
}
```

## How It Works

### OR Conditions

Enterprise features require enterprise account AND team size >= 10. They're hidden if EITHER condition fails:

```typescript
{
  key: 'ssoEnabled',
  type: 'toggle',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'or',
      conditions: [
        {
          type: 'fieldValue',
          fieldPath: 'accountType',
          operator: 'notEquals',
          value: 'enterprise',
        },
        {
          type: 'fieldValue',
          fieldPath: 'teamSize',
          operator: 'less',
          value: 10,
        },
      ],
    },
  }],
}
```

This reads as: "Hide SSO if account is NOT enterprise OR team size < 10"

### Tiered Feature Access

Different tiers have different feature access:

| Feature           | Free | Pro | Enterprise (10+) |
| ----------------- | ---- | --- | ---------------- |
| Analytics         | ✓    | ✓   | ✓                |
| Notifications     | ✓    | ✓   | ✓                |
| API Access        | ✗    | ✓   | ✓                |
| Advanced Reports  | ✗    | ✓   | ✓                |
| SSO               | ✗    | ✗   | ✓                |
| Custom Branding   | ✗    | ✗   | ✓                |
| Dedicated Support | ✗    | ✗   | ✓                |

## Using AND Conditions

For features that require ALL conditions to be met, use `type: 'and'`:

```typescript
{
  type: 'hidden',
  condition: {
    type: 'and',
    conditions: [
      { type: 'fieldValue', fieldPath: 'accountType', operator: 'equals', value: 'enterprise' },
      { type: 'fieldValue', fieldPath: 'teamSize', operator: 'greaterOrEqual', value: 10 },
      { type: 'fieldValue', fieldPath: 'verified', operator: 'equals', value: true },
    ],
  },
}
```

## Use Cases

- SaaS feature configuration
- Admin settings panels
- Permission management
- Subscription tier management

## Related Documentation

- **[Conditional Logic](../../dynamic-behavior/conditional-logic/overview/)** - Full conditional logic guide
- **[Combining Conditions](../../dynamic-behavior/conditional-logic/overview/#combining-conditions)** - AND/OR logic
- **[Form Groups](../../prebuilt/form-groups/)** - Organizing fields

--- examples/index ---

{{ NgDocActions.demo("ExamplesIndexComponent", { container: false }) }}

--- examples/login-form ---

[← Back to Quick Start](/examples)

Simple login form demonstrating authentication UI with email and password fields.

## Live Demo

<iframe src="http://localhost:4201/#/examples/login" class="example-frame" title="Login Form Demo"></iframe>

## Overview

A minimal login form showing:

- Email input with validation
- Password input (masked)
- Remember me checkbox
- Submit button
- Clean, focused UI

## Implementation

```typescript
import { Component } from '@angular/core';
import { DynamicForm, FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-login-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config"></form>`,
})
export class LoginFormComponent {
  config = {
    // Define common validation messages at the form level
    defaultValidationMessages: {
      required: 'This field is required',
      minLength: 'Must be at least {{requiredLength}} characters',
    },
    fields: [
      {
        key: 'title',
        type: 'text',
        label: 'Sign In',
        props: {
          elementType: 'h2',
        },
      },
      {
        key: 'email',
        type: 'input',
        label: 'Email Address',
        required: true,
        email: true,
        // Only specify custom message for 'email' - 'required' uses default
        validationMessages: {
          email: 'Please enter a valid email address',
        },
        props: {
          type: 'email',
          placeholder: 'your@email.com',
          hint: 'Enter the email associated with your account',
        },
      },
      {
        key: 'password',
        type: 'input',
        label: 'Password',
        required: true,
        minLength: 8,
        // Override default 'required' message with custom one
        validationMessages: {
          required: 'Password is required',
        },
        // 'minLength' will use default with interpolated {{requiredLength}}
        props: {
          type: 'password',
          placeholder: 'Enter your password',
        },
      },
      {
        key: 'remember',
        type: 'checkbox',
        label: 'Remember me for 30 days',
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Sign In',
        props: {
          color: 'primary',
        },
      },
    ],
  } as const satisfies FormConfig;
}
```

## Key Features

### Email Validation

Built-in email format validation:

```typescript
{
  key: 'email',
  email: true,  // Validates email format
  validationMessages: {
    email: 'Please enter a valid email',
  },
}
```

### Password Security

Minimum length requirement and masked input:

```typescript
{
  key: 'password',
  minLength: 8,
  props: {
    type: 'password',  // Masks input
  },
}
```

### Remember Me Option

Simple checkbox for persistent login:

```typescript
{
  key: 'remember',
  type: 'checkbox',
  label: 'Remember me',
}
```

## Common Enhancements

### Add "Forgot Password" Link

```typescript
{
  type: 'text',
  key: 'forgotLink',
  label: '<a href="/forgot-password">Forgot your password?</a>',
}
```

### Social Login Buttons

For social login buttons, you can use text fields with links or handle this outside the form:

```typescript
{
  type: 'text',
  key: 'socialText',
  label: 'Or sign in with Google or GitHub',
}
```

**Note:** Social login typically involves OAuth flows handled outside the form. Consider placing social login buttons in your component template rather than in the form configuration.

### Add Sign Up Link

```typescript
{
  type: 'text',
  key: 'signupText',
  label: "Don't have an account? <a href='/signup'>Sign up</a>",
}
```

## Use Cases

- User authentication
- Admin panels
- Member portals
- Dashboard access
- Protected areas

## Related Examples

- **[User Registration](../user-registration/)** - Account creation
- **[Contact Form](../contact-form/)** - Basic form with validation

## Related Documentation

- **[Validation](../../validation/basics/)** - Form validation guide
- **[Material Integration](../../ui-libs-integrations/material/)** - Material Design styling

--- examples/paginated-form ---

[← Back to Quick Start](/examples)

A comprehensive multi-step registration form demonstrating the `page` field type for creating wizards and stepped workflows.

## Live Demo

<iframe src="http://localhost:4201/#/examples/paginated-form" class="example-frame" title="Paginated Form Demo"></iframe>

## Overview

This example showcases a 4-step registration form with:

- **Page navigation** with Previous/Next/Submit buttons
- **Per-page validation** that prevents moving forward with invalid data
- **Progress tracking** through multiple steps
- **Flattened form values** - page fields don't nest their children
- **Mixed field types** across different steps

## Implementation

{% raw %}

```typescript
import { Component, signal } from '@angular/core';
import { DynamicForm, FormConfig } from '@ng-forge/dynamic-forms';
import '@ng-forge/dynamic-forms-material';

@Component({
  selector: 'app-paginated-form',
  imports: [DynamicForm, JsonPipe],
  template: `
    <form [dynamic-form]="config" [(value)]="formValue"></form>
  `,
})
export class PaginatedFormComponent {
  formValue = signal({});

  config = {
    fields: [
      // Step 1: Personal Information
      {
        key: 'step1',
        type: 'page',
        fields: [
          {
            key: 'step1Title',
            type: 'text',
            label: 'Personal Information',
            props: { elementType: 'h2' },
          },
          {
            key: 'step1Description',
            type: 'text',
            label: 'Please provide your basic information',
          },
          {
            key: 'firstName',
            type: 'input',
            label: 'First Name',
            value: '',
            required: true,
          },
          {
            key: 'lastName',
            type: 'input',
            label: 'Last Name',
            value: '',
            required: true,
          },
          {
            key: 'birthDate',
            type: 'datepicker',
            label: 'Date of Birth',
            required: true,
          },
          {
            type: 'next',
            key: 'step1Next',
            label: 'Continue to Contact Info',
          },
        ],
      },

      // Step 2: Contact Information
      {
        key: 'step2',
        type: 'page',
        fields: [
          {
            key: 'step2Title',
            type: 'text',
            label: 'Contact Information',
            props: { elementType: 'h2' },
          },
          {
            key: 'step2Description',
            type: 'text',
            label: 'How can we reach you?',
          },
          {
            key: 'email',
            type: 'input',
            label: 'Email Address',
            value: '',
            required: true,
            email: true,
          },
          {
            key: 'phone',
            type: 'input',
            label: 'Phone Number',
            value: '',
            required: true,
          },
          {
            key: 'contactPreference',
            type: 'radio',
            label: 'Preferred Contact Method',
            value: 'email',
            options: [
              { value: 'email', label: 'Email' },
              { value: 'phone', label: 'Phone' },
              { value: 'both', label: 'Either' },
            ],
          },
          {
            type: 'row',
            key: 'step2Buttons',
            fields: [
              { type: 'previous', key: 'step2Previous', label: 'Back' },
              { type: 'next', key: 'step2Next', label: 'Continue' },
            ],
          },
        ],
      },

      // Step 3: Address
      {
        key: 'step3',
        type: 'page',
        fields: [
          {
            key: 'step3Title',
            type: 'text',
            label: 'Address',
            props: { elementType: 'h2' },
          },
          {
            key: 'step3Description',
            type: 'text',
            label: 'Where do you live?',
          },
          {
            key: 'street',
            type: 'input',
            label: 'Street Address',
            value: '',
            required: true,
          },
          {
            type: 'row',
            key: 'cityStateRow',
            fields: [
              { key: 'city', type: 'input', label: 'City', value: '', required: true, col: 6 },
              { key: 'state', type: 'select', label: 'State', required: true, options: [...], col: 6 },
            ],
          },
          {
            key: 'zipCode',
            type: 'input',
            label: 'ZIP Code',
            value: '',
            required: true,
            pattern: /^\d{5}$/,
          },
          {
            type: 'row',
            key: 'step3Buttons',
            fields: [
              { type: 'previous', key: 'step3Previous', label: 'Back' },
              { type: 'next', key: 'step3Next', label: 'Continue' },
            ],
          },
        ],
      },

      // Step 4: Preferences & Completion
      {
        key: 'step4',
        type: 'page',
        fields: [
          {
            key: 'step4Title',
            type: 'text',
            label: 'Preferences',
            props: { elementType: 'h2' },
          },
          {
            key: 'step4Description',
            type: 'text',
            label: 'Tell us about your preferences',
          },
          {
            key: 'interests',
            type: 'multi-checkbox',
            label: 'Interests',
            options: [
              { value: 'technology', label: 'Technology' },
              { value: 'sports', label: 'Sports' },
              // ... more options
            ],
          },
          {
            key: 'newsletter',
            type: 'checkbox',
            label: 'Subscribe to newsletter',
            value: true,
          },
          {
            key: 'terms',
            type: 'checkbox',
            label: 'I agree to the terms and conditions',
            required: true,
          },
          {
            type: 'row',
            key: 'step4Buttons',
            fields: [
              { type: 'previous', key: 'step4Previous', label: 'Back' },
              { type: 'submit', key: 'submit', label: 'Complete Registration' },
            ],
          },
        ],
      },
    ],
  } as const satisfies FormConfig;
}
```

{% endraw %}

## Form Value Structure

Note that page fields use `valueHandling: 'flatten'`, meaning their children are flattened to the parent level:

```json
{
  "firstName": "John",
  "lastName": "Doe",
  "birthDate": "1990-01-01",
  "email": "john@example.com",
  "phone": "+1-555-0000",
  "contactPreference": "email",
  "street": "123 Main St",
  "city": "New York",
  "state": "ny",
  "zipCode": "10001",
  "interests": ["technology", "sports"],
  "newsletter": true,
  "terms": true
}
```

The page structure is **not reflected** in the form value - all fields are at the top level.

## Key Features

### Navigation Buttons

- **`type: 'next'`** - Validates current page and moves to next step
- **`type: 'previous'`** - Goes to previous step without validation
- **`type: 'submit'`** - Validates entire form and submits

### Per-Page Validation

Each page validates independently. Users cannot proceed to the next page until all required fields on the current page are valid.

### Page Configuration

```typescript
{
  key: 'step1',    // Required key
  type: 'page',    // Page field type
  fields: [        // Child fields
    // Add text fields for titles/descriptions if needed
    { key: 'title', type: 'text', label: 'Page Title', props: { elementType: 'h2' } },
    { key: 'desc', type: 'text', label: 'Page description...' },
    // ... other fields for this page
  ],
}
```

## Performance & Lazy Loading

Dynamic Forms uses Angular's `@defer` blocks with **smart prefetching** to achieve true lazy loading while maintaining flicker-free navigation.

### How It Works

- **Current page loads immediately** - The active page renders instantly
- **Adjacent pages (±1) prefetch** - Next/previous pages load in background for instant navigation
- **Distant pages defer until idle** - Pages 2+ steps away load when browser is idle
- **Automatic optimization** - No configuration needed - Dynamic Forms handles this automatically

### Benefits

```typescript
// Example: Currently on step 2 of 5
fields: [
  { key: 'step1', type: 'page', fields: [...] }, // ✓ Prefetched (adjacent)
  { key: 'step2', type: 'page', fields: [...] }, // ✓ Visible (current)
  { key: 'step3', type: 'page', fields: [...] }, // ✓ Prefetched (adjacent)
  { key: 'step4', type: 'page', fields: [...] }, // ⏳ Deferred (distant)
  { key: 'step5', type: 'page', fields: [...] }, // ⏳ Deferred (distant)
]
```

**Performance advantages:**

- ⚡ **Zero flicker navigation** - Adjacent pages prefetched for instant next/previous
- 🚀 **Faster initial load** - Only 3 pages load immediately, distant pages defer until idle
- ⏱️ **Better Time to Interactive (TTI)** - Reduced initial JavaScript parsing/compilation
- 📱 **Mobile-friendly** - Lower startup cost on slower devices
- 🎯 **Optimized user experience** - Smooth page transitions without loading states

### Technical Details

Under the hood, the page orchestrator uses a **2-tier loading strategy**:

```typescript
@if (i === currentPageIndex || i === currentPageIndex + 1 || i === currentPageIndex - 1) {
  <!-- Current and adjacent pages: render immediately (but hide adjacent) -->
  @defer (on immediate) {
    <page-field [isVisible]="i === currentPageIndex" />
  }
} @else {
  <!-- Distant pages: defer until idle -->
  @defer (on idle) {
    <page-field [isVisible]="false" />
  }
}
```

This means:

- **Current + adjacent pages render immediately** - Using `@defer (on immediate)` to render during browser idle
- **Visibility controlled via input and CSS** - Adjacent pages are fully rendered but hidden with `display: none`
- **Initial load optimization** - Only 3 pages render initially, distant pages defer until idle
- **Zero flicker navigation** - Next/previous pages already rendered, just toggle visibility
- **Once loaded, pages persist** - Pages remain in DOM (hidden with CSS) after initial load

The primary benefit is **optimizing initial load performance**, not ongoing memory usage.

### Best Practices

For optimal performance with multi-step forms:

1. **Keep pages focused** - Limit each page to 5-10 fields for best UX
2. **Put heavy pages later** - Place pages with expensive operations or large datasets later in the flow so they defer until idle
3. **Front-load critical data** - Place important fields in early pages (they prefetch immediately)
4. **Leverage the 3-page window** - Only current + adjacent pages load immediately, so structure your flow accordingly

**Example optimization:**

```typescript
fields: [
  {
    key: 'basicInfo',
    type: 'page',
    fields: [
      /* lightweight fields */
    ],
  },
  {
    key: 'contact',
    type: 'page',
    fields: [
      /* lightweight fields */
    ],
  },
  {
    key: 'address',
    type: 'page',
    fields: [
      /* lightweight fields */
    ],
  },
  // These won't load until user reaches page 2-4 (when idle)
  {
    key: 'preferences',
    type: 'page',
    fields: [
      /* heavy multi-checkbox with 100 options */
    ],
  },
  {
    key: 'advanced',
    type: 'page',
    fields: [
      /* complex conditional logic */
    ],
  },
];
```

With this structure:

- **Pages 1-2** load immediately (current + adjacent)
- **Page 3** prefetches when you reach page 2
- **Pages 4-5** defer until browser is idle, saving initial load time

## Common Enhancements

### Dynamic Steps

Show/hide pages based on user choices:

```typescript
{
  key: 'businessInfo',
  type: 'page',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'notEquals',
      value: 'business',
    },
  }],
  fields: [/* ... */],
}
```

### Progress Indicator

Add a custom progress component:

{% raw %}

```typescript
template: `
  <div class="progress-bar">
    Step {{ currentPage() + 1 }} of {{ totalPages }}
  </div>
  <form [dynamic-form]="config" [(value)]="formValue" />
`;
```

{% endraw %}

### Conditional Validation

Apply different validation rules per step:

```typescript
{
  key: 'taxId',
  type: 'input',
  label: 'Tax ID',
  value: '',
  validators: [{
    type: 'required',
    when: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'equals',
      value: 'business',
    },
  }],
}
```

## Use Cases

- **Multi-step registration** - Break long forms into digestible steps
- **Onboarding flows** - Guide users through setup processes
- **Checkout processes** - Separate shipping, payment, and review
- **Survey forms** - Organize questions into logical sections
- **Complex data entry** - Reduce cognitive load with progressive disclosure

## Related Examples

- [User Registration Form](../user-registration) - Single-page registration with validation
- [Contact Form](../contact-form) - Simple contact form
- [Login Form](../login-form) - Basic authentication

## Related Documentation

- [Conditional Logic](../../dynamic-behavior/conditional-logic/overview) - Show/hide pages dynamically
- [Validation](../../validation/basics) - Per-page and cross-page validation
- [Material Integration](../../ui-libs-integrations/material/) - Material Design styling

--- examples/shipping-billing-address ---

[← Back to Quick Start](/examples)

Checkout form demonstrating the common "same as billing" pattern for shipping addresses.

## Live Demo

<iframe src="http://localhost:4201/#/examples/shipping-billing-address" class="example-frame" title="Shipping Billing Address Demo"></iframe>

## Overview

This example shows how to toggle an entire group of fields based on a checkbox. When "Shipping same as billing" is checked, the shipping address fields are hidden.

**Key patterns demonstrated:**

- Entire group hidden/shown with single condition
- Checkbox controls form complexity
- Reduces user effort when addresses are the same

## Implementation

```typescript
import { Component, signal } from '@angular/core';
import { DynamicForm, type FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-shipping-billing-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" [(value)]="formValue"></form>`,
})
export class ShippingBillingFormComponent {
  formValue = signal({});

  config = {
    fields: [
      {
        key: 'billingTitle',
        type: 'text',
        label: 'Billing Address',
        props: { elementType: 'h4' },
      },
      {
        key: 'billingAddress',
        type: 'group',
        fields: [
          {
            key: 'street',
            type: 'input',
            value: '',
            label: 'Street Address',
            required: true,
          },
          {
            key: 'city',
            type: 'input',
            value: '',
            label: 'City',
            required: true,
          },
          {
            key: 'state',
            type: 'input',
            value: '',
            label: 'State/Province',
            required: true,
          },
          {
            key: 'zipCode',
            type: 'input',
            value: '',
            label: 'ZIP/Postal Code',
            required: true,
          },
        ],
      },
      {
        key: 'sameAsBilling',
        type: 'checkbox',
        value: false,
        label: 'Shipping address is same as billing address',
      },
      {
        key: 'shippingTitle',
        type: 'text',
        label: 'Shipping Address',
        props: { elementType: 'h4' },
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'sameAsBilling',
              operator: 'equals',
              value: true,
            },
          },
        ],
      },
      {
        key: 'shippingAddress',
        type: 'group',
        logic: [
          {
            type: 'hidden',
            condition: {
              type: 'fieldValue',
              fieldPath: 'sameAsBilling',
              operator: 'equals',
              value: true,
            },
          },
        ],
        fields: [
          {
            key: 'street',
            type: 'input',
            value: '',
            label: 'Street Address',
            required: true,
          },
          {
            key: 'city',
            type: 'input',
            value: '',
            label: 'City',
            required: true,
          },
          {
            key: 'state',
            type: 'input',
            value: '',
            label: 'State/Province',
            required: true,
          },
          {
            key: 'zipCode',
            type: 'input',
            value: '',
            label: 'ZIP/Postal Code',
            required: true,
          },
        ],
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Continue to Payment',
      },
    ],
  } as const satisfies FormConfig;
}
```

## How It Works

### Checkbox Toggle

A simple checkbox controls whether shipping fields are visible:

```typescript
{
  key: 'sameAsBilling',
  type: 'checkbox',
  value: false,
  label: 'Shipping address is same as billing address',
}
```

### Group Visibility

The entire shipping address group is hidden when the checkbox is checked:

```typescript
{
  key: 'shippingAddress',
  type: 'group',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'sameAsBilling',
      operator: 'equals',
      value: true,
    },
  }],
  fields: [
    // All shipping fields...
  ],
}
```

### Section Titles

The section title is also hidden along with the group:

```typescript
{
  key: 'shippingTitle',
  type: 'text',
  label: 'Shipping Address',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'sameAsBilling',
      operator: 'equals',
      value: true,
    },
  }],
}
```

## Use Cases

- E-commerce checkout flows
- Order forms
- Account billing setup
- Subscription management

## Related Documentation

- **[Conditional Logic](../../dynamic-behavior/conditional-logic/overview/)** - Full conditional logic guide
- **[Form Groups](../../prebuilt/form-groups/)** - Working with groups
- **[Checkbox Fields](../../schema-fields/field-types/)** - Field types reference

--- examples/simplified-array-form ---

[← Back to Quick Start](/examples)

Dynamic arrays using the simplified API with auto-generated add/remove buttons, template-based item definitions, and both primitive and object arrays.

## Live Demo

<iframe src="http://localhost:4201/#/examples/simplified-array" class="example-frame" title="Simplified Array Demo"></iframe>

## Overview

This example showcases the simplified array API with:

- **Primitive arrays** (tags) with flat scalar values
- **Object arrays** (contacts) with multiple fields per item
- **Empty arrays** that start with no items
- **Button customization** including opt-out
- **Auto-generated add/remove buttons**

## Implementation

```typescript
import { Component, signal } from '@angular/core';
import { DynamicForm, FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-simplified-array-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" [(value)]="formValue"></form>`,
})
export class SimplifiedArrayFormComponent {
  formValue = signal({});

  config = {
    fields: [
      // Primitive array — tags
      {
        key: 'tags',
        type: 'array',
        template: {
          key: 'value',
          type: 'input',
          label: 'Tag',
          required: true,
          minLength: 2,
          props: { placeholder: 'Enter a tag' },
        },
        value: ['angular', 'typescript'],
        addButton: { label: 'Add Tag', props: { color: 'primary' } },
        removeButton: { label: 'Remove', props: { color: 'warn' } },
      },

      // Object array — contacts
      {
        key: 'contacts',
        type: 'array',
        template: [
          {
            key: 'name',
            type: 'input',
            label: 'Contact Name',
            required: true,
            minLength: 2,
            props: { placeholder: 'Enter contact name' },
          },
          {
            key: 'phone',
            type: 'input',
            label: 'Phone Number',
            props: { type: 'tel', placeholder: '5551234567' },
          },
        ],
        value: [
          { name: 'Jane Smith', phone: '5551234567' },
          { name: 'John Doe', phone: '5559876543' },
        ],
        addButton: { label: 'Add Contact', props: { color: 'primary' } },
      },

      // Empty array — notes
      {
        key: 'notes',
        type: 'array',
        template: {
          key: 'text',
          type: 'input',
          label: 'Note',
          props: { placeholder: 'Enter a note' },
        },
        addButton: { label: 'Add Note' },
      },

      // No remove button — categories
      {
        key: 'categories',
        type: 'array',
        template: { key: 'name', type: 'input', label: 'Category' },
        value: ['Frontend', 'Backend'],
        removeButton: false,
        addButton: { label: 'Add Category' },
      },

      { key: 'submit', type: 'submit', label: 'Save All', props: { color: 'primary' } },
    ],
  } as const satisfies FormConfig;
}
```

## Key Features

### Template-Based Items

Define the item structure once via `template`, and provide initial data via `value`:

```typescript
{
  key: 'tags',
  type: 'array',
  template: { key: 'value', type: 'input', label: 'Tag', required: true },
  value: ['angular', 'typescript'],
}
```

### Auto-Generated Buttons

Add and remove buttons are generated automatically. Customize labels and props:

```typescript
addButton: { label: 'Add Tag', props: { color: 'primary' } },
removeButton: { label: 'Remove', props: { color: 'warn' } },
```

### Button Opt-Out

Disable buttons entirely with `false`:

```typescript
removeButton: false,  // No remove buttons on items
addButton: false,     // No add button
```

## Use Cases

- Tag lists and keyword management
- Contact lists with multiple fields
- Dynamic note-taking
- Category management
- Any repeating data entry

## Related Examples

- **[Array Form (Complete)](../array-form/)** - Full control with declarative buttons and EventBus
- **[Paginated Form](../paginated-form/)** - Multi-step wizard form
- **[Contact Form](../contact-form/)** - Basic contact form

## Related Documentation

- **[Simplified Array API](../../prebuilt/form-arrays/simplified/)** - Full API reference
- **[Complete Array API](../../prebuilt/form-arrays/complete/)** - Advanced array features
- **[Validation](../../validation/basics/)** - Form validation guide

--- examples/user-registration ---

[← Back to Quick Start](/examples)

Complete example of a user registration form with validation, conditional logic, and proper type safety.

## Live Demo

<iframe src="http://localhost:4201/#/examples/user-registration" class="example-frame" title="User Registration Demo"></iframe>

## Overview

This example demonstrates:

- Multi-step form with validation
- Password strength validation
- Conditional fields (business account)
- Terms and conditions acceptance
- Type-safe form submission
- Material Design integration

## Complete Implementation

```typescript
import { Component } from '@angular/core';
import { FormConfig, DynamicForm } from '@ng-forge/dynamic-forms';

const registrationConfig = {
  fields: [
    // Step 1: Account Information
    {
      type: 'page',
      key: 'accountPage',
      fields: [
        {
          type: 'text',
          key: 'accountText',
          label: 'Create your account',
          props: { elementType: 'h3' },
        },
        {
          key: 'username',
          type: 'input',
          value: '',
          label: 'Username',
          required: true,
          minLength: 3,
          maxLength: 20,
          pattern: '^[a-zA-Z0-9_]+$',
          validationMessages: {
            required: 'Username is required',
            minLength: 'Username must be at least 3 characters',
            maxLength: 'Username cannot exceed 20 characters',
            pattern: 'Username can only contain letters, numbers, and underscores',
          },
          props: {
            appearance: 'outline',
            hint: '3-20 characters, letters, numbers, and underscores only',
          },
        },
        {
          key: 'email',
          type: 'input',
          value: '',
          label: 'Email Address',
          required: true,
          email: true,
          validationMessages: {
            required: 'Email is required',
            email: 'Please enter a valid email address',
          },
          props: {
            type: 'email',
            appearance: 'outline',
            hint: "We'll send a verification email",
          },
        },
        {
          key: 'password',
          type: 'input',
          value: '',
          label: 'Password',
          required: true,
          minLength: 8,
          pattern: '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$',
          validationMessages: {
            required: 'Password is required',
            minLength: 'Password must be at least 8 characters',
            pattern: 'Password must include uppercase, lowercase, number, and special character',
          },
          props: {
            type: 'password',
            appearance: 'outline',
            hint: 'At least 8 characters with uppercase, lowercase, number, and special character',
          },
        },
        {
          key: 'confirmPassword',
          type: 'input',
          value: '',
          label: 'Confirm Password',
          required: true,
          validators: [
            {
              type: 'custom',
              expression: 'fieldValue === formValue.password',
              kind: 'passwordMismatch',
            },
          ],
          validationMessages: {
            required: 'Please confirm your password',
            passwordMismatch: 'Passwords do not match',
          },
          props: {
            type: 'password',
            appearance: 'outline',
          },
        },
        {
          type: 'next',
          key: 'nextToProfile',
          label: 'Continue to Profile',
          props: { color: 'primary' },
        },
      ],
    },

    // Step 2: Profile Information
    {
      type: 'page',
      key: 'profilePage',
      fields: [
        {
          type: 'row',
          key: 'nameRow',
          fields: [
            {
              key: 'firstName',
              type: 'input',
              value: '',
              label: 'First Name',
              required: true,
              col: 6,
              props: { appearance: 'outline' },
            },
            {
              key: 'lastName',
              type: 'input',
              value: '',
              label: 'Last Name',
              required: true,
              col: 6,
              props: { appearance: 'outline' },
            },
          ],
        },
        {
          key: 'dateOfBirth',
          type: 'datepicker',
          value: null,
          label: 'Date of Birth',
          required: true,
          maxDate: new Date(new Date().getFullYear() - 13, 0, 1),
          validationMessages: {
            required: 'Date of birth is required',
            maxDate: 'You must be at least 13 years old',
          },
          props: {
            appearance: 'outline',
            hint: 'You must be at least 13 years old',
          },
        },
        {
          key: 'accountType',
          type: 'radio',
          value: 'personal',
          label: 'Account Type',
          required: true,
          options: [
            { value: 'personal', label: 'Personal Account' },
            { value: 'business', label: 'Business Account' },
          ],
          props: { color: 'primary' },
        },
        {
          key: 'companyName',
          type: 'input',
          value: '',
          label: 'Company Name',
          logic: [
            {
              type: 'hidden',
              condition: {
                type: 'fieldValue',
                fieldPath: 'accountType',
                operator: 'notEquals',
                value: 'business',
              },
            },
            {
              type: 'required',
              condition: {
                type: 'fieldValue',
                fieldPath: 'accountType',
                operator: 'equals',
                value: 'business',
              },
            },
          ],
          props: { appearance: 'outline' },
        },
        {
          key: 'industry',
          type: 'select',
          value: '',
          label: 'Industry',
          options: [
            { value: 'tech', label: 'Technology' },
            { value: 'finance', label: 'Finance' },
            { value: 'healthcare', label: 'Healthcare' },
            { value: 'retail', label: 'Retail' },
            { value: 'education', label: 'Education' },
            { value: 'other', label: 'Other' },
          ],
          logic: [
            {
              type: 'hidden',
              condition: {
                type: 'fieldValue',
                fieldPath: 'accountType',
                operator: 'notEquals',
                value: 'business',
              },
            },
            {
              type: 'required',
              condition: {
                type: 'fieldValue',
                fieldPath: 'accountType',
                operator: 'equals',
                value: 'business',
              },
            },
          ],
          props: {
            appearance: 'outline',
            placeholder: 'Select your industry',
          },
        },
        {
          type: 'row',
          key: 'navigationRow',
          fields: [
            {
              type: 'previous',
              key: 'backToAccount',
              label: 'Back',
            },
            {
              type: 'next',
              key: 'nextToPreferences',
              label: 'Continue',
              props: { color: 'primary' },
            },
          ],
        },
      ],
    },

    // Step 3: Preferences & Terms
    {
      type: 'page',
      key: 'preferencesPage',
      fields: [
        {
          key: 'interests',
          type: 'multi-checkbox',
          value: [],
          label: 'Interests',
          options: [
            { value: 'tech', label: 'Technology & Innovation' },
            { value: 'business', label: 'Business & Entrepreneurship' },
            { value: 'design', label: 'Design & Creativity' },
            { value: 'marketing', label: 'Marketing & Sales' },
            { value: 'development', label: 'Software Development' },
          ],
          props: { color: 'primary' },
        },
        {
          key: 'newsletter',
          type: 'checkbox',
          value: false,
          label: 'Subscribe to newsletter',
          props: { color: 'primary' },
        },
        {
          key: 'notifications',
          type: 'toggle',
          value: true,
          label: 'Enable email notifications',
          props: { color: 'primary' },
        },
        {
          key: 'terms',
          type: 'checkbox',
          value: false,
          label: 'I accept the terms and conditions',
          required: true,
          validationMessages: {
            required: 'You must accept the terms and conditions',
          },
          props: { color: 'primary' },
        },
        {
          key: 'privacy',
          type: 'checkbox',
          value: false,
          label: 'I have read and accept the privacy policy',
          required: true,
          validationMessages: {
            required: 'You must accept the privacy policy',
          },
          props: { color: 'primary' },
        },
        {
          type: 'row',
          key: 'finalNavigationRow',
          fields: [
            {
              type: 'previous',
              key: 'backToProfile',
              label: 'Back',
            },
            {
              type: 'submit',
              key: 'submitRegistration',
              label: 'Create Account',
              props: { color: 'primary' },
            },
          ],
        },
      ],
    },
  ],
} as const satisfies FormConfig;

@Component({
  selector: 'app-user-registration',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config"></form>`,
})
export class UserRegistrationComponent {
  config = registrationConfig;
}
```

## Key Features

### Multi-Step Form

The form uses page fields to create a wizard-style registration process:

1. **Account Information** - Username, email, password
2. **Profile Information** - Name, DOB, account type
3. **Preferences & Terms** - Interests, notifications, agreements

Navigation buttons (`next`, `previous`, `submit`) control flow between pages.

### Password Validation

Strong password requirements with pattern validation:

```typescript
{
  key: 'password',
  type: 'input',
  value: '',
  required: true,
  minLength: 8,
  pattern: '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$',
  // ...
}
```

Password confirmation with cross-field validation:

```typescript
{
  key: 'confirmPassword',
  validators: [{
    type: 'custom',
    expression: 'fieldValue === formValue.password',
    kind: 'passwordMismatch',
  }],
  validationMessages: {
    passwordMismatch: 'Passwords do not match',
  },
}
```

### Conditional Business Fields

Company name and industry appear only for business accounts:

```typescript
{
  key: 'companyName',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'notEquals',
      value: 'business',
    },
  }, {
    type: 'required',
    condition: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'equals',
      value: 'business',
    },
  }],
}
```

### Age Verification

Uses datepicker `maxDate` to ensure users are at least 13 years old:

```typescript
{
  key: 'dateOfBirth',
  type: 'datepicker',
  maxDate: new Date(new Date().getFullYear() - 13, 0, 1),
  validationMessages: {
    maxDate: 'You must be at least 13 years old',
  },
}
```

### Type Safety

Full type inference for form values:

```typescript
type RegistrationValue = InferFormValue<typeof registrationConfig.fields>;

// TypeScript knows the exact structure:
// {
//   username: string;
//   email: string;
//   password: string;
//   confirmPassword: string;
//   firstName: string;
//   lastName: string;
//   dateOfBirth: Date | null;
//   accountType: string;
//   companyName?: string;      // Conditional
//   industry?: string;          // Conditional
//   interests?: string[];
//   newsletter?: boolean;
//   notifications?: boolean;
//   terms: boolean;
//   privacy: boolean;
// }
```

## Variations

### Single Page Registration

For simpler forms, remove page fields:

```typescript
const simpleRegistrationConfig = {
  fields: [
    { key: 'email', type: 'input', value: '', required: true, email: true },
    { key: 'password', type: 'input', value: '', required: true, minLength: 8 },
    { key: 'terms', type: 'checkbox', value: false, required: true },
    { type: 'submit', key: 'submit', label: 'Sign Up' },
  ],
} as const satisfies FormConfig;
```

### Social Login Integration

Add social login buttons before the form:

```typescript
{
  type: 'row',
  key: 'socialRow',
  fields: [
    { type: 'button', key: 'google', label: 'Sign up with Google', col: 6 },
    { type: 'button', key: 'github', label: 'Sign up with GitHub', col: 6 },
  ],
}
```

## Related

- **[Login Form](../login-form/)** - Simple authentication form
- **[Paginated Form](../paginated-form/)** - Page field navigation patterns
- **[Validation](../../validation/basics/)** - Validation guide
- **[Conditional Logic](../../dynamic-behavior/conditional-logic/overview/)** - Dynamic field behavior
- **[Material Integration](../../ui-libs-integrations/material/)** - Material Design styling

--- examples/value-derivation ---

---
title: Value Derivation
keyword: ValueDerivationExamplePage
---

[← Back to Quick Start](/examples)

This example demonstrates automatic value derivation using expressions. Watch how changing input values automatically updates calculated fields.

## Live Demo

<iframe src="http://localhost:4201/#/examples/value-derivation" class="example-frame" title="Value Derivation Demo"></iframe>

## How It Works

### Numeric Calculations

The order calculator shows chained derivations:

1. **Subtotal** = Quantity × Unit Price
2. **Tax** = Subtotal × Tax Rate / 100
3. **Total** = Subtotal + Tax

When you change any input, all dependent fields update automatically.

### String Concatenation

The name fields demonstrate string derivation:

- **Full Name** = First Name + " " + Last Name

## Key Patterns

### Using the `derivation` Shorthand

The simplest way to create a derived field is with the `derivation` property directly on the target field:

```typescript
{
  key: 'subtotal',
  type: 'input',
  disabled: true,
  derivation: 'formValue.quantity * formValue.unitPrice',
}
```

The expression is evaluated whenever its dependencies change. Dependencies are automatically detected from the expression.

### Chained Derivations

Derivations can reference other derived values. The system automatically processes them in the correct order:

```typescript
// subtotal depends on quantity and unitPrice
{ key: 'subtotal', derivation: 'formValue.quantity * formValue.unitPrice' }

// tax depends on subtotal (another derived field)
{ key: 'tax', derivation: 'formValue.subtotal * formValue.taxRate / 100' }

// total depends on both subtotal and tax
{ key: 'total', derivation: 'formValue.subtotal + formValue.tax' }
```

### Derivation Flow

```
quantity ───┐
            ├── subtotal ──┬── tax ──┬── total
unitPrice ──┘              │         │
                           │         │
taxRate ───────────────────┴─────────┘
```

## Related

- **[Value Derivation](../../dynamic-behavior/value-derivation/basics/)** - Core concepts, syntax, array derivations, debugging, and bidirectional patterns

--- installation ---

Get ng-forge dynamic forms up and running in your Angular project.

## Requirements

- **Angular 21+** - ng-forge dynamic forms requires Angular 21 or higher for signal forms support
- **TypeScript 5.6+** - For best type inference results

## Installation

Install the core library and your preferred UI integration:

```bash group="install" name="npm"
npm install @ng-forge/dynamic-forms @ng-forge/dynamic-forms-material
```

```bash group="install" name="yarn"
yarn add @ng-forge/dynamic-forms @ng-forge/dynamic-forms-material
```

```bash group="install" name="pnpm"
pnpm add @ng-forge/dynamic-forms @ng-forge/dynamic-forms-material
```

> This installs the core `@ng-forge/dynamic-forms` package and the Material Design integration. See [UI Framework Options](#ui-framework-options) below for other choices.

## Configure Your App

Add the dynamic form provider to your app configuration:

```typescript name="app.config.ts"
import { ApplicationConfig } from '@angular/core';
import { provideDynamicForm } from '@ng-forge/dynamic-forms';
import { withMaterialFields } from '@ng-forge/dynamic-forms-material';

export const appConfig: ApplicationConfig = {
  providers: [
    provideDynamicForm(...withMaterialFields()),
    // ... other providers
  ],
};
```

The `provideDynamicForm()` function registers field types and validators. The `withMaterialFields()` function provides all Material Design field components.

## Create Your First Form

Create a simple login form to verify everything works:

```typescript name="login.component.ts"
import { Component } from '@angular/core';
import { DynamicForm, type FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-login',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config"></form>`,
})
export class LoginComponent {
  config = {
    fields: [
      {
        key: 'email',
        type: 'input',
        value: '',
        label: 'Email',
        required: true,
        email: true,
      },
      {
        key: 'password',
        type: 'input',
        value: '',
        label: 'Password',
        required: true,
        minLength: 8,
        props: { type: 'password' },
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Sign In',
        props: { color: 'primary' },
      },
    ],
  } as const satisfies FormConfig;
}
```

You now have a working form with:

- ✅ Real-time validation with error messages
- ✅ TypeScript type inference
- ✅ Material Design styling
- ✅ Accessibility support
- ✅ Submit button auto-disables when invalid

## UI Framework Options

ng-forge dynamic forms supports multiple UI frameworks. Install the integration package for your preferred framework:

### Material Design (Preview)

```bash group="install-material" name="npm"
npm install @ng-forge/dynamic-forms-material
```

```bash group="install-material" name="yarn"
yarn add @ng-forge/dynamic-forms-material
```

```bash group="install-material" name="pnpm"
pnpm add @ng-forge/dynamic-forms-material
```

```typescript
import { withMaterialFields } from '@ng-forge/dynamic-forms-material';

export const appConfig: ApplicationConfig = {
  providers: [provideDynamicForm(...withMaterialFields())],
};
```

See [Material Integration](../ui-libs-integrations/material) for full documentation.

### PrimeNG (Preview)

```bash group="install-primeng" name="npm"
npm install @ng-forge/dynamic-forms-primeng
```

```bash group="install-primeng" name="yarn"
yarn add @ng-forge/dynamic-forms-primeng
```

```bash group="install-primeng" name="pnpm"
pnpm add @ng-forge/dynamic-forms-primeng
```

```typescript
import { withPrimeNGFields } from '@ng-forge/dynamic-forms-primeng';

export const appConfig: ApplicationConfig = {
  providers: [provideDynamicForm(...withPrimeNGFields())],
};
```

See [PrimeNG Integration](../ui-libs-integrations/primeng) for full documentation.

### Bootstrap (Preview)

```bash group="install-bootstrap" name="npm"
npm install @ng-forge/dynamic-forms-bootstrap
```

```bash group="install-bootstrap" name="yarn"
yarn add @ng-forge/dynamic-forms-bootstrap
```

```bash group="install-bootstrap" name="pnpm"
pnpm add @ng-forge/dynamic-forms-bootstrap
```

```typescript
import { withBootstrapFields } from '@ng-forge/dynamic-forms-bootstrap';

export const appConfig: ApplicationConfig = {
  providers: [provideDynamicForm(...withBootstrapFields())],
};
```

See [Bootstrap Integration](../ui-libs-integrations/bootstrap) for full documentation.

### Ionic (Preview)

```bash group="install-ionic" name="npm"
npm install @ng-forge/dynamic-forms-ionic
```

```bash group="install-ionic" name="yarn"
yarn add @ng-forge/dynamic-forms-ionic
```

```bash group="install-ionic" name="pnpm"
pnpm add @ng-forge/dynamic-forms-ionic
```

```typescript
import { withIonicFields } from '@ng-forge/dynamic-forms-ionic';

export const appConfig: ApplicationConfig = {
  providers: [provideDynamicForm(...withIonicFields())],
};
```

See [Ionic Integration](../ui-libs-integrations/ionic) for full documentation.

### Custom UI Components

You can also build your own field components using any UI library or custom styling:

```typescript
import { MyCustomInputComponent } from './my-custom-input.component';

export const appConfig: ApplicationConfig = {
  providers: [
    provideDynamicForm([
      { name: 'input', loadComponent: () => MyCustomInputComponent },
      // ... more custom field types
    ]),
  ],
};
```

See [Custom Integration Guide](../advanced/custom-integrations) for building custom field components.

## Next Steps

Now that you have ng-forge dynamic forms installed, explore the core features:

### Learn Core Concepts

- **[Field Types](../schema-fields/field-types)** - Understand all available field types (input, select, checkbox, group, etc.)
- **[Validation](../validation/basics)** - Add validation rules with shorthand syntax or conditional validators
- **[Conditional Logic](../dynamic-behavior/conditional-logic/overview)** - Show/hide fields based on other field values
- **[Type Safety](../advanced/type-safety/basics)** - TypeScript type inference for forms

### Build Advanced Forms

- **[Multi-Step Forms](../prebuilt/form-pages)** - Create wizard-style forms with page navigation
- **[Repeatable Sections](../prebuilt/form-arrays/simplified)** - Dynamic form arrays for adding/removing fields
- **[Conditional Validation](../validation/advanced#conditional-validators)** - Validators that activate based on conditions

### Customize and Extend

- **[i18n Setup](../dynamic-behavior/i18n)** - Add multi-language support to your forms
- **[Events](../advanced/events)** - Handle custom form events
- **[Custom Fields](../advanced/custom-integrations)** - Create your own field types

## Get Help

- 💬 **[GitHub Discussions](https://github.com/ng-forge/ng-forge/discussions)** - Ask questions and get help
- 🐛 **[Issue Tracker](https://github.com/ng-forge/ng-forge/issues)** - Report bugs
- 📖 **[Documentation](../)** - Browse full documentation

--- prebuilt/form-arrays/complete ---

Arrays create dynamic collections of field values. Each item in the `fields` array defines **one array item** with its structure and initial values.

> For most use cases, the **simplified array API** is recommended. See [Form Arrays (Simplified)](/prebuilt/form-arrays/simplified) for details. This page documents the complete API for advanced use cases.

## Interactive Demo

<iframe src="http://localhost:4201/#/examples/array" class="example-frame" title="Array Field Demo"></iframe>

## Structure Overview

The `fields` property supports two item formats:

- **Single FieldDef** (not wrapped in array) → **Primitive item** - extracts field value directly
- **Array of FieldDefs** → **Object item** - merges fields into an object

```typescript
// Primitive array: ['angular', 'typescript']
{
  key: 'tags',
  type: 'array',
  fields: [
    { key: 'tag', type: 'input', value: 'angular' },      // Single field = primitive
    { key: 'tag', type: 'input', value: 'typescript' },
  ]
}

// Object array: [{ name: 'Alice', email: '...' }]
{
  key: 'contacts',
  type: 'array',
  fields: [
    [                                                      // Array of fields = object
      { key: 'name', type: 'input', label: 'Name', value: 'Alice' },
      { key: 'email', type: 'input', label: 'Email', value: 'alice@example.com' }
    ],
  ]
}
```

## Empty Arrays (No Initial Items)

For arrays that start empty and are populated via buttons:

```typescript
{
  key: 'tags',
  type: 'array',
  fields: []  // No initial items - user adds via button
}
```

## Array Size Validation

Use `minLength` and `maxLength` on the array field to constrain the number of items. When violated, the form becomes invalid (e.g. submit button is disabled), but no field-level error message is shown.

```typescript
{
  key: 'tags',
  type: 'array',
  minLength: 1,  // At least 1 item required
  maxLength: 5,  // No more than 5 items
  fields: [
    [{ key: 'tag', type: 'input', label: 'Tag', value: 'default' }]
  ]
}
```

| Property    | Type     | Description                   |
| ----------- | -------- | ----------------------------- |
| `minLength` | `number` | Minimum number of array items |
| `maxLength` | `number` | Maximum number of array items |

Both properties are optional and can be used independently or together.

## Initial Values

Initial values are defined directly on each field via the `value` property - no separate `initialValue` is needed:

```typescript
{
  key: 'emails',
  type: 'array',
  fields: [
    // One initial item with pre-filled value (object item)
    [
      { key: 'email', type: 'input', label: 'Email', value: 'primary@example.com' }
    ]
  ]
}
```

## Primitive Arrays (Simple Value Lists)

For simple arrays of primitive values like `['tag1', 'tag2']`, use a **single FieldDef per item** (not wrapped in an array):

```typescript
{
  key: 'tags',
  type: 'array',
  fields: [
    { key: 'tag', type: 'input', label: 'Tag', value: 'featured' },
    { key: 'tag', type: 'input', label: 'Tag', value: 'popular' }
  ]
}
```

This creates a true primitive array in the form value:

```typescript
{
  tags: ['featured', 'popular'];
}
```

The `key` property on each field is used for internal tracking but doesn't affect the output value.

## Object Arrays (Multiple Fields per Item)

For arrays of objects with multiple fields, wrap the fields in an **inner array**:

```typescript
{
  key: 'contacts',
  type: 'array',
  fields: [
    [
      { key: 'name', type: 'input', label: 'Name', value: '' },
      { key: 'phone', type: 'input', label: 'Phone', value: '' }
    ]
  ]
}
```

This creates an array of objects:

```typescript
{
  contacts: [{ name: '', phone: '' }];
}
```

## Nested Object Arrays (Using Groups)

For arrays with nested object structure, use a group field:

```typescript
{
  key: 'contacts',
  type: 'array',
  fields: [
    [
      {
        key: 'contact',
        type: 'group',
        fields: [
          { key: 'name', type: 'input', label: 'Name', value: '' },
          { key: 'phone', type: 'input', label: 'Phone', value: '' }
        ]
      }
    ]
  ]
}
```

This creates an array of nested objects (note the group key creates the nesting):

```typescript
{
  contacts: [{ contact: { name: '', phone: '' } }];
}
```

## Heterogeneous Arrays (Mixed Primitives and Objects)

Arrays can contain both primitive and object items in the same array:

```typescript
{
  key: 'items',
  type: 'array',
  fields: [
    [{ key: 'label', type: 'input', value: 'Structured' }],  // Object item (wrapped in array)
    { key: 'value', type: 'input', value: 'Simple' },        // Primitive item (single field)
  ]
}
```

This creates a heterogeneous array:

```typescript
{
  items: [{ label: 'Structured' }, 'Simple'];
}
```

## Array vs Group

- **Groups** create nested objects with keys: `{ address: { street: '', city: '' } }`
- **Primitive Arrays** create lists of values: `{ tags: ['value1', 'value2'] }`
- **Object Arrays** create lists of objects: `{ items: [{name: ''}, {name: ''}] }`

## Dynamic Add/Remove

### Declarative Approach (Recommended)

Use button field types directly in your form configuration for declarative array manipulation:

| Button Type        | Placement        | Description                                      |
| ------------------ | ---------------- | ------------------------------------------------ |
| `addArrayItem`     | Outside array    | Appends a new item to the end of the array       |
| `prependArrayItem` | Outside array    | Inserts a new item at the beginning of the array |
| `insertArrayItem`  | Outside array    | Inserts a new item at a specific index           |
| `removeArrayItem`  | Inside each item | Removes the current item from the array          |
| `popArrayItem`     | Outside array    | Removes the last item from the array             |
| `shiftArrayItem`   | Outside array    | Removes the first item from the array            |

**Important:** Add/prepend/insert buttons **require** a `template` property defining the new item structure. There is no fallback to the array's `fields[0]` - each button must explicitly define what structure to add.

The `template` can be:

- **Single FieldDef** - creates a primitive item (field value is extracted directly)
- **Array of FieldDefs** - creates an object item (fields merged into object)

```typescript
// Template for PRIMITIVE items (single field, not wrapped)
const tagTemplate = { key: 'tag', type: 'input', label: 'Tag' };

// Template for OBJECT items (array of fields)
const contactTemplate = [
  { key: 'name', type: 'input', label: 'Name' },
  { key: 'phone', type: 'input', label: 'Phone' },
  // Remove button inside each item (no template needed)
  { key: 'remove', type: 'removeArrayItem', label: 'Remove' },
];

// Form configuration
{
  fields: [
    {
      key: 'tags',
      type: 'array',
      fields: [], // Start empty - primitive array
    },
    // Add button for primitive items
    {
      key: 'addTag',
      type: 'addArrayItem',
      label: 'Add Tag',
      arrayKey: 'tags',
      template: tagTemplate, // Single field = primitive item
    },
    {
      key: 'contacts',
      type: 'array',
      fields: [], // Start empty - object array
    },
    // Add button for object items
    {
      key: 'addContact',
      type: 'addArrayItem',
      label: 'Add Contact',
      arrayKey: 'contacts',
      template: contactTemplate, // Array of fields = object item
    },
  ];
}
```

### Programmatic Approach

For more control, use the `arrayEvent` builder to dispatch array operations directly. **Note:** When using the programmatic approach, you must provide a template.

**Which API to use depends on where your code lives:**

- **Inside a custom field component** → inject `EventBus` (it is scoped to the form's DI tree)
- **From a host/parent component** → provide and inject `EventDispatcher` (see [Events](/advanced/events))

**From a host component (most common case):**

```typescript
import { Component, inject, signal } from '@angular/core';
import { DynamicForm, EventDispatcher, arrayEvent } from '@ng-forge/dynamic-forms';

@Component({
  providers: [EventDispatcher],
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" [(value)]="formValue"></form>`,
})
export class MyFormComponent {
  readonly formValue = signal<Record<string, unknown>>({});
  private readonly dispatcher = inject(EventDispatcher);

  // Template for PRIMITIVE items (single field, not wrapped)
  tagTemplate = { key: 'tag', type: 'input', label: 'Tag', value: '' };

  // Template for OBJECT items (array of fields)
  contactTemplate = [
    { key: 'name', type: 'input', label: 'Name', value: '' },
    { key: 'phone', type: 'input', label: 'Phone', value: '' },
  ];

  addTag() {
    this.dispatcher.dispatch(arrayEvent('tags').append(this.tagTemplate));
  }

  addContact() {
    this.dispatcher.dispatch(arrayEvent('contacts').append(this.contactTemplate));
  }

  prependItem() {
    this.dispatcher.dispatch(arrayEvent('contacts').prepend(this.contactTemplate));
  }

  addItemAt(index: number) {
    this.dispatcher.dispatch(arrayEvent('contacts').insertAt(index, this.contactTemplate));
  }

  removeLastItem() {
    this.dispatcher.dispatch(arrayEvent('contacts').pop());
  }

  removeFirstItem() {
    this.dispatcher.dispatch(arrayEvent('contacts').shift());
  }

  removeItemAt(index: number) {
    this.dispatcher.dispatch(arrayEvent('contacts').removeAt(index));
  }
}
```

**From inside a custom field component:**

```typescript
import { inject } from '@angular/core';
import { EventBus, arrayEvent } from '@ng-forge/dynamic-forms';

export class MyFieldComponent {
  private readonly eventBus = inject(EventBus);

  addItem() {
    this.eventBus.dispatch(arrayEvent('contacts').append(this.contactTemplate));
  }
}
```

## Use Cases

Arrays are ideal for:

- Lists of simple values (tags, categories, keywords)
- Repeating form sections (multiple addresses, phone numbers)
- Dynamic collections where items can be added/removed
- Collection-based data structures where order matters

## Complete Example: Primitive Array with Initial Values

Here's a complete working example of a primitive array field (simple value list) with initial values and declarative add/remove buttons:

```typescript
import { FormConfig } from '@ng-forge/dynamic-forms';

// Template for new tags - a row with an input and a remove button
const tagTemplate = {
  key: 'tag',
  type: 'row',
  fields: [
    {
      key: 'value',
      type: 'input',
      label: 'Tag',
      required: true,
      minLength: 2,
    },
    {
      key: 'removeTag',
      type: 'removeArrayItem',
      label: 'Remove',
      props: { color: 'warn' },
    },
  ],
} as const;

const formConfig = {
  fields: [
    {
      key: 'tags',
      type: 'array',
      // Start with two initial tags using the same row structure
      fields: [
        [
          {
            key: 'tag',
            type: 'row',
            fields: [
              { key: 'value', type: 'input', label: 'Tag', value: 'featured', required: true, minLength: 2 },
              { key: 'removeTag', type: 'removeArrayItem', label: 'Remove', props: { color: 'warn' } },
            ],
          },
        ],
        [
          {
            key: 'tag',
            type: 'row',
            fields: [
              { key: 'value', type: 'input', label: 'Tag', value: 'popular', required: true, minLength: 2 },
              { key: 'removeTag', type: 'removeArrayItem', label: 'Remove', props: { color: 'warn' } },
            ],
          },
        ],
      ],
    },
    // Declarative add button - no EventBus needed
    {
      key: 'addTag',
      type: 'addArrayItem',
      label: 'Add Tag',
      arrayKey: 'tags',
      template: [tagTemplate],
      props: { color: 'primary' },
    },
  ],
} as const satisfies FormConfig;

// Form value: { tags: [{ tag: { value: 'featured' } }, { tag: { value: 'popular' } }] }
```

## Complete Example: Object Array with Initial Values

Here's a complete working example of an object array field with initial values, validation, and declarative buttons:

```typescript
import { FormConfig } from '@ng-forge/dynamic-forms';

// Template for new contacts - includes a remove button inside each item
const contactTemplate = [
  { key: 'name', type: 'input', label: 'Contact Name', required: true, minLength: 2 },
  { key: 'phone', type: 'input', label: 'Phone Number', required: true, pattern: /^\d{10}$/ },
  {
    key: 'relationship',
    type: 'select',
    label: 'Relationship',
    options: [
      { label: 'Family', value: 'family' },
      { label: 'Friend', value: 'friend' },
      { label: 'Colleague', value: 'colleague' },
    ],
  },
  {
    key: 'removeContact',
    type: 'removeArrayItem',
    label: 'Remove Contact',
    props: { color: 'warn' },
  },
] as const;

const formConfig = {
  fields: [
    {
      key: 'contacts',
      type: 'array',
      // Start with one pre-filled contact (includes remove button)
      fields: [
        [
          { key: 'name', type: 'input', label: 'Contact Name', value: 'John Doe', required: true, minLength: 2 },
          {
            key: 'phone',
            type: 'input',
            label: 'Phone Number',
            value: '5551234567',
            required: true,
            pattern: /^\d{10}$/,
          },
          {
            key: 'relationship',
            type: 'select',
            label: 'Relationship',
            value: 'family',
            options: [
              { label: 'Family', value: 'family' },
              { label: 'Friend', value: 'friend' },
              { label: 'Colleague', value: 'colleague' },
            ],
          },
          {
            key: 'removeContact',
            type: 'removeArrayItem',
            label: 'Remove Contact',
            props: { color: 'warn' },
          },
        ],
      ],
    },
    // Declarative add button - no EventBus needed
    {
      key: 'addContact',
      type: 'addArrayItem',
      label: 'Add Contact',
      arrayKey: 'contacts',
      template: contactTemplate,
      props: { color: 'primary' },
    },
  ],
} as const satisfies FormConfig;

// Form value: { contacts: [{ name: 'John Doe', phone: '5551234567', relationship: 'family' }] }
```

## Template Requirement

**Important:** When adding items dynamically (via buttons or event bus), you must always provide an explicit `template`. There is no automatic fallback to use the first item's structure.

This design ensures:

- Clear intent - each add operation explicitly defines what to add
- Flexibility - different buttons can add different item structures
- No ambiguity - the array's `fields` only defines initial items, not a "default template"

## Heterogeneous Items

Arrays can have items with different field structures:

```typescript
{
  key: 'entries',
  type: 'array',
  fields: [
    // Item 0: Simple tag
    [{ key: 'tag', type: 'input', label: 'Tag', value: 'simple' }],
    // Item 1: Contact with more fields
    [
      { key: 'name', type: 'input', label: 'Name', value: 'Alice' },
      { key: 'email', type: 'input', label: 'Email', value: 'alice@example.com' }
    ]
  ]
}
```

This flexibility allows each item to have its own structure, though typically all items share the same structure for consistency.

## Nesting Constraints

Array fields can be used within:

- Pages (top-level container)
- Rows (for horizontal layouts)
- Groups (for nested arrays within objects)

Arrays **cannot** contain:

- Other array fields (no nested arrays)
- Page fields

## Allowed Children

Arrays can contain these field types:

- Leaf fields (input, select, checkbox, etc.) -> creates flat or object arrays
- Group fields with key -> creates nested object arrays `[{groupKey: {...}}, ...]`
- Row fields -> creates flat object arrays `[{...}, {...}]` (rows don't add nesting)
- Button fields (for remove operations inside each item)

See [Type Safety & Inference](../advanced/type-safety/basics) for details on how arrays affect type inference.

## Conditional Visibility

Array containers support the `logic` property to conditionally show or hide the entire array section based on form state.

```typescript
{
  key: 'dependents',
  type: 'array',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'hasDependents',
      operator: 'equals',
      value: false,
    },
  }],
  fields: [/* ... */],
}
```

When the array is hidden, all items and add/remove buttons are hidden with it. Only `'hidden'` is supported as a logic type on containers.

For all available condition types and operators, see [Conditional Logic](../../../dynamic-behavior/conditional-logic/overview/).

## When to Use the Complete API

The complete API documented on this page is the right choice when you need capabilities beyond what the simplified API offers:

- **Heterogeneous items** -- Different field structures per item (e.g. some items have 2 fields, others have 5)
- **Custom button placement** -- Positioning add/remove/prepend/insert buttons in specific locations relative to the array
- **Programmatic control via EventBus** -- Dispatching `arrayEvent` commands for append, prepend, insertAt, pop, shift, and removeAt operations from component code
- **Custom templates per button action** -- Different add buttons that each insert a different item structure (e.g. an "Add Simple" and an "Add Detailed" button)
- **Mixed primitive and object items** -- Arrays containing both primitive values and object values in the same collection

For all other scenarios, the [simplified array API](/prebuilt/form-arrays/simplified) provides a more concise configuration with auto-generated buttons.

--- prebuilt/form-arrays/simplified ---

The simplified array API provides a concise way to define dynamic arrays. Instead of manually specifying each item in `fields`, you provide a `template` for the item structure and a `value` array with initial data. Add and remove buttons are generated automatically.

> **When should I use this?** For most array use cases -- primitive lists, object lists, and standard add/remove workflows -- the simplified API is the right choice. For advanced scenarios like heterogeneous items or custom button placement, see [Form Arrays (Complete)](/prebuilt/form-arrays/complete).

## Interactive Demo

<iframe src="http://localhost:4201/#/examples/simplified-array" class="example-frame" title="Simplified Array Demo"></iframe>

## Overview

The simplified API uses two key properties:

| Property    | Description                                                                |
| ----------- | -------------------------------------------------------------------------- |
| `template`  | Defines the structure of a single array item (single field or field array) |
| `value`     | Initial data array -- each element creates one pre-filled item             |
| `minLength` | Minimum number of array items (form invalid if fewer)                      |
| `maxLength` | Maximum number of array items (form invalid if more)                       |

The `template` shape determines the array variant:

- **Single field** (`template: { ... }`) -- primitive array (e.g. `['tag1', 'tag2']`)
- **Array of fields** (`template: [{ ... }, { ... }]`) -- object array (e.g. `[{ name: 'Jane', phone: '555' }]`)

```typescript
// Discriminant: template is a single field → primitive array
{ key: 'tags', type: 'array', template: { key: 'value', type: 'input', label: 'Tag' } }

// Discriminant: template is an array of fields → object array
{ key: 'contacts', type: 'array', template: [
  { key: 'name', type: 'input', label: 'Name' },
  { key: 'phone', type: 'input', label: 'Phone' },
] }
```

## Primitive Arrays

For simple arrays of scalar values like `['angular', 'typescript']`, provide a single field as the `template` and a flat array as the `value`:

```typescript
{
  key: 'tags',
  type: 'array',
  template: { key: 'value', type: 'input', label: 'Tag', required: true },
  value: ['angular', 'typescript'],
}
```

This renders two input fields pre-filled with `'angular'` and `'typescript'`, each with an auto-generated **Remove** button. An **Add** button is placed after the array.

Form value output:

```typescript
{
  tags: ['angular', 'typescript'];
}
```

## Object Arrays

For arrays of objects like `[{ name: 'Jane', phone: '555' }]`, provide an array of fields as the `template` and an array of objects as the `value`:

```typescript
{
  key: 'contacts',
  type: 'array',
  template: [
    { key: 'name', type: 'input', label: 'Contact Name', required: true },
    { key: 'phone', type: 'input', label: 'Phone Number' },
  ],
  value: [
    { name: 'Jane', phone: '555-1234' },
    { name: 'Bob', phone: '555-5678' },
  ],
}
```

Each value object is matched to the template by key. If a value object omits a key, the corresponding field renders without an initial value.

Form value output:

```typescript
{
  contacts: [
    { name: 'Jane', phone: '555-1234' },
    { name: 'Bob', phone: '555-5678' },
  ];
}
```

## Empty Arrays

Omit `value` or set `value: []` to start with an empty array. Users populate it via the auto-generated **Add** button:

```typescript
// No value property — starts empty
{
  key: 'tags',
  type: 'array',
  template: { key: 'value', type: 'input', label: 'Tag' },
}

// Explicit empty array — same behavior
{
  key: 'emails',
  type: 'array',
  template: [
    { key: 'address', type: 'input', label: 'Email Address', required: true },
    { key: 'label', type: 'select', label: 'Type', options: [
      { label: 'Work', value: 'work' },
      { label: 'Personal', value: 'personal' },
    ] },
  ],
  value: [],
}
```

## Button Customization

By default, the library generates an **Add** button (label: `"Add"`) after the array and a **Remove** button (label: `"Remove"`) inside each item. You can customize both via `addButton` and `removeButton`:

```typescript
{
  key: 'tags',
  type: 'array',
  template: { key: 'value', type: 'input', label: 'Tag' },
  value: ['angular'],
  addButton: { label: 'Add Tag', props: { color: 'primary' } },
  removeButton: { label: 'Delete', props: { color: 'warn' } },
}
```

### Button Config Properties

| Property | Type                      | Description                                          |
| -------- | ------------------------- | ---------------------------------------------------- |
| `label`  | `string`                  | Custom label text for the button                     |
| `props`  | `Record<string, unknown>` | Additional properties passed to the button component |

## Button Opt-Out

Set `addButton: false` or `removeButton: false` to suppress the corresponding auto-generated button entirely:

```typescript
// No add button — items are only removable, not addable
{
  key: 'defaultTags',
  type: 'array',
  template: { key: 'value', type: 'input', label: 'Tag' },
  value: ['featured', 'popular'],
  addButton: false,
}

// No remove button — items are only addable, not removable
{
  key: 'skills',
  type: 'array',
  template: { key: 'value', type: 'input', label: 'Skill' },
  value: ['TypeScript'],
  removeButton: false,
}

// No buttons at all — static list rendered from initial values
{
  key: 'readonlyItems',
  type: 'array',
  template: { key: 'value', type: 'input', label: 'Item' },
  value: ['A', 'B', 'C'],
  addButton: false,
  removeButton: false,
}
```

When `removeButton: false` is set for a primitive array, each item renders as a plain field without being wrapped in a row. When set for an object array, the remove button is simply omitted from the item's field list.

## Complete Example: Primitive Array

A full working configuration for a tag list with custom buttons:

```typescript
import { FormConfig } from '@ng-forge/dynamic-forms';

const formConfig: FormConfig = {
  fields: [
    {
      key: 'projectName',
      type: 'input',
      label: 'Project Name',
      required: true,
    },
    {
      key: 'tags',
      type: 'array',
      template: { key: 'value', type: 'input', label: 'Tag', required: true, minLength: 2 },
      value: ['angular', 'open-source'],
      addButton: { label: 'Add Tag' },
      removeButton: { label: 'Remove Tag' },
    },
  ],
};

// Form value:
// {
//   projectName: 'My Project',
//   tags: ['angular', 'open-source']
// }
```

## Complete Example: Object Array

A full working configuration for a contact list:

```typescript
import { FormConfig } from '@ng-forge/dynamic-forms';

const formConfig: FormConfig = {
  fields: [
    {
      key: 'teamName',
      type: 'input',
      label: 'Team Name',
      required: true,
    },
    {
      key: 'members',
      type: 'array',
      template: [
        { key: 'name', type: 'input', label: 'Full Name', required: true },
        { key: 'email', type: 'input', label: 'Email', required: true },
        {
          key: 'role',
          type: 'select',
          label: 'Role',
          options: [
            { label: 'Developer', value: 'dev' },
            { label: 'Designer', value: 'design' },
            { label: 'Manager', value: 'manager' },
          ],
        },
      ],
      value: [
        { name: 'Alice', email: 'alice@example.com', role: 'dev' },
        { name: 'Bob', email: 'bob@example.com', role: 'design' },
      ],
      addButton: { label: 'Add Member' },
      removeButton: { label: 'Remove' },
    },
  ],
};

// Form value:
// {
//   teamName: 'Frontend Team',
//   members: [
//     { name: 'Alice', email: 'alice@example.com', role: 'dev' },
//     { name: 'Bob', email: 'bob@example.com', role: 'design' },
//   ]
// }
```

## Form Value Output

The simplified API produces the same form values as the complete API:

| Template Shape  | Value Shape           | Output                                           |
| --------------- | --------------------- | ------------------------------------------------ |
| Single field    | Flat array of scalars | `{ tags: ['angular', 'typescript'] }`            |
| Array of fields | Array of objects      | `{ contacts: [{ name: 'Jane', phone: '555' }] }` |
| Any template    | `[]` or omitted       | `{ items: [] }`                                  |

## Array Size Validation

Use `minLength` and `maxLength` to constrain the number of items. When violated, the form becomes invalid (e.g. submit button is disabled).

```typescript
{
  key: 'tags',
  type: 'array',
  template: { key: 'value', type: 'input', label: 'Tag' },
  value: ['angular'],
  minLength: 1,
  maxLength: 5,
}
```

Both properties are optional and can be used independently or together.

## Conditional Visibility

Simplified arrays support `logic` for conditional visibility, just like the complete API:

```typescript
{
  key: 'extras',
  type: 'array',
  template: { key: 'value', type: 'input', label: 'Extra' },
  value: [],
  logic: [{ type: 'hidden', condition: { type: 'fieldValue', fieldPath: 'showExtras', operator: 'equals', value: false } }],
}
```

## Decision Guide: Simplified vs Complete API

| Scenario                                        | Recommended API |
| ----------------------------------------------- | --------------- |
| Uniform items with standard add/remove          | **Simplified**  |
| Pre-filled values from a data source            | **Simplified**  |
| Custom button labels or styling                 | **Simplified**  |
| Empty array populated by users                  | **Simplified**  |
| Static list (no add/remove buttons)             | **Simplified**  |
| Heterogeneous items (different fields per item) | Complete        |
| Custom button placement (buttons outside array) | Complete        |
| Programmatic control via EventDispatcher        | Complete        |
| Multiple add buttons (append, prepend, insert)  | Complete        |
| Nested arrays inside item templates             | Complete        |

As a rule of thumb: **start with the simplified API**. If you hit a limitation, switch to the [complete API](/prebuilt/form-arrays/complete).

--- prebuilt/form-groups ---

Groups nest form fields under a single key in the form value. This creates logical grouping for form data, not visual grouping.

## Interactive Demo

<iframe src="http://localhost:4201/#/examples/group" class="example-frame" title="Group Field Demo"></iframe>

## Basic Group

```typescript
{
  type: 'group',
  key: 'address',
  fields: [
    { key: 'street', type: 'input', label: 'Street', value: '' },
    { key: 'city', type: 'input', label: 'City', value: '' },
    { key: 'zip', type: 'input', label: 'ZIP', value: '' },
  ],
}
```

This creates a nested structure in the form value:

```typescript
{
  address: {
    street: '',
    city: '',
    zip: ''
  }
}
```

Groups are for organizing form **data**, not UI. The visual presentation depends on your UI integration (Material, Bootstrap, etc.).

## Complete Example

Here's a complete working example of a group field with validation:

```typescript
import { Component } from '@angular/core';
import { DynamicForm } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-user-profile-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="formConfig"></form>`,
})
export class UserProfileFormComponent {
  formConfig = {
    fields: [
      {
        key: 'name',
        type: 'input',
        label: 'Full Name',
        value: '',
        required: true,
      },
      {
        key: 'address',
        type: 'group',
        fields: [
          {
            key: 'street',
            type: 'input',
            label: 'Street Address',
            value: '',
            required: true,
          },
          {
            key: 'city',
            type: 'input',
            label: 'City',
            value: '',
            required: true,
          },
          {
            key: 'state',
            type: 'input',
            label: 'State',
            value: '',
            required: true,
            maxLength: 2,
          },
          {
            key: 'zip',
            type: 'input',
            label: 'ZIP Code',
            value: '',
            required: true,
            pattern: /^\d{5}$/,
          },
        ],
      },
    ],
  };
}
```

This produces a form value with nested structure:

```typescript
{
  name: 'John Doe',
  address: {
    street: '123 Main St',
    city: 'Springfield',
    state: 'IL',
    zip: '62701'
  }
}
```

## Nesting Restrictions

Group fields can be used within:

- Pages (top-level container)
- Rows (for horizontal layouts)
- Array fields (for creating object arrays where each array item is an object)

Groups **cannot** be nested inside:

- Other group fields (no nested groups)

## Allowed Children

Groups can contain:

- Leaf fields (input, select, checkbox, etc.)
- Row fields (for horizontal layouts within the group)

See [Type Safety & Inference](../advanced/type-safety/basics) for details on how groups affect type inference.

## Conditional Visibility

Group containers support the `logic` property to conditionally show or hide the entire group (and all its nested fields) based on form state.

```typescript
{
  key: 'addressGroup',
  type: 'group',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'sameAsBilling',
      operator: 'equals',
      value: true,
    },
  }],
  fields: [
    { key: 'street', type: 'input', label: 'Street', value: '' },
    { key: 'city', type: 'input', label: 'City', value: '' },
    { key: 'zip', type: 'input', label: 'ZIP', value: '' },
  ],
}
```

When the group is hidden, all its nested fields are hidden with it. Only `'hidden'` is supported as a logic type on containers (not `required`, `readonly`, or `disabled`).

For all available condition types and operators, see [Conditional Logic](../../dynamic-behavior/conditional-logic/overview/).

--- prebuilt/form-pages ---

Create multi-step forms by using page fields. When your form contains page fields, it automatically enters "paged mode" and renders with navigation controls.

## Basic Multi-Step Form

Create a multi-step form by adding multiple page fields to your form configuration:

```typescript
{
  fields: [
    {
      key: 'account',
      type: 'page',
      fields: [
        { key: 'accountTitle', type: 'text', label: 'Account Information', props: { elementType: 'h3' } },
        { key: 'username', type: 'input', label: 'Username', value: '', required: true },
        { key: 'password', type: 'input', label: 'Password', value: '', props: { type: 'password' }, required: true },
      ],
    },
    {
      key: 'profile',
      type: 'page',
      fields: [
        { key: 'profileTitle', type: 'text', label: 'Profile Details', props: { elementType: 'h3' } },
        { key: 'firstName', type: 'input', label: 'First Name', value: '' },
        { key: 'lastName', type: 'input', label: 'Last Name', value: '' },
      ],
    },
  ],
}
```

## Page Properties

Each page field supports:

- `key` (required) - Unique identifier for the page
- `type: 'page'` (required) - Field type identifier
- `fields` (required) - Array of child fields to render on this page

## Page with Description

```typescript
{
  key: 'preferences',
  type: 'page',
  fields: [
    { key: 'newsletter', type: 'checkbox', label: 'Subscribe to newsletter', value: false },
    { key: 'notifications', type: 'checkbox', label: 'Enable notifications', value: false },
  ],
}
```

## Paged Mode Behavior

When your form contains page fields:

- **Automatic Detection**: Form automatically enters "paged mode"
- **Navigation Controls**: Previous/Next buttons are rendered automatically
- **Validation**: Users must complete required fields before advancing to the next page
- **Single Page View**: Only one page is visible at a time

## Performance & Lazy Loading

ng-forge uses Angular's `@defer` blocks with smart prefetching to optimize page rendering while maintaining flicker-free navigation.

### How It Works

The page orchestrator uses a **2-tier loading strategy**:

**Tier 1: Current + Adjacent Pages (±1)**

- Render immediately using `@defer (on immediate)`
- Initially, only 3 pages load (current + 2 adjacent)
- Adjacent pages are fully rendered but hidden with `display: none`
- Ensures zero flicker when navigating forward/backward

**Tier 2: Distant Pages (2+ steps away)**

- Defer loading until browser is idle using `@defer (on idle)`
- Lazy loading optimizes initial page load
- Load automatically during browser idle time
- Once loaded, pages remain in DOM (hidden with CSS)

### Benefits

```typescript
// Example: User is on step 2 of 5
fields: [
  { key: 'step1', type: 'page', ... }, // ✓ Rendered (adjacent)
  { key: 'step2', type: 'page', ... }, // ✓ Visible (current)
  { key: 'step3', type: 'page', ... }, // ✓ Rendered (adjacent)
  { key: 'step4', type: 'page', ... }, // ⏳ Deferred (distant)
  { key: 'step5', type: 'page', ... }, // ⏳ Deferred (distant)
]
```

**Performance advantages:**

- ⚡ **Zero navigation flicker** - Adjacent pages already rendered
- 🚀 **Faster initial load** - Only 3 pages render immediately, distant pages defer until idle
- ⏱️ **Better Time to Interactive (TTI)** - Reduced initial JavaScript parsing/compilation
- 📱 **Mobile-friendly** - Lower startup cost on slower devices

**Note:** Once loaded, pages remain in the DOM (hidden with CSS). The primary benefit is optimizing **initial load performance**, not ongoing memory usage.

This optimization happens automatically - no configuration needed.

## Value Structure

Pages are container fields - they don't add nesting to your form values. Fields flatten to the root level:

```typescript
// Form config with pages
{
  fields: [
    {
      key: 'page1',
      type: 'page',
      fields: [
        { key: 'firstName', type: 'input', value: '' },
      ],
    },
    {
      key: 'page2',
      type: 'page',
      fields: [
        { key: 'lastName', type: 'input', value: '' },
      ],
    },
  ],
}

// Resulting form value (flat structure)
{
  firstName: 'John',
  lastName: 'Doe',
  // Note: page keys are NOT in the value
}
```

## Nesting Restrictions

Page fields can only be used at the top level of your form configuration. They **cannot** be nested inside:

- Other page fields
- Row fields
- Group fields

Attempting to nest pages will result in a validation error.

## Allowed Children

Pages can contain:

- Leaf fields (input, select, checkbox, etc.)
- Row fields (for horizontal layouts)
- Group fields (for nested data structures)

## Conditional Visibility

Pages support the `logic` property to conditionally skip a page (hide it from the page navigation and progression) based on form state.

```typescript
{
  key: 'businessDetails',
  type: 'page',
  label: 'Business Details',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'notEquals',
      value: 'business',
    },
  }],
  fields: [
    { key: 'companyName', type: 'input', label: 'Company Name', value: '' },
    { key: 'taxId', type: 'input', label: 'Tax ID', value: '' },
  ],
}
```

When a page is hidden, it is excluded from the multi-step navigation — users skip directly past it. Only `'hidden'` is supported as a logic type on containers.

For all available condition types and operators, see [Conditional Logic](../../dynamic-behavior/conditional-logic/overview/).

## CSS Classes

Page fields use these classes for styling:

- `.df-page` - Applied to the page container
- `.df-page-visible` - Applied to the currently visible page
- `.df-page-hidden` - Applied to hidden pages
- `.df-page-field` - Applied to the page field component

--- prebuilt/form-rows ---

Organize fields into horizontal rows for compact layouts. Rows display fields side-by-side.

## Interactive Demo

<iframe src="http://localhost:4201/#/examples/row" class="example-frame" title="Row Field Demo"></iframe>

## Basic Row

```typescript
{
  type: 'row',
  fields: [
    { key: 'firstName', type: 'input', label: 'First Name', value: '', col: 6 },
    { key: 'lastName', type: 'input', label: 'Last Name', value: '', col: 6 },
  ],
}
```

Rows flatten their children - they don't add nesting to form values. Use the `col` property to control field widths (see Column Sizing below).

## Column Sizing

Control field widths within rows using the `col` property:

```typescript
{
  type: 'row',
  fields: [
    { key: 'city', type: 'input', label: 'City', value: '', col: 6 },
    { key: 'state', type: 'select', label: 'State', value: '', col: 3 },
    { key: 'zip', type: 'input', label: 'ZIP', value: '', col: 3 },
  ],
}
```

The `col` property uses a 12-column grid system (like Bootstrap). In this example:

- `city` takes 6/12 (50%) width
- `state` takes 3/12 (25%) width
- `zip` takes 3/12 (25%) width

## Responsive Behavior

Rows automatically stack on small screens, making forms mobile-friendly without additional configuration.

## Complete Example

Here's a complete working example of a row field with multiple fields:

```typescript
import { Component } from '@angular/core';
import { DynamicForm } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-address-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="formConfig"></form>
    >`,
})
export class AddressFormComponent {
  formConfig = {
    fields: [
      {
        type: 'row',
        fields: [
          {
            key: 'firstName',
            type: 'input',
            label: 'First Name',
            value: '',
            required: true,
            col: 6,
          },
          {
            key: 'lastName',
            type: 'input',
            label: 'Last Name',
            value: '',
            required: true,
            col: 6,
          },
        ],
      },
      {
        key: 'email',
        type: 'input',
        label: 'Email Address',
        value: '',
        required: true,
        email: true,
      },
      {
        type: 'row',
        fields: [
          {
            key: 'city',
            type: 'input',
            label: 'City',
            value: '',
            required: true,
            col: 6,
          },
          {
            key: 'state',
            type: 'input',
            label: 'State',
            value: '',
            required: true,
            maxLength: 2,
            col: 3,
          },
          {
            key: 'zip',
            type: 'input',
            label: 'ZIP',
            value: '',
            required: true,
            pattern: /^\d{5}$/,
            col: 3,
          },
        ],
      },
    ],
  };
}
```

This produces a flat form value (rows don't create nesting):

```typescript
{
  firstName: 'John',
  lastName: 'Doe',
  email: 'john.doe@example.com',
  city: 'Springfield',
  state: 'IL',
  zip: '62701'
}
```

## Value Structure

Rows are layout containers - they don't add nesting to your form values. Fields flatten to the root level:

```typescript
// Form config with rows
{
  fields: [
    {
      type: 'row',
      fields: [
        { key: 'firstName', type: 'input', value: '', col: 6 },
        { key: 'lastName', type: 'input', value: '', col: 6 },
      ],
    },
  ];
}

// Resulting form value (flat structure)
{
  firstName: 'John',
  lastName: 'Doe',
  // Note: row itself is NOT in the value
}
```

## Nesting Restrictions

Row fields can be used within:

- Pages (top-level container)
- Groups (for layouts within grouped data)
- Arrays (for layouts within array items)

Rows **cannot** be nested inside:

- Other row fields

## Allowed Children

Rows can contain:

- Leaf fields (input, select, checkbox, etc.)
- Group fields (for nested data structures within the row)
- Array fields (for repeating sections within the row)

## Conditional Visibility

Row containers support the `logic` property to conditionally show or hide the entire row (and all its fields) based on form state.

```typescript
{
  key: 'contactRow',
  type: 'row',
  logic: [{
    type: 'hidden',
    condition: {
      type: 'fieldValue',
      fieldPath: 'contactPreference',
      operator: 'equals',
      value: 'none',
    },
  }],
  fields: [
    { key: 'phone', type: 'input', label: 'Phone', col: 6 },
    { key: 'email', type: 'input', label: 'Email', col: 6 },
  ],
}
```

Only `'hidden'` is supported as a logic type on containers. For all available condition types and operators, see [Conditional Logic](../../dynamic-behavior/conditional-logic/overview/).

--- prebuilt/hidden-fields ---

Hidden fields store values in the form model without rendering any visible UI. They're useful for persisting IDs, metadata, or other non-user-facing data.

## Basic Usage

```typescript
{
  type: 'hidden',
  key: 'id',
  value: 'uuid-550e8400-e29b-41d4-a716-446655440000',
}
```

This adds `id` to the form value without rendering anything:

```typescript
{
  id: 'uuid-550e8400-e29b-41d4-a716-446655440000',
  // ... other fields
}
```

## Supported Value Types

Hidden fields support scalar values and arrays of scalars:

```typescript
// String
{ type: 'hidden', key: 'sessionId', value: 'abc123' }

// Number
{ type: 'hidden', key: 'version', value: 42 }

// Boolean
{ type: 'hidden', key: 'isActive', value: true }

// String array
{ type: 'hidden', key: 'tags', value: ['draft', 'review'] }

// Number array
{ type: 'hidden', key: 'tagIds', value: [1, 2, 3] }

// Boolean array
{ type: 'hidden', key: 'flags', value: [true, false, true] }
```

## Complete Example

Here's a form that uses hidden fields to persist metadata during an update operation:

```typescript
import { Component } from '@angular/core';
import { DynamicForm } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-edit-user-form',
  imports: [DynamicForm],
  template: `<form [dynamic-form]="formConfig"></form>`,
})
export class EditUserFormComponent {
  formConfig = {
    fields: [
      // Hidden fields for metadata
      {
        type: 'hidden',
        key: 'id',
        value: 'user-123',
      },
      {
        type: 'hidden',
        key: 'version',
        value: 3,
      },
      {
        type: 'hidden',
        key: 'roles',
        value: ['admin', 'editor'],
      },
      // Visible fields
      {
        key: 'name',
        type: 'input',
        label: 'Full Name',
        value: 'John Doe',
        required: true,
      },
      {
        key: 'email',
        type: 'input',
        label: 'Email',
        value: 'john@example.com',
        required: true,
        props: { type: 'email' },
      },
      {
        key: 'submit',
        type: 'submit',
        label: 'Save Changes',
      },
    ],
  };
}
```

Form value on submission:

```typescript
{
  id: 'user-123',
  version: 3,
  roles: ['admin', 'editor'],
  name: 'John Doe',
  email: 'john@example.com'
}
```

## Use Cases

- Persisting record IDs for update operations
- Tracking version numbers for optimistic concurrency
- Passing context data (parent IDs, source references)
- Storing computed values that shouldn't be user-editable
- Including metadata in form submissions

## Placement

Hidden fields can be placed:

- At the top level of a form
- Inside page fields
- Inside group fields

**Note:** Placing hidden fields inside row fields will generate a validation warning. Rows are meant for horizontal layouts, and since hidden fields don't render anything, placing them in rows serves no purpose. Place hidden fields outside of rows instead.

## Type Safety

Hidden fields are fully type-safe:

```typescript
import { HiddenField } from '@ng-forge/dynamic-forms';

// Typed hidden field
const idField: HiddenField<string> = {
  type: 'hidden',
  key: 'id',
  value: 'abc123',
};

// Array type
const tagsField: HiddenField<number[]> = {
  type: 'hidden',
  key: 'tagIds',
  value: [1, 2, 3],
};
```

Use the `isHiddenField` type guard to check field types at runtime:

```typescript
import { isHiddenField } from '@ng-forge/dynamic-forms';

if (isHiddenField(field)) {
  console.log(field.value); // Type-safe access to value
}
```

## Value Exclusion

The `HiddenField` type (`type: 'hidden'`) is **not affected** by value exclusion. Hidden fields:

- Have no reactive `hidden()` state (they don't render a component)
- Are always included in submission output, regardless of `excludeValueIfHidden` settings

This is different from regular fields with `hidden: true` or fields hidden via conditional logic. Those fields have a reactive `hidden()` state that value exclusion checks.

See the **Value Exclusion** page under Recipes for full details.

## Technical Details

- **Componentless**: Hidden fields have no Angular component and render zero DOM elements
- **Value handling**: Uses `valueHandling: 'include'`, so values are always included in form submissions
- **Required value**: The `value` property is required (unlike most field types where it's optional)

--- prebuilt/text-components ---

Display static or dynamic text content in forms. Text fields are **display-only** - they don't collect user input or contribute to form values.

## Basic Text

Display a paragraph of text:

```typescript
{
  key: 'instructions',
  type: 'text',
  label: 'Please review the terms and conditions before proceeding.',
}
```

## HTML Element Types

Render text as different HTML elements:

```typescript
{
  key: 'pageTitle',
  type: 'text',
  label: 'User Registration',
  props: {
    elementType: 'h1',  // Options: 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'span'
  },
}
```

**Options**: `'p'` | `'h1'` | `'h2'` | `'h3'` | `'h4'` | `'h5'` | `'h6'` | `'span'`

## With i18n

Text fields support dynamic content via Observables and Signals:

```typescript
{
  key: 'formInstructions',
  type: 'text',
  label: translationService.translate('form.instructions'),  // Observable<string>
  props: {
    elementType: 'p',
  },
}
```

## Styling with CSS Variables

Customize appearance using CSS custom properties:

```css
/* Global text styling */
:root {
  --df-text-font-size: 1rem;
  --df-text-font-family: inherit;
  --df-text-font-weight: normal;
  --df-text-color: inherit;
  --df-text-line-height: 1.5;
  --df-text-text-align: inherit;
  --df-text-letter-spacing: normal;
  --df-text-text-decoration: none;
  --df-text-text-transform: none;
  --df-text-margin: 0;
  --df-text-padding: 0;
}

/* Element-specific styling */
:root {
  --df-text-h1-font-size: 2rem;
  --df-text-h1-font-weight: bold;
  --df-text-h1-margin: 0;

  --df-text-h2-font-size: 1.75rem;
  --df-text-h2-font-weight: bold;
  --df-text-h2-margin: 0;

  --df-text-h3-font-size: 1.5rem;
  --df-text-h3-font-weight: bold;
  --df-text-h3-margin: 0;

  --df-text-h4-font-size: 1.25rem;
  --df-text-h4-font-weight: bold;
  --df-text-h4-margin: 0;

  --df-text-h5-font-size: 1.125rem;
  --df-text-h5-font-weight: bold;
  --df-text-h5-margin: 0;

  --df-text-h6-font-size: 1rem;
  --df-text-h6-font-weight: bold;
  --df-text-h6-margin: 0;

  --df-text-p-font-size: 1rem;
  --df-text-p-margin: 0;

  --df-text-span-display: inline;
}
```

## CSS Classes

Text fields use these classes for styling:

- `.df-text` - Applied to all text fields
- `.df-text-{elementType}` - Element-specific class (e.g., `.df-text-h1`, `.df-text-p`)

## Custom Classes

Add custom classes via the `className` property:

```typescript
{
  key: 'notice',
  type: 'text',
  label: 'Important Notice',
  className: 'my-custom-class highlight-text',
  props: {
    elementType: 'h2',
  },
}
```

## Use Cases

- Form instructions and help text
- Section headings
- Legal disclaimers
- Status messages
- Informational content between form fields

--- schema-fields/field-types ---

Field types define form control behavior and rendering. Each UI integration (Material, Bootstrap, PrimeNG, Ionic) provides implementations for these core field types.

**Note**: For nested form structures, use [group fields](../field-types#group) instead of dot notation in keys.

## Core Field Types

### input

Text-based input with HTML5 type support.

```typescript
{
  key: 'email',
  type: 'input',
  value: '',
  label: 'Email',
  required: true,
  email: true,
  props: {
    type: 'email',              // 'text' | 'email' | 'password' | 'number' | 'tel' | 'url'
    placeholder: 'user@example.com',
  }
}
```

**Core Props:**

- `type`: HTML input type (`'text'` | `'email'` | `'password'` | `'number'` | `'tel'` | `'url'`)
- `placeholder`: Input placeholder text

**Note:** UI integrations may extend props with additional features like `hint`, `appearance`, etc. See your specific integration's documentation.

### select

Single or multi-select dropdown.

```typescript
{
  key: 'country',
  type: 'select',
  value: '',
  label: 'Country',
  required: true,
  options: [
    { value: 'us', label: 'United States' },
    { value: 'uk', label: 'United Kingdom' },
  ],
  props: {
    placeholder: 'Select country',
  }
}
```

**Core Properties:**

- `options`: Array of `{ value: T, label: string }` objects (at field level, not in props)

**Core Props:**

- `placeholder`: Placeholder text when no value selected

**Note:** UI integrations may extend with additional props like `multiple`, `clearable`, etc. Check your specific integration's documentation.

### checkbox

Boolean toggle control.

```typescript
{
  key: 'newsletter',
  type: 'checkbox',
  value: false,
  label: 'Subscribe to newsletter',
}
```

**Note:** UI integrations may extend with additional props like `hint`. The core checkbox has no required props.

### radio

Single selection from multiple options.

```typescript
{
  key: 'plan',
  type: 'radio',
  value: '',
  label: 'Subscription Plan',
  required: true,
  options: [
    { value: 'free', label: 'Free' },
    { value: 'pro', label: 'Pro - $10/month' },
    { value: 'enterprise', label: 'Enterprise - $50/month' },
  ],
}
```

**Core Properties:**

- `options`: Array of `{ value: string, label: string }` objects (at field level, not in props)

### textarea

Multi-line text input.

```typescript
{
  key: 'bio',
  type: 'textarea',
  value: '',
  label: 'Biography',
  maxLength: 500,
  props: {
    placeholder: 'Tell us about yourself',
    rows: 4,
  }
}
```

**Core Props:**

- `placeholder`: Placeholder text
- `rows`: Number of visible text rows

### datepicker

Date selection control (requires UI integration).

```typescript
{
  key: 'birthDate',
  type: 'datepicker',
  label: 'Birth Date',
  value: null,
  required: true,
  minDate: new Date(1900, 0, 1),  // optional
  maxDate: new Date(),            // optional
  props: {
    placeholder: 'Select your birth date',
  }
}
```

**Core Properties (all optional):**

- `minDate`: Minimum selectable date (at field level) - `Date | string | null`
- `maxDate`: Maximum selectable date (at field level) - `Date | string | null`
- `startAt`: Initial calendar view date - `Date | null`

**Core Props:**

- `placeholder`: Placeholder text
- `format`: Date format string (UI-integration specific)

### slider

Numeric range selection (requires UI integration).

```typescript
{
  key: 'volume',
  type: 'slider',
  label: 'Volume',
  value: 50,
  minValue: 0,    // optional
  maxValue: 100,  // optional
  step: 5,        // optional
}
```

**Core Properties (all optional):**

- `minValue`: Minimum slider value (at field level)
- `maxValue`: Maximum slider value (at field level)
- `step`: Step increment value (at field level)

### toggle

Boolean switch control (requires UI integration). Similar to checkbox but with switch UI.

```typescript
{
  key: 'darkMode',
  type: 'toggle',
  label: 'Enable Dark Mode',
  value: false,
}
```

### multi-checkbox

Multiple selection from a list of checkboxes. Value is an array of selected values.

```typescript
{
  key: 'interests',
  type: 'multi-checkbox',
  label: 'Interests',
  value: [],  // Array of selected values
  options: [
    { value: 'tech', label: 'Technology' },
    { value: 'sports', label: 'Sports' },
    { value: 'music', label: 'Music' },
  ],
}
```

**Core Properties:**

- `options`: Array of `{ value: T, label: string }` objects (at field level, not in props)

### text

Display-only text content (not a form control). Useful for instructions, headers, or dynamic content.

```typescript
{
  key: 'instructions',
  type: 'text',
  label: 'Please fill out all required fields',
  props: {
    elementType: 'p',  // 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'span'
  },
}
```

**Core Props:**

- `elementType`: HTML element to render (`'p'` | `'h1'` - `'h6'` | `'span'`)

**Note:** Text fields don't have a `value` - they display the `label` content.

## Validation

Fields integrate with Angular's signal forms validation system. ng-forge provides shorthand syntax for common validators (e.g., `required: true`) with comprehensive customizability via the `validators` property. See [Validation](../validation/basics) for details.

```typescript
{
  key: 'username',
  type: 'input',
  value: '',
  label: 'Username',
  required: true,
  minLength: 3,
  maxLength: 20,
  pattern: '^[a-zA-Z0-9_]+$',
}
```

## Props vs Meta

When configuring fields, there are two distinct ways to customize behavior: `props` and `meta`. Understanding the difference is important for proper field configuration.

### Props (Component Properties)

`props` are **UI library-specific configuration** passed to the field component. They control the behavior and appearance of the UI library's widget.

```typescript
{
  key: 'country',
  type: 'select',
  label: 'Country',
  props: {
    // Material-specific: controls form field appearance
    appearance: 'outline',
    // PrimeNG-specific: enables filtering
    filter: true,
    showClear: true,
  },
}
```

**Characteristics of props:**

- UI library-specific (different props for Material vs PrimeNG)
- Control component behavior (multiple selection, filtering, etc.)
- Affect visual appearance (appearance, size, variant)
- Passed to wrapper components, not native elements
- Defined by each UI adapter's type definitions

### Meta (Native Element Attributes)

`meta` contains **native HTML attributes** that should be applied to the underlying DOM element. These are framework-agnostic attributes used for accessibility, testing, and browser features.

```typescript
{
  key: 'email',
  type: 'input',
  label: 'Email',
  meta: {
    // HTML autocomplete for browser autofill
    autocomplete: 'email',
    // Keyboard input mode hint
    inputmode: 'email',
    // Testing attribute
    'data-testid': 'email-input',
    // Analytics tracking
    'data-analytics': 'email-field',
    // ARIA attributes
    'aria-describedby': 'email-help',
  },
}
```

**Characteristics of meta:**

- Framework-agnostic (same across all UI libraries)
- Applied to native DOM elements (input, select, textarea)
- Used for accessibility (`aria-*`), testing (`data-*`), and browser features (`autocomplete`)
- Important for screen readers, automated testing, and browser autofill
- Defined in core library types

### When to Use Each

| Use Case                              | Use `props` | Use `meta` |
| ------------------------------------- | ----------- | ---------- |
| UI appearance (size, variant)         | ✅          | ❌         |
| Component behavior (multiple, filter) | ✅          | ❌         |
| Browser autofill (`autocomplete`)     | ❌          | ✅         |
| Testing IDs (`data-testid`)           | ❌          | ✅         |
| Accessibility (`aria-*`)              | ❌          | ✅         |
| Analytics tracking (`data-*`)         | ❌          | ✅         |
| Input mode hints (`inputmode`)        | ❌          | ✅         |

### Complete Example

```typescript
{
  key: 'email',
  type: 'input',
  label: 'Email Address',
  required: true,
  email: true,
  // UI library-specific configuration
  props: {
    type: 'email',
    appearance: 'outline',  // Material-specific
    hint: 'We will never share your email',
  },
  // Native HTML attributes
  meta: {
    autocomplete: 'email',
    inputmode: 'email',
    'data-testid': 'registration-email',
  },
}
```

## UI Integrations

UI framework integrations extend field types with framework-specific styling and features while maintaining the same configuration API.

- [Material Design](../ui-libs-integrations/material) - Material Design components
- [Bootstrap](../ui-libs-integrations/bootstrap) - Bootstrap styling
- [PrimeNG](../ui-libs-integrations/primeng) - PrimeNG components
- [Ionic](../ui-libs-integrations/ionic) - Ionic mobile components

--- schema-validation/angular-schema ---

---
title: Angular Schema
keyword: AngularSchemaPage
---

Angular's signal forms include a native `Schema<T>` API for form-level validation. This approach requires no additional dependencies and integrates seamlessly with Dynamic Forms.

## Raw Callback Pattern (Recommended)

For maximum simplicity, pass Angular's schema callback directly without any wrapper:

```typescript
import { FormConfig } from '@ng-forge/dynamic-forms';
import { validateTree } from '@angular/forms/signals';

const config = {
  // Raw callback - no wrapper needed!
  schema: (path) => {
    validateTree(path, (ctx) => {
      const { password, confirmPassword } = ctx.value();
      if (password !== confirmPassword) {
        return [{ kind: 'passwordMismatch', fieldTree: ctx.fieldTreeOf(path).confirmPassword }];
      }
      return null;
    });
  },
  fields: [
    { key: 'password', type: 'input', label: 'Password', required: true, props: { type: 'password' } },
    {
      key: 'confirmPassword',
      type: 'input',
      label: 'Confirm Password',
      required: true,
      validationMessages: { passwordMismatch: 'Passwords must match' },
      props: { type: 'password' },
    },
    { key: 'submit', type: 'submit', label: 'Register' },
  ],
} as const satisfies FormConfig;
```

This pattern gives you full access to Angular's validation APIs including `validateTree`, `validate`, and `required`.

## Combining Field and Schema Validation

Field-level validators (like `required`, `minLength`) run **first**, then the schema callback runs for cross-field validation. Both work together seamlessly.

## Using schema() Wrapper

Alternatively, you can use Angular's `schema()` function to wrap your callback:

```typescript
import { schema, required, validate } from '@angular/forms/signals';
```

Define your schema with cross-field validation:

```typescript
interface PasswordForm {
  password: string;
  confirmPassword: string;
}

const passwordSchema = schema<PasswordForm>(({ value }) =>
  validate(value.password === value.confirmPassword, { confirmPassword: { passwordMismatch: true } }),
);
```

## Using with Dynamic Forms

Pass the Angular schema directly to your form configuration:

```typescript
import { FormConfig } from '@ng-forge/dynamic-forms';
import { schema, validate } from '@angular/forms/signals';

interface PasswordForm {
  password: string;
  confirmPassword: string;
}

const config = {
  schema: schema<PasswordForm>(({ value }) =>
    validate(value.password === value.confirmPassword, { confirmPassword: { passwordMismatch: true } }),
  ),
  fields: [
    {
      key: 'password',
      type: 'input',
      label: 'Password',
      required: true,
      minLength: 8,
      props: { type: 'password' },
    },
    {
      key: 'confirmPassword',
      type: 'input',
      label: 'Confirm Password',
      required: true,
      validationMessages: {
        passwordMismatch: 'Passwords must match',
      },
      props: { type: 'password' },
    },
    {
      key: 'submit',
      type: 'submit',
      label: 'Register',
    },
  ],
} as const satisfies FormConfig;
```

## Schema API Reference

### `schema<T>(validator)`

Creates a form-level schema validator.

```typescript
const mySchema = schema<MyFormType>(({ value, touched, dirty }) => {
  // value: current form value
  // touched: whether form has been touched
  // dirty: whether form has been modified
  return validate(/* condition */, /* errors */);
});
```

### `validate(condition, errors)`

Returns validation errors when condition is false.

```typescript
validate(endDate > startDate, { endDate: { invalidRange: true } });
```

### `required(path)`

Marks a field as conditionally required.

```typescript
schema<MyForm>(({ value }) => (value.hasEndDate ? required('endDate') : null));
```

### Combining Validators

Return multiple validation results:

```typescript
schema<MyForm>(({ value }) => [
  validate(value.password === value.confirmPassword, { confirmPassword: { passwordMismatch: true } }),
  validate(value.endDate > value.startDate, { endDate: { invalidRange: true } }),
]);
```

## Examples

### Date Range Validation

```typescript
interface DateRangeForm {
  startDate: string;
  endDate: string;
}

const dateRangeSchema = schema<DateRangeForm>(({ value }) =>
  validate(!value.startDate || !value.endDate || new Date(value.endDate) >= new Date(value.startDate), { endDate: { invalidRange: true } }),
);

const config = {
  schema: dateRangeSchema,
  fields: [
    {
      key: 'startDate',
      type: 'datepicker',
      label: 'Start Date',
      required: true,
    },
    {
      key: 'endDate',
      type: 'datepicker',
      label: 'End Date',
      required: true,
      validationMessages: {
        invalidRange: 'End date must be after start date',
      },
    },
  ],
} as const satisfies FormConfig;
```

### Conditional Required Fields

```typescript
interface ContactForm {
  preferredContact: 'email' | 'phone';
  email: string;
  phone: string;
}

const contactSchema = schema<ContactForm>(({ value }) => [
  value.preferredContact === 'email' && !value.email ? validate(false, { email: { required: true } }) : null,
  value.preferredContact === 'phone' && !value.phone ? validate(false, { phone: { required: true } }) : null,
]);
```

### Complex Business Rules

```typescript
interface OrderForm {
  quantity: number;
  discount: number;
  discountType: 'percentage' | 'fixed';
  total: number;
}

const orderSchema = schema<OrderForm>(({ value }) => {
  const errors = [];

  // Percentage discount can't exceed 100%
  if (value.discountType === 'percentage' && value.discount > 100) {
    errors.push(
      validate(false, {
        discount: { maxPercentage: true },
      }),
    );
  }

  // Fixed discount can't exceed total
  if (value.discountType === 'fixed' && value.discount > value.total) {
    errors.push(
      validate(false, {
        discount: { exceedsTotal: true },
      }),
    );
  }

  return errors;
});
```

## Best Practices

**Keep schemas focused:**

```typescript
// Good - single responsibility
const passwordMatchSchema = schema<PasswordForm>(({ value }) =>
  validate(value.password === value.confirmPassword, { confirmPassword: { passwordMismatch: true } }),
);

// Avoid - too many concerns
const everythingSchema = schema<BigForm>(({ value }) => [
  // 10+ validations...
]);
```

**Use field validators for simple cases:**

```typescript
// Use field validators when possible
{
  key: 'email',
  required: true,
  email: true,
}

// Use schema for cross-field only
schema: schema<Form>(({ value }) =>
  validate(value.email !== value.alternateEmail, {
    alternateEmail: { sameAsEmail: true }
  })
)
```

## When to Use Standard Schema Instead

Consider [Standard Schema (Zod)](../zod) if you:

- Already have Zod schemas from an API or shared library
- Need the same validation in Node.js backend
- Want automatic TypeScript type inference from schemas
- Are using OpenAPI-generated schemas

## Related

- **[Schema Validation Overview](../overview)** - When to use form-level validation
- **[Standard Schema (Zod)](../zod)** - Alternative using Zod/Valibot
- **[Field Validation](../../validation/basics/)** - Individual field validators

--- schema-validation/overview ---

---
title: Overview
keyword: SchemaValidationOverviewPage
---

Form-level schema validation enables cross-field validation rules that examine the entire form state. While field-level validators check individual fields, schema validators validate relationships between multiple fields.

## When to Use Schema Validation

Schema validation excels at:

- **Password confirmation** - Ensure two fields match
- **Date ranges** - Validate end date is after start date
- **Conditional requirements** - Complex business rules across fields
- **Data consistency** - Ensure related fields are logically consistent

## Available Approaches

Dynamic Forms supports two approaches to form-level validation:

| Approach                            | Best For                               | Wrapper Required         |
| ----------------------------------- | -------------------------------------- | ------------------------ |
| [Angular Schema](../angular-schema) | Angular-only projects, full API access | No (raw callback)        |
| [Standard Schema](../zod)           | Reusing Zod/Valibot schemas, OpenAPI   | Yes (`standardSchema()`) |

### Angular Schema

Uses Angular's native schema APIs from signal forms. Best when:

- Your project is Angular-only
- You want zero additional dependencies
- Validation logic is specific to this form

```typescript
import { validateTree } from '@angular/forms/signals';

const config = {
  // Raw callback - no wrapper needed!
  schema: (path) => {
    validateTree(path, (ctx) => {
      const { password, confirmPassword } = ctx.value();
      if (password !== confirmPassword) {
        return [{ kind: 'passwordMismatch', fieldTree: ctx.fieldTreeOf(path).confirmPassword }];
      }
      return null;
    });
  },
  fields: [
    /* ... */
  ],
};
```

### Standard Schema (Zod, Valibot, ArkType)

Uses the [Standard Schema](https://standardschema.dev) spec for cross-library compatibility. Best when:

- You have existing Zod/Valibot schemas
- You're reusing OpenAPI-generated schemas
- You want the same validation on frontend and backend

```typescript
import { z } from 'zod';
import { standardSchema } from '@ng-forge/dynamic-forms/schema';

const passwordSchema = z
  .object({
    password: z.string().min(8),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, { message: 'Passwords must match', path: ['confirmPassword'] });

const config = {
  schema: standardSchema(passwordSchema),
  fields: [
    /* ... */
  ],
};
```

## Comparison

| Feature          | Angular Schema           | Standard Schema                   |
| ---------------- | ------------------------ | --------------------------------- |
| Dependencies     | None (Angular core)      | Schema library (Zod, etc.)        |
| Type inference   | Manual                   | Automatic from schema             |
| Cross-platform   | No                       | Yes (same schema in Node.js)      |
| OpenAPI compat   | No                       | Yes (via zod-openapi, etc.)       |
| Learning curve   | Familiar to Angular devs | Requires schema library knowledge |
| Wrapper required | No (raw callback)        | Yes (`standardSchema()`)          |

## How It Works

1. Define your schema (Angular or Standard Schema)
2. Add it to your form configuration via the `schema` property
3. The form validates against the schema on every change
4. Schema errors are mapped to the appropriate fields

## Next Steps

- **[Angular Schema](../angular-schema)** - Native Angular approach
- **[Standard Schema (Zod)](../zod)** - Use Zod, Valibot, or ArkType
- **[Field Validation](../../validation/basics/)** - Individual field validators

--- schema-validation/zod ---

---
title: Zod Validation
keyword: ZodSchemaPage
---

Use [Zod](https://zod.dev) schemas to validate your dynamic forms. This lets you reuse existing schemas, share validation logic between frontend and backend, and leverage Zod's powerful cross-field validation like `.refine()`.

## Installation

```bash
npm install zod
```

## Basic Usage

```typescript
import { z } from 'zod';
import { standardSchema } from '@ng-forge/dynamic-forms/schema';

const userSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

const config = {
  schema: standardSchema(userSchema),
  fields: [
    { key: 'email', type: 'input', label: 'Email', props: { type: 'email' } },
    { key: 'password', type: 'input', label: 'Password', props: { type: 'password' } },
    { key: 'submit', type: 'submit', label: 'Register' },
  ],
} as const satisfies FormConfig;
```

The `standardSchema()` wrapper tells Dynamic Forms to use Zod for validation. Errors are automatically mapped to the corresponding form fields.

## Live Demo

Try the password confirmation form with Zod validation:

<iframe src="http://localhost:4201/#/examples/zod-schema-validation" class="example-frame" title="Zod Validation Demo"></iframe>

## Cross-Field Validation

The main reason to use Zod is cross-field validation - rules that depend on multiple fields.

### Password Confirmation with `.refine()`

```typescript
const passwordSchema = z
  .object({
    password: z.string().min(8, 'Password must be at least 8 characters'),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: 'Passwords must match',
    path: ['confirmPassword'], // Error appears on this field
  });
```

### Date Range Validation

```typescript
const dateRangeSchema = z
  .object({
    startDate: z.string(),
    endDate: z.string(),
  })
  .refine((data) => new Date(data.endDate) >= new Date(data.startDate), {
    message: 'End date must be after start date',
    path: ['endDate'],
  });
```

### Multiple Cross-Field Rules with `.superRefine()`

```typescript
const registrationSchema = z
  .object({
    password: z.string().min(8),
    confirmPassword: z.string(),
    email: z.string().email(),
    confirmEmail: z.string().email(),
  })
  .superRefine((data, ctx) => {
    if (data.password !== data.confirmPassword) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Passwords must match',
        path: ['confirmPassword'],
      });
    }
    if (data.email !== data.confirmEmail) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Emails must match',
        path: ['confirmEmail'],
      });
    }
  });
```

### Conditional Required Fields

```typescript
const contactSchema = z
  .object({
    contactMethod: z.enum(['email', 'phone']),
    email: z.string().optional(),
    phone: z.string().optional(),
  })
  .refine(
    (data) => {
      if (data.contactMethod === 'email') return !!data.email;
      if (data.contactMethod === 'phone') return !!data.phone;
      return true;
    },
    (data) => ({
      message: `${data.contactMethod} is required`,
      path: [data.contactMethod],
    }),
  );
```

## Reusing Schemas

### From OpenAPI or Backend

```typescript
// Reuse schemas generated from OpenAPI specs
import { UserCreateSchema } from './generated/schemas';

const config = {
  schema: standardSchema(UserCreateSchema),
  fields: [
    { key: 'username', type: 'input', label: 'Username' },
    { key: 'email', type: 'input', label: 'Email' },
    { key: 'password', type: 'input', label: 'Password', props: { type: 'password' } },
  ],
} as const satisfies FormConfig;
```

### Shared Validation Logic

```typescript
// schemas/user.schema.ts - shared with backend
export const userSchema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Password too short'),
});

// frontend form
import { userSchema } from '@shared/schemas';

const config = {
  schema: standardSchema(userSchema),
  fields: [
    { key: 'email', type: 'input', label: 'Email' },
    { key: 'password', type: 'input', label: 'Password', props: { type: 'password' } },
  ],
} as const satisfies FormConfig;
```

## How Errors Work

Zod errors automatically map to form fields via the `path` property:

```typescript
// When validation fails, Zod produces:
{
  issues: [{ path: ['confirmPassword'], message: 'Passwords must match' }];
}

// Dynamic Forms maps this to Angular's form errors:
form.controls.confirmPassword.errors;
// → { 'Passwords must match': true }
```

## Combining with Field Validators

Use Zod for cross-field rules, field-level validators for single-field rules:

```typescript
const config = {
  // Zod handles cross-field validation
  schema: standardSchema(
    z.object({ password: z.string(), confirm: z.string() }).refine((data) => data.password === data.confirm, {
      message: 'Passwords must match',
      path: ['confirm'],
    }),
  ),

  // Field validators handle single-field rules
  fields: [
    { key: 'password', type: 'input', label: 'Password', required: true, minLength: 8 },
    { key: 'confirm', type: 'input', label: 'Confirm Password', required: true },
  ],
} as const satisfies FormConfig;
```

## Other Schema Libraries

The same approach works with Valibot and ArkType:

```typescript
// Valibot
import * as v from 'valibot';
const schema = v.object({ email: v.pipe(v.string(), v.email()) });
const config = { schema: standardSchema(schema), fields: [...] };

// ArkType
import { type } from 'arktype';
const schema = type({ email: 'email' });
const config = { schema: standardSchema(schema), fields: [...] };
```

## Related

- **[Schema Validation Overview](../overview)** - When to use form-level validation
- **[Angular Schema](../angular-schema)** - Native Angular approach without dependencies
- **[Field Validation](../../validation/basics/)** - Individual field validators

--- ui-libs-integrations/bootstrap ---

Modern Bootstrap 5 field components for ng-forge dynamic forms, built with native HTML elements and Bootstrap CSS.

---

## Installation

Install the package and its peer dependencies:

```bash group="install" name="npm"
npm install @ng-forge/dynamic-forms @ng-forge/dynamic-forms-bootstrap bootstrap
```

```bash group="install" name="yarn"
yarn add @ng-forge/dynamic-forms @ng-forge/dynamic-forms-bootstrap bootstrap
```

```bash group="install" name="pnpm"
pnpm add @ng-forge/dynamic-forms @ng-forge/dynamic-forms-bootstrap bootstrap
```

Optional: For advanced datepicker features with calendar UI:

```bash group="install-ng-bootstrap" name="npm"
npm install @ng-bootstrap/ng-bootstrap
```

```bash group="install-ng-bootstrap" name="yarn"
yarn add @ng-bootstrap/ng-bootstrap
```

```bash group="install-ng-bootstrap" name="pnpm"
pnpm add @ng-bootstrap/ng-bootstrap
```

## Quick Start

### 1. Configure Providers

Add Bootstrap field types to your application:

```typescript
// app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideDynamicForm } from '@ng-forge/dynamic-forms';
import { withBootstrapFields } from '@ng-forge/dynamic-forms-bootstrap';

export const appConfig: ApplicationConfig = {
  providers: [provideDynamicForm(...withBootstrapFields())],
};
```

### 2. Import Bootstrap Styles

Add Bootstrap CSS to your application:

```scss name="styles.scss"
@import 'bootstrap/dist/css/bootstrap.min.css';
```

Or include via CDN in your `index.html`:

```html
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
```

### 3. Create Your First Form

```typescript
import { Component, signal } from '@angular/core';
import { JsonPipe } from '@angular/common';
import { DynamicForm, type FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-contact-form',
  imports: [DynamicForm, JsonPipe],
  template: `
    <form [dynamic-form]="config" [(value)]="formValue"></form>
    @let value = formValue();
    <pre>{% raw %}{{ value | json }}{% endraw %}</pre>
  `,
})
export class ContactFormComponent {
  formValue = signal({});

  config = {
    fields: [
      {
        key: 'name',
        type: 'input',
        label: 'Full Name',
        required: true,
        props: {
          floatingLabel: true,
        },
      },
      {
        key: 'email',
        type: 'input',
        label: 'Email',
        required: true,
        email: true,
        props: {
          type: 'email',
          floatingLabel: true,
        },
      },
      {
        key: 'message',
        type: 'textarea',
        label: 'Message',
        required: true,
        minLength: 10,
        props: {
          floatingLabel: true,
          rows: 4,
        },
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Send Message',
        props: {
          variant: 'primary',
        },
      },
    ],
  } as const satisfies FormConfig;
}
```

## Configuration Options

Configure default props at the library, form, or field level.

Use `BsFormConfig` for type-safe form configurations with Bootstrap-specific props.

### Available Options

| Option          | Type           | Default | Description                  |
| --------------- | -------------- | ------- | ---------------------------- |
| `size`          | `'sm' \| 'lg'` | -       | Bootstrap size class         |
| `floatingLabel` | `boolean`      | `false` | Enable floating label design |

---

## Type Augmentation

Importing this package automatically extends `@ng-forge/dynamic-forms` with Bootstrap-specific field types via TypeScript module augmentation. If you need type safety in a file without importing specific exports, use a bare import:

```typescript
import '@ng-forge/dynamic-forms-bootstrap';
```

---

## Complete Form Example

Here's a full registration form showcasing multiple Bootstrap field types:

<iframe src="http://localhost:4204/#/examples/complete-form" class="example-frame" title="Complete Form Demo"></iframe>

This example demonstrates:

- Text inputs with validation
- Select dropdowns
- Checkboxes and switches
- Radio buttons
- Date inputs
- Range sliders
- Multi-checkbox selections
- Form submission

---

## Field Types Reference

Complete reference for all Bootstrap field types with comprehensive validation, native HTML5 features, and Bootstrap styling.

### Text Input Fields

Text input fields provide user-friendly text entry with Bootstrap form styling.

#### Input

Text input field with HTML5 type support and optional floating labels.

**Live Demo:**

<iframe src="http://localhost:4204/#/examples/input" class="example-frame" title="Input Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'email',
  type: 'input',
  label: 'Email Address',
  value: '',
  required: true,
  email: true,
  props: {
    type: 'email',
    floatingLabel: true,
    placeholder: 'Enter your email',
    hint: 'We will never share your email',
  },
}
```

**Field Properties:**

| Property      | Type               | Description                        |
| ------------- | ------------------ | ---------------------------------- |
| `key`         | `string`           | Unique field identifier (required) |
| `type`        | `'input'`          | Field type (required)              |
| `value`       | `string \| number` | Initial value                      |
| `label`       | `string`           | Field label                        |
| `placeholder` | `string`           | Placeholder text                   |
| `required`    | `boolean`          | Mark field as required             |
| `disabled`    | `boolean`          | Disable the field                  |
| `readonly`    | `boolean`          | Make field read-only               |

**Validation Properties:**

| Property    | Type               | Description                       |
| ----------- | ------------------ | --------------------------------- |
| `email`     | `boolean`          | Email format validation           |
| `minLength` | `number`           | Minimum character length          |
| `maxLength` | `number`           | Maximum character length          |
| `min`       | `number`           | Minimum value (for number inputs) |
| `max`       | `number`           | Maximum value (for number inputs) |
| `pattern`   | `string \| RegExp` | RegEx pattern validation          |

**Props (Bootstrap-Specific):**

| Prop              | Type                                                            | Default  | Description                  |
| ----------------- | --------------------------------------------------------------- | -------- | ---------------------------- |
| `type`            | `'text' \| 'email' \| 'password' \| 'number' \| 'tel' \| 'url'` | `'text'` | HTML input type              |
| `size`            | `'sm' \| 'lg'`                                                  | -        | Bootstrap size class         |
| `floatingLabel`   | `boolean`                                                       | `false`  | Enable floating label design |
| `plaintext`       | `boolean`                                                       | `false`  | Render as plaintext          |
| `hint`            | `string`                                                        | -        | Helper text below input      |
| `validFeedback`   | `string`                                                        | -        | Success message when valid   |
| `invalidFeedback` | `string`                                                        | -        | Error message when invalid   |

#### Textarea

Multi-line text input field with Bootstrap form styling.

**Live Demo:**

<iframe src="http://localhost:4204/#/examples/textarea" class="example-frame" title="Textarea Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'bio',
  type: 'textarea',
  value: '',
  label: 'Biography',
  placeholder: 'Tell us about yourself',
  required: true,
  props: {
    rows: 4,
    floatingLabel: true,
  },
}
```

**Props (Bootstrap-Specific):**

| Prop            | Type           | Default | Description                  |
| --------------- | -------------- | ------- | ---------------------------- |
| `rows`          | `number`       | `3`     | Number of visible rows       |
| `size`          | `'sm' \| 'lg'` | -       | Bootstrap size class         |
| `floatingLabel` | `boolean`      | `false` | Enable floating label design |
| `hint`          | `string`       | -       | Helper text below textarea   |

---

### Selection Fields

Selection fields enable users to choose from predefined options.

#### Select

Dropdown selection field with native HTML select element. Supports both single and multi-select modes.

**Live Demo:**

<iframe src="http://localhost:4204/#/examples/select" class="example-frame" title="Select Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'country',
  type: 'select',
  value: '',
  label: 'Country',
  required: true,
  options: [
    { value: 'us', label: 'United States' },
    { value: 'uk', label: 'United Kingdom' },
    { value: 'ca', label: 'Canada' },
  ],
  props: {
    floatingLabel: true,
  },
}
```

**Props (Bootstrap-Specific):**

| Prop            | Type           | Default | Description                  |
| --------------- | -------------- | ------- | ---------------------------- |
| `multiple`      | `boolean`      | `false` | Enable multi-select          |
| `size`          | `'sm' \| 'lg'` | -       | Bootstrap size class         |
| `floatingLabel` | `boolean`      | `false` | Enable floating label design |
| `hint`          | `string`       | -       | Helper text below select     |

#### Radio

Radio button group for selecting a single option with optional button group styling.

**Live Demo:**

<iframe src="http://localhost:4204/#/examples/radio" class="example-frame" title="Radio Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'size',
  type: 'radio',
  value: '',
  label: 'Select Size',
  required: true,
  options: [
    { value: 'small', label: 'Small' },
    { value: 'medium', label: 'Medium' },
    { value: 'large', label: 'Large' },
  ],
}
```

**Props (Bootstrap-Specific):**

| Prop          | Type           | Default | Description                               |
| ------------- | -------------- | ------- | ----------------------------------------- |
| `inline`      | `boolean`      | `false` | Display options inline                    |
| `reverse`     | `boolean`      | `false` | Reverse label and input position          |
| `buttonGroup` | `boolean`      | `false` | Render as Bootstrap button group          |
| `buttonSize`  | `'sm' \| 'lg'` | -       | Button size (when buttonGroup is enabled) |
| `hint`        | `string`       | -       | Helper text below radio group             |

#### Checkbox

Boolean checkbox control for single true/false selections.

**Live Demo:**

<iframe src="http://localhost:4204/#/examples/checkbox" class="example-frame" title="Checkbox Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'terms',
  type: 'checkbox',
  value: false,
  label: 'I accept the terms and conditions',
  required: true,
}
```

**Props (Bootstrap-Specific):**

| Prop      | Type      | Default | Description                      |
| --------- | --------- | ------- | -------------------------------- |
| `switch`  | `boolean` | `false` | Render as Bootstrap switch       |
| `inline`  | `boolean` | `false` | Inline layout                    |
| `reverse` | `boolean` | `false` | Reverse label and input position |

#### Multi-Checkbox

Multiple checkbox selection field for choosing multiple options.

**Live Demo:**

<iframe src="http://localhost:4204/#/examples/multi-checkbox" class="example-frame" title="Multi-Checkbox Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'interests',
  type: 'multi-checkbox',
  value: [],
  label: 'Select Your Interests',
  required: true,
  options: [
    { value: 'sports', label: 'Sports' },
    { value: 'music', label: 'Music' },
    { value: 'reading', label: 'Reading' },
    { value: 'travel', label: 'Travel' },
  ],
}
```

**Props (Bootstrap-Specific):**

| Prop      | Type      | Default | Description                      |
| --------- | --------- | ------- | -------------------------------- |
| `switch`  | `boolean` | `false` | Render checkboxes as switches    |
| `inline`  | `boolean` | `false` | Display options inline           |
| `reverse` | `boolean` | `false` | Reverse label and input position |
| `hint`    | `string`  | -       | Helper text below checkbox group |

---

### Interactive Fields

Interactive fields provide advanced user input controls.

#### Toggle

Slide toggle switch for boolean on/off selections (renders as Bootstrap switch).

**Live Demo:**

<iframe src="http://localhost:4204/#/examples/toggle" class="example-frame" title="Toggle Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'notifications',
  type: 'toggle',
  value: false,
  label: 'Enable notifications',
}
```

**Props (Bootstrap-Specific):**

| Prop      | Type      | Default | Description                      |
| --------- | --------- | ------- | -------------------------------- |
| `inline`  | `boolean` | `false` | Inline layout                    |
| `reverse` | `boolean` | `false` | Reverse label and input position |

#### Slider

Native HTML5 range input for selecting values from a numeric range.

**Live Demo:**

<iframe src="http://localhost:4204/#/examples/slider" class="example-frame" title="Slider Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'volume',
  type: 'slider',
  value: 50,
  label: 'Volume',
  minValue: 0,
  maxValue: 100,
  step: 1,
  props: {
    showValue: true,
  },
}
```

**Props (Bootstrap-Specific):**

| Prop        | Type      | Default | Description              |
| ----------- | --------- | ------- | ------------------------ |
| `showValue` | `boolean` | `false` | Display current value    |
| `hint`      | `string`  | -       | Helper text below slider |

#### Datepicker

Native HTML5 date input with Bootstrap styling.

**Live Demo:**

<iframe src="http://localhost:4204/#/examples/datepicker" class="example-frame" title="Datepicker Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'birthdate',
  type: 'datepicker',
  value: null,
  label: 'Date of Birth',
  required: true,
  props: {
    min: '1900-01-01',
    max: '2025-12-31',
  },
}
```

**Field Properties:**

| Property  | Type                     | Description             |
| --------- | ------------------------ | ----------------------- |
| `minDate` | `Date \| string \| null` | Minimum selectable date |
| `maxDate` | `Date \| string \| null` | Maximum selectable date |

**Props (Bootstrap-Specific):**

| Prop              | Type                                   | Default | Description                                |
| ----------------- | -------------------------------------- | ------- | ------------------------------------------ |
| `size`            | `'sm' \| 'lg'`                         | -       | Bootstrap size class                       |
| `floatingLabel`   | `boolean`                              | `false` | Enable floating label design               |
| `hint`            | `string`                               | -       | Helper text below field                    |
| `validFeedback`   | `string`                               | -       | Success message when valid                 |
| `invalidFeedback` | `string`                               | -       | Error message when invalid                 |
| `useNgBootstrap`  | `boolean`                              | -       | Use ng-bootstrap datepicker                |
| `displayMonths`   | `number`                               | -       | Number of months to display (ng-bootstrap) |
| `navigation`      | `'select' \| 'arrows' \| 'none'`       | -       | Navigation style (ng-bootstrap)            |
| `outsideDays`     | `'visible' \| 'collapsed' \| 'hidden'` | -       | How to display outside days (ng-bootstrap) |
| `showWeekNumbers` | `boolean`                              | -       | Show week numbers (ng-bootstrap)           |

---

### Buttons & Actions

Action buttons provide form submission and navigation controls.

#### Submit Button

Form submission button that's automatically disabled when the form is invalid.

**Live Demo:**

<iframe src="http://localhost:4204/#/examples/button" class="example-frame" title="Button Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  type: 'submit',
  key: 'submit',
  label: 'Create Account',
  props: {
    variant: 'primary',
    size: 'lg',
  },
}
```

The submit button automatically:

- Disables when the form is invalid
- Emits a `SubmitEvent` when clicked
- Validates all fields before submission

**Props:**

| Prop      | Type                                                                                                      | Default     | Description            |
| --------- | --------------------------------------------------------------------------------------------------------- | ----------- | ---------------------- |
| `variant` | `'primary' \| 'secondary' \| 'success' \| 'danger' \| 'warning' \| 'info' \| 'light' \| 'dark' \| 'link'` | `'primary'` | Bootstrap button color |
| `outline` | `boolean`                                                                                                 | `false`     | Use outline variant    |
| `size`    | `'sm' \| 'lg'`                                                                                            | -           | Button size            |
| `block`   | `boolean`                                                                                                 | `false`     | Full-width button      |
| `active`  | `boolean`                                                                                                 | `false`     | Active state styling   |
| `type`    | `'button' \| 'submit' \| 'reset'`                                                                         | `'submit'`  | HTML button type       |

#### Navigation Buttons

Navigation buttons for multi-step (paged) forms.

**Basic Usage:**

```typescript
{
  fields: [
    {
      key: 'step1',
      type: 'page',
      fields: [
        { key: 'name', type: 'input', value: '', label: 'Name', required: true },
        {
          type: 'next',
          key: 'next',
          label: 'Continue',
          props: { variant: 'primary' },
        },
      ],
    },
    {
      key: 'step2',
      type: 'page',
      fields: [
        { key: 'email', type: 'input', value: '', label: 'Email', required: true },
        { type: 'previous', key: 'back', label: 'Back', props: { variant: 'secondary' } },
        { type: 'submit', key: 'submit', label: 'Submit', props: { variant: 'primary' } },
      ],
    },
  ],
}
```

**Button Types:**

- **Next Button**: Navigates to the next page. Automatically disabled when current page has validation errors.
- **Previous Button**: Navigates to the previous page. Always enabled to allow users to go back.

---

## Theming

Bootstrap components use standard Bootstrap CSS classes. Customize appearance using Bootstrap's CSS variables or custom themes:

```typescript
// Field with custom variant
{
  key: 'submitBtn',
  type: 'submit',
  label: 'Save Changes',
  props: {
    variant: 'success', // Bootstrap color variant
    size: 'lg',
    outline: true,
  },
}
```

### Custom Bootstrap Theme

Customize Bootstrap variables before importing:

```scss name="styles.scss"
// Override Bootstrap variables
$primary: #007bff;
$secondary: #6c757d;
$success: #28a745;
$danger: #dc3545;

// Import Bootstrap
@import 'bootstrap/dist/css/bootstrap.min.css';
```

### Component CSS Variables

Customize field spacing and styling with CSS variables:

```scss
:root {
  --df-bs-field-gap: 0.75rem;
  --df-bs-label-font-weight: 600;
  --df-bs-hint-color: #6c757d;
  --df-bs-error-color: #dc3545;
}
```

## Common Props

All Bootstrap fields support these common properties:

| Prop   | Type           | Default | Description                       |
| ------ | -------------- | ------- | --------------------------------- |
| `size` | `'sm' \| 'lg'` | -       | Bootstrap size class              |
| `hint` | `string`       | -       | Helper text displayed below field |

## Bootstrap-Specific Features

### Floating Labels

Enable modern floating label design for input, select, and textarea fields:

```typescript
{
  key: 'email',
  type: 'input',
  label: 'Email',
  props: {
    floatingLabel: true,
  },
}
```

### Grid System Integration

Use the `col` property for responsive grid layouts:

```typescript
{
  key: 'nameRow',
  type: 'row',
  fields: [
    {
      key: 'firstName',
      type: 'input',
      label: 'First Name',
      value: '',
      col: 6, // 50% width
    },
    {
      key: 'lastName',
      type: 'input',
      label: 'Last Name',
      value: '',
      col: 6, // 50% width
    },
  ],
}
```

Or use `className` for custom Bootstrap grid classes:

```typescript
{
  key: 'firstName',
  type: 'input',
  label: 'First Name',
  className: 'col-md-6 col-lg-4',
}
```

### Validation States

Bootstrap validation classes (`.is-invalid`, `.is-valid`) are automatically applied based on form state:

- Fields show errors only after being touched
- Valid fields can show success feedback with `validFeedback` prop
- Error messages automatically display below invalid fields

### Switch Styling

Checkboxes and multi-checkboxes can render as Bootstrap switches:

```typescript
{
  key: 'notifications',
  type: 'checkbox',
  label: 'Enable notifications',
  props: {
    switch: true,
  },
}
```

### Button Groups

Radio buttons can render as Bootstrap button groups:

```typescript
{
  key: 'size',
  type: 'radio',
  label: 'Size',
  options: [
    { value: 's', label: 'S' },
    { value: 'm', label: 'M' },
    { value: 'l', label: 'L' },
  ],
  props: {
    buttonGroup: true,
    buttonSize: 'lg',
  },
}
```

## Accessibility

All Bootstrap components include:

- Proper semantic HTML5 elements
- ARIA attributes for screen readers
- Keyboard navigation support
- Focus management
- Associated labels and descriptions
- Error announcements via `aria-describedby`

Bootstrap's native HTML elements provide excellent baseline accessibility that's enhanced by ng-forge's form integration.

## Next Steps

- Check out [Examples & Patterns](../../../examples/) for real-world use cases
- Learn about [Validation](../../validation/basics/) for form validation
- See [Type Safety](../../advanced/type-safety/basics/) for TypeScript integration
- Explore [Conditional Logic](../../dynamic-behavior/conditional-logic/overview/) for dynamic field behavior

--- ui-libs-integrations/ionic ---

Mobile-first Ionic field components for ng-forge dynamic forms, optimized for iOS and Android with native platform styling.

---

## Installation

Install the package and its peer dependencies:

```bash group="install" name="npm"
npm install @ng-forge/dynamic-forms @ng-forge/dynamic-forms-ionic @ionic/angular
```

```bash group="install" name="yarn"
yarn add @ng-forge/dynamic-forms @ng-forge/dynamic-forms-ionic @ionic/angular
```

```bash group="install" name="pnpm"
pnpm add @ng-forge/dynamic-forms @ng-forge/dynamic-forms-ionic @ionic/angular
```

## Quick Start

### 1. Configure Providers

Add Ionic field types to your application:

```typescript
// app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideDynamicForm } from '@ng-forge/dynamic-forms';
import { withIonicFields } from '@ng-forge/dynamic-forms-ionic';

export const appConfig: ApplicationConfig = {
  providers: [provideDynamicForm(...withIonicFields())],
};
```

### 2. Import Ionic Styles

Add Ionic core styles to your application:

```scss name="styles.scss"
@import '@ionic/angular/css/core.css';
@import '@ionic/angular/css/normalize.css';
@import '@ionic/angular/css/structure.css';
@import '@ionic/angular/css/typography.css';

// Optional: Additional Ionic utility styles
@import '@ionic/angular/css/padding.css';
@import '@ionic/angular/css/float-elements.css';
@import '@ionic/angular/css/text-alignment.css';
@import '@ionic/angular/css/text-transformation.css';
@import '@ionic/angular/css/flex-utils.css';
```

### 3. Create Your First Form

```typescript
import { Component, signal } from '@angular/core';
import { JsonPipe } from '@angular/common';
import { DynamicForm, type FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-contact-form',
  imports: [DynamicForm, JsonPipe],
  template: `
    <form [dynamic-form]="config" [(value)]="formValue"></form>
    @let value = formValue();
    <pre>{% raw %}{{ value | json }}{% endraw %}</pre>
  `,
})
export class ContactFormComponent {
  formValue = signal({});

  config = {
    fields: [
      {
        key: 'name',
        type: 'input',
        label: 'Full Name',
        value: '',
        required: true,
        props: {
          placeholder: 'Enter your name',
        },
      },
      {
        key: 'email',
        type: 'input',
        label: 'Email',
        value: '',
        required: true,
        email: true,
        props: {
          type: 'email',
          placeholder: 'your@email.com',
        },
      },
      {
        key: 'message',
        type: 'textarea',
        label: 'Message',
        value: '',
        required: true,
        minLength: 10,
        props: {
          placeholder: 'Your message here...',
          rows: 4,
          autoGrow: true,
        },
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Send Message',
        props: {
          color: 'primary',
          expand: 'block',
        },
      },
    ],
  } as const satisfies FormConfig;
}
```

## Configuration Options

Configure default props at the library, form, or field level.

Use `IonicFormConfig` for type-safe form configurations with Ionic-specific props.

### Available Options

| Option           | Type                                                                                                            | Default     | Description              |
| ---------------- | --------------------------------------------------------------------------------------------------------------- | ----------- | ------------------------ |
| `fill`           | `'solid' \| 'outline'`                                                                                          | `'solid'`   | Input fill style         |
| `shape`          | `'round'`                                                                                                       | -           | Rounded shape for inputs |
| `labelPlacement` | `'start' \| 'end' \| 'fixed' \| 'stacked' \| 'floating'`                                                        | `'start'`   | Label position           |
| `color`          | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger' \| 'light' \| 'medium' \| 'dark'` | `'primary'` | Ionic color theme        |
| `size`           | `'small' \| 'default' \| 'large'`                                                                               | `'default'` | Button size              |
| `expand`         | `'full' \| 'block'`                                                                                             | -           | Button expand behavior   |
| `buttonFill`     | `'clear' \| 'outline' \| 'solid' \| 'default'`                                                                  | `'solid'`   | Button fill style        |
| `strong`         | `boolean`                                                                                                       | `false`     | Bold button text         |

---

## Type Augmentation

Importing this package automatically extends `@ng-forge/dynamic-forms` with Ionic-specific field types via TypeScript module augmentation. If you need type safety in a file without importing specific exports, use a bare import:

```typescript
import '@ng-forge/dynamic-forms-ionic';
```

---

## Complete Form Example

Here's a full registration form showcasing multiple Ionic field types optimized for mobile:

<iframe src="http://localhost:4203/#/examples/complete-form" class="example-frame" title="Complete Form Demo"></iframe>

This example demonstrates:

- Text inputs with mobile keyboard optimization
- Select dropdowns with native action sheets
- Checkboxes and toggles with Ionic styling
- Radio buttons
- Date/time pickers with native selectors
- Range sliders with pin display
- Multi-checkbox selections
- Form submission

---

## Field Types Reference

Complete reference for all Ionic field types with mobile-first design, native platform styling, and comprehensive validation.

### Text Input Fields

Text input fields provide mobile-optimized text entry with platform-specific keyboards.

#### Input

Text input field with mobile keyboard optimization and platform-adaptive styling.

**Live Demo:**

<iframe src="http://localhost:4203/#/examples/input" class="example-frame" title="Input Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'email',
  type: 'input',
  label: 'Email Address',
  value: '',
  required: true,
  email: true,
  props: {
    type: 'email',
    placeholder: 'your@email.com',
    clearInput: true,
  },
}
```

**Field Properties:**

| Property      | Type               | Description                        |
| ------------- | ------------------ | ---------------------------------- |
| `key`         | `string`           | Unique field identifier (required) |
| `type`        | `'input'`          | Field type (required)              |
| `value`       | `string \| number` | Initial value                      |
| `label`       | `string`           | Field label                        |
| `placeholder` | `string`           | Placeholder text                   |
| `required`    | `boolean`          | Mark field as required             |
| `disabled`    | `boolean`          | Disable the field                  |
| `readonly`    | `boolean`          | Make field read-only               |

**Validation Properties:**

| Property    | Type               | Description                       |
| ----------- | ------------------ | --------------------------------- |
| `email`     | `boolean`          | Email format validation           |
| `minLength` | `number`           | Minimum character length          |
| `maxLength` | `number`           | Maximum character length          |
| `min`       | `number`           | Minimum value (for number inputs) |
| `max`       | `number`           | Maximum value (for number inputs) |
| `pattern`   | `string \| RegExp` | RegEx pattern validation          |

**Props (Ionic-Specific):**

| Prop             | Type                                                                           | Default   | Description             |
| ---------------- | ------------------------------------------------------------------------------ | --------- | ----------------------- |
| `type`           | `'text' \| 'email' \| 'password' \| 'number' \| 'tel' \| 'url'`                | `'text'`  | HTML input type         |
| `placeholder`    | `string`                                                                       | -         | Placeholder text        |
| `clearInput`     | `boolean`                                                                      | `false`   | Show clear button       |
| `fill`           | `'solid' \| 'outline'`                                                         | `'solid'` | Input fill style        |
| `shape`          | `'round'`                                                                      | -         | Rounded input shape     |
| `labelPlacement` | `'start' \| 'end' \| 'fixed' \| 'stacked' \| 'floating'`                       | `'start'` | Position of the label   |
| `color`          | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger'` | -         | Ionic theme color       |
| `helperText`     | `string`                                                                       | -         | Helper text below input |
| `counter`        | `boolean`                                                                      | `false`   | Show character counter  |

#### Textarea

Multi-line text input field with auto-grow support for mobile devices.

**Live Demo:**

<iframe src="http://localhost:4203/#/examples/textarea" class="example-frame" title="Textarea Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'bio',
  type: 'textarea',
  value: '',
  label: 'Biography',
  placeholder: 'Tell us about yourself',
  required: true,
  maxLength: 500,
  props: {
    rows: 4,
    autoGrow: true,
  },
}
```

**Props (Ionic-Specific):**

| Prop             | Type                                                                           | Default   | Description                  |
| ---------------- | ------------------------------------------------------------------------------ | --------- | ---------------------------- |
| `rows`           | `number`                                                                       | `4`       | Number of visible rows       |
| `autoGrow`       | `boolean`                                                                      | `false`   | Auto-resize based on content |
| `placeholder`    | `string`                                                                       | -         | Placeholder text             |
| `fill`           | `'solid' \| 'outline'`                                                         | `'solid'` | Textarea fill style          |
| `labelPlacement` | `'start' \| 'end' \| 'fixed' \| 'stacked' \| 'floating'`                       | `'start'` | Position of the label        |
| `color`          | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger'` | -         | Ionic theme color            |
| `helperText`     | `string`                                                                       | -         | Helper text below field      |
| `counter`        | `boolean`                                                                      | `false`   | Show character counter       |

---

### Selection Fields

Selection fields enable users to choose from predefined options with mobile-optimized interfaces.

#### Select

Dropdown selection field with native action sheets on mobile devices.

**Live Demo:**

<iframe src="http://localhost:4203/#/examples/select" class="example-frame" title="Select Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'country',
  type: 'select',
  value: '',
  label: 'Country',
  required: true,
  options: [
    { value: 'us', label: 'United States' },
    { value: 'uk', label: 'United Kingdom' },
    { value: 'ca', label: 'Canada' },
  ],
  props: {
    interface: 'action-sheet',
  },
}
```

**Props (Ionic-Specific):**

| Prop             | Type                                                                           | Default          | Description           |
| ---------------- | ------------------------------------------------------------------------------ | ---------------- | --------------------- |
| `interface`      | `'action-sheet' \| 'alert' \| 'popover'`                                       | `'action-sheet'` | Mobile selection UI   |
| `multiple`       | `boolean`                                                                      | `false`          | Enable multi-select   |
| `placeholder`    | `string`                                                                       | -                | Placeholder text      |
| `cancelText`     | `string`                                                                       | `'Cancel'`       | Cancel button text    |
| `okText`         | `string`                                                                       | `'OK'`           | OK button text        |
| `fill`           | `'solid' \| 'outline'`                                                         | `'solid'`        | Select fill style     |
| `labelPlacement` | `'start' \| 'end' \| 'fixed' \| 'stacked' \| 'floating'`                       | `'start'`        | Position of the label |
| `color`          | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger'` | -                | Ionic theme color     |

#### Radio

Radio button group for selecting a single option with mobile-friendly spacing.

**Live Demo:**

<iframe src="http://localhost:4203/#/examples/radio" class="example-frame" title="Radio Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'size',
  type: 'radio',
  value: '',
  label: 'Select Size',
  required: true,
  options: [
    { value: 'small', label: 'Small' },
    { value: 'medium', label: 'Medium' },
    { value: 'large', label: 'Large' },
  ],
}
```

**Props (Ionic-Specific):**

| Prop             | Type                                                                           | Default | Description               |
| ---------------- | ------------------------------------------------------------------------------ | ------- | ------------------------- |
| `labelPlacement` | `'start' \| 'end' \| 'fixed' \| 'stacked'`                                     | `'end'` | Position of option labels |
| `justify`        | `'start' \| 'end' \| 'space-between'`                                          | -       | Layout justification      |
| `color`          | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger'` | -       | Ionic theme color         |

#### Checkbox

Boolean checkbox control optimized for touch interaction.

**Live Demo:**

<iframe src="http://localhost:4203/#/examples/checkbox" class="example-frame" title="Checkbox Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'terms',
  type: 'checkbox',
  value: false,
  label: 'I accept the terms and conditions',
  required: true,
}
```

**Props (Ionic-Specific):**

| Prop             | Type                                                                           | Default | Description            |
| ---------------- | ------------------------------------------------------------------------------ | ------- | ---------------------- |
| `labelPlacement` | `'start' \| 'end' \| 'fixed' \| 'stacked'`                                     | `'end'` | Position of label text |
| `justify`        | `'start' \| 'end' \| 'space-between'`                                          | -       | Layout justification   |
| `color`          | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger'` | -       | Ionic theme color      |

#### Multi-Checkbox

Multiple checkbox selection field for choosing multiple options.

**Live Demo:**

<iframe src="http://localhost:4203/#/examples/multi-checkbox" class="example-frame" title="Multi-Checkbox Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'interests',
  type: 'multi-checkbox',
  value: [],
  label: 'Select Your Interests',
  required: true,
  options: [
    { value: 'sports', label: 'Sports' },
    { value: 'music', label: 'Music' },
    { value: 'reading', label: 'Reading' },
    { value: 'travel', label: 'Travel' },
  ],
}
```

**Props (Ionic-Specific):**

| Prop             | Type                                                                           | Default | Description          |
| ---------------- | ------------------------------------------------------------------------------ | ------- | -------------------- |
| `labelPlacement` | `'start' \| 'end' \| 'fixed' \| 'stacked'`                                     | `'end'` | Position of labels   |
| `justify`        | `'start' \| 'end' \| 'space-between'`                                          | -       | Layout justification |
| `color`          | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger'` | -       | Ionic theme color    |

---

### Interactive Fields

Interactive fields provide advanced user input controls optimized for mobile interaction.

#### Toggle

Slide toggle switch for boolean on/off selections with smooth animations.

**Live Demo:**

<iframe src="http://localhost:4203/#/examples/toggle" class="example-frame" title="Toggle Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'notifications',
  type: 'toggle',
  value: false,
  label: 'Enable notifications',
}
```

**Props (Ionic-Specific):**

| Prop                | Type                                                                           | Default | Description            |
| ------------------- | ------------------------------------------------------------------------------ | ------- | ---------------------- |
| `labelPlacement`    | `'start' \| 'end' \| 'fixed' \| 'stacked'`                                     | `'end'` | Position of label text |
| `justify`           | `'start' \| 'end' \| 'space-between'`                                          | -       | Layout justification   |
| `enableOnOffLabels` | `boolean`                                                                      | `false` | Show on/off labels     |
| `color`             | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger'` | -       | Ionic theme color      |

#### Slider

Range slider control with pin display and snap-to-tick support.

**Live Demo:**

<iframe src="http://localhost:4203/#/examples/slider" class="example-frame" title="Slider Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'volume',
  type: 'slider',
  value: 50,
  label: 'Volume',
  minValue: 0,
  maxValue: 100,
  step: 1,
  props: {
    pin: true,
    ticks: true,
  },
}
```

**Field Properties:**

| Property   | Type     | Default | Description          |
| ---------- | -------- | ------- | -------------------- |
| `minValue` | `number` | `0`     | Minimum slider value |
| `maxValue` | `number` | `100`   | Maximum slider value |
| `step`     | `number` | `1`     | Value increment step |

**Props (Ionic-Specific):**

| Prop             | Type                                                                           | Default   | Description                    |
| ---------------- | ------------------------------------------------------------------------------ | --------- | ------------------------------ |
| `pin`            | `boolean`                                                                      | `false`   | Show value pin above knob      |
| `pinFormatter`   | `(value: number) => string \| number`                                          | -         | Custom formatter for pin value |
| `ticks`          | `boolean`                                                                      | `false`   | Show tick marks                |
| `snaps`          | `boolean`                                                                      | `false`   | Snap to tick marks             |
| `dualKnobs`      | `boolean`                                                                      | `false`   | Enable dual knob mode          |
| `color`          | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger'` | -         | Ionic theme color              |
| `labelPlacement` | `'start' \| 'end' \| 'fixed' \| 'stacked'`                                     | `'start'` | Position of label              |

#### Datepicker

Date and time selection with native mobile pickers for iOS and Android.

**Live Demo:**

<iframe src="http://localhost:4203/#/examples/datepicker" class="example-frame" title="Datepicker Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'birthdate',
  type: 'datepicker',
  value: null,
  label: 'Date of Birth',
  required: true,
  props: {
    presentation: 'date',
  },
}
```

**Field Properties:**

| Property  | Type                     | Description             |
| --------- | ------------------------ | ----------------------- |
| `minDate` | `Date \| string \| null` | Minimum selectable date |
| `maxDate` | `Date \| string \| null` | Maximum selectable date |

**Props (Ionic-Specific):**

| Prop                   | Type                                                                                  | Default    | Description              |
| ---------------------- | ------------------------------------------------------------------------------------- | ---------- | ------------------------ |
| `presentation`         | `'date' \| 'time' \| 'date-time' \| 'time-date' \| 'month' \| 'month-year' \| 'year'` | `'date'`   | Picker type              |
| `showDefaultButtons`   | `boolean`                                                                             | `true`     | Show cancel/done buttons |
| `showDefaultTitle`     | `boolean`                                                                             | -          | Show default title       |
| `showDefaultTimeLabel` | `boolean`                                                                             | -          | Show default time label  |
| `showClearButton`      | `boolean`                                                                             | -          | Show clear button        |
| `cancelText`           | `string`                                                                              | `'Cancel'` | Cancel button text       |
| `doneText`             | `string`                                                                              | `'Done'`   | Done button text         |
| `multiple`             | `boolean`                                                                             | `false`    | Allow multiple selection |
| `preferWheel`          | `boolean`                                                                             | `false`    | Use wheel picker style   |
| `size`                 | `'cover' \| 'fixed'`                                                                  | -          | Picker overlay size      |
| `color`                | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger'`        | -          | Ionic theme color        |

---

### Buttons & Actions

Action buttons provide form submission and navigation controls with Ionic styling.

#### Submit Button

Form submission button that's automatically disabled when the form is invalid.

**Live Demo:**

<iframe src="http://localhost:4203/#/examples/button" class="example-frame" title="Button Field Demo"></iframe>

**Basic Usage:**

```typescript
{
  type: 'submit',
  key: 'submit',
  label: 'Create Account',
  props: {
    color: 'primary',
    expand: 'block',
  },
}
```

The submit button automatically:

- Disables when the form is invalid
- Emits a `SubmitEvent` when clicked
- Validates all fields before submission

**Props:**

| Prop     | Type                                                                                                            | Default     | Description       |
| -------- | --------------------------------------------------------------------------------------------------------------- | ----------- | ----------------- |
| `expand` | `'full' \| 'block'`                                                                                             | -           | Button width      |
| `fill`   | `'clear' \| 'outline' \| 'solid' \| 'default'`                                                                  | `'solid'`   | Button fill style |
| `shape`  | `'round'`                                                                                                       | -           | Rounded button    |
| `size`   | `'small' \| 'default' \| 'large'`                                                                               | -           | Button size       |
| `color`  | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger' \| 'light' \| 'medium' \| 'dark'` | `'primary'` | Ionic theme color |
| `strong` | `boolean`                                                                                                       | `false`     | Use strong font   |

#### Navigation Buttons

Navigation buttons for multi-step (paged) forms with platform-adaptive styling.

**Basic Usage:**

```typescript
{
  fields: [
    {
      key: 'step1',
      type: 'page',
      fields: [
        { key: 'step1Title', type: 'text', label: 'Step 1', props: { elementType: 'h3' } },
        { key: 'name', type: 'input', value: '', label: 'Name', required: true },
        {
          type: 'next',
          key: 'next',
          label: 'Continue',
          props: { color: 'primary', expand: 'block' },
        },
      ],
    },
    {
      key: 'step2',
      type: 'page',
      fields: [
        { key: 'step2Title', type: 'text', label: 'Step 2', props: { elementType: 'h3' } },
        { key: 'email', type: 'input', value: '', label: 'Email', required: true },
        { type: 'previous', key: 'back', label: 'Back' },
        { type: 'submit', key: 'submit', label: 'Submit', props: { color: 'primary' } },
      ],
    },
  ],
}
```

**Button Types:**

- **Next Button**: Navigates to the next page. Automatically disabled when current page has validation errors.
- **Previous Button**: Navigates to the previous page. Always enabled to allow users to go back.

---

## Theming

Ionic components use CSS variables for theming. Customize colors and styles globally or per-component.

### Color Palette

Ionic provides a comprehensive color system:

```typescript
// Field with custom color
{
  key: 'email',
  type: 'input',
  label: 'Email',
  props: {
    color: 'success', // Uses your theme's success color
  },
}
```

**Available Colors:**

- `'primary'` - Primary brand color
- `'secondary'` - Secondary brand color
- `'tertiary'` - Tertiary brand color
- `'success'` - Success/positive actions
- `'warning'` - Warning states
- `'danger'` - Error/destructive actions
- `'light'` - Light variant
- `'medium'` - Medium gray
- `'dark'` - Dark variant

### Custom Theme Variables

Override Ionic's default colors in your global styles:

```scss name="styles.scss"
:root {
  --ion-color-primary: #3880ff;
  --ion-color-primary-rgb: 56, 128, 255;
  --ion-color-primary-contrast: #ffffff;
  --ion-color-primary-contrast-rgb: 255, 255, 255;
  --ion-color-primary-shade: #3171e0;
  --ion-color-primary-tint: #4c8dff;

  // Customize other colors...
}
```

See [Ionic Theming Guide](https://ionicframework.com/docs/theming/basics) for complete customization options.

## Common Props

All Ionic fields support these common properties:

| Prop    | Type                                                                           | Default     | Description                     |
| ------- | ------------------------------------------------------------------------------ | ----------- | ------------------------------- |
| `color` | `'primary' \| 'secondary' \| 'tertiary' \| 'success' \| 'warning' \| 'danger'` | `'primary'` | Ionic theme color               |
| `mode`  | `'ios' \| 'md'`                                                                | -           | Force platform-specific styling |

## Mobile Optimization

All Ionic components are designed for mobile devices:

### Touch Targets

- **Minimum size**: 44x44px touch areas for accessibility
- **Spacing**: Adequate padding for comfortable tapping
- **Visual feedback**: Ripple effects and state changes

### Native Keyboards

Input fields automatically show the appropriate keyboard:

```typescript
{
  key: 'email',
  type: 'input',
  props: {
    type: 'email',      // Shows email keyboard
    inputmode: 'email', // Forces email input mode
  },
}
```

**Inputmode Options:**

- `'text'` - Standard keyboard
- `'decimal'` - Numeric with decimal
- `'numeric'` - Numeric only
- `'tel'` - Telephone keypad
- `'search'` - Search keyboard
- `'email'` - Email keyboard
- `'url'` - URL keyboard

### Platform Styling

Ionic automatically adapts to the platform:

- **iOS**: Native iOS styling with SF Pro font and iOS design patterns
- **Android**: Material Design with Roboto font and MD patterns
- **Automatic detection**: Based on device platform
- **Manual override**: Use `mode` prop to force specific styling

```typescript
{
  key: 'name',
  type: 'input',
  label: 'Name',
  props: {
    mode: 'ios', // Force iOS styling on all platforms
  },
}
```

### Performance

- **Hardware acceleration**: GPU-accelerated animations
- **Virtual scrolling**: Efficient rendering for long lists
- **Lazy loading**: Components load on demand
- **Gesture support**: Native swipe and touch gestures

## Accessibility

All Ionic components include comprehensive accessibility features:

### ARIA Support

- Proper ARIA roles and attributes
- ARIA labels for screen readers
- ARIA-describedby for error messages
- ARIA-invalid for validation states

### Keyboard Navigation

- Full keyboard support for all interactive elements
- Tab navigation with proper focus order
- Enter/Space for button activation
- Arrow keys for option selection

### Screen Readers

- Descriptive labels for all form controls
- Error message announcements
- State change notifications
- Context-aware instructions

### Focus Management

- Visible focus indicators
- Logical focus order
- Focus trap for modals
- Auto-focus on error fields

### High Contrast

- Compatible with high contrast modes
- Sufficient color contrast ratios (WCAG AA)
- Clear visual distinctions
- Icon and text alternatives

## Next Steps

- Check out [Examples & Patterns](../../../examples/) for real-world use cases
- Learn about [Validation](../../validation/basics/) for form validation
- See [Type Safety](../../advanced/type-safety/basics/) for TypeScript integration
- Explore [Conditional Logic](../../dynamic-behavior/conditional-logic/overview/) for dynamic field behavior

--- ui-libs-integrations/material ---

Beautiful Material Design field components for ng-forge dynamic forms, built with Angular Material.

---

## Installation

Install the package and its peer dependencies:

```bash group="install" name="npm"
npm install @ng-forge/dynamic-forms @ng-forge/dynamic-forms-material @angular/material @angular/cdk
```

```bash group="install" name="yarn"
yarn add @ng-forge/dynamic-forms @ng-forge/dynamic-forms-material @angular/material @angular/cdk
```

```bash group="install" name="pnpm"
pnpm add @ng-forge/dynamic-forms @ng-forge/dynamic-forms-material @angular/material @angular/cdk
```

## Quick Start

### 1. Configure Providers

Add Material Design field types to your application:

```typescript
// app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideDynamicForm } from '@ng-forge/dynamic-forms';
import { withMaterialFields } from '@ng-forge/dynamic-forms-material';
import { provideAnimations } from '@angular/platform-browser/animations';

export const appConfig: ApplicationConfig = {
  providers: [provideAnimations(), provideDynamicForm(...withMaterialFields())],
};
```

### 2. Import Material Theme

Add a Material Design theme to your styles:

```scss name="styles.scss"
@use '@angular/material' as mat;

@include mat.core();

$my-primary: mat.define-palette(mat.$indigo-palette);
$my-accent: mat.define-palette(mat.$pink-palette);
$my-warn: mat.define-palette(mat.$red-palette);

$my-theme: mat.define-light-theme(
  (
    color: (
      primary: $my-primary,
      accent: $my-accent,
      warn: $my-warn,
    ),
  )
);

@include mat.all-component-themes($my-theme);
```

### 3. Create Your First Form

```typescript
import { Component, signal } from '@angular/core';
import { JsonPipe } from '@angular/common';
import { DynamicForm, type FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-contact-form',
  imports: [DynamicForm, JsonPipe],
  template: `
    <form [dynamic-form]="config" [(value)]="formValue"></form>
    @let value = formValue();
    <pre>{% raw %}{{ value | json }}{% endraw %}</pre>
  `,
})
export class ContactFormComponent {
  formValue = signal({});

  config = {
    fields: [
      {
        key: 'name',
        type: 'input',
        label: 'Full Name',
        required: true,
        props: {
          appearance: 'outline',
        },
      },
      {
        key: 'email',
        type: 'input',
        label: 'Email',
        required: true,
        email: true,
        props: {
          type: 'email',
          appearance: 'outline',
        },
      },
      {
        key: 'message',
        type: 'textarea',
        label: 'Message',
        required: true,
        minLength: 10,
        props: {
          appearance: 'outline',
          rows: 4,
        },
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Send Message',
        props: {
          color: 'primary',
        },
      },
    ],
  } as const satisfies FormConfig;
}
```

## Configuration Options

Configure default props at the library, form, or field level.

Use `MatFormConfig` for type-safe form configurations with Material-specific props.

### Available Options

| Option            | Type                              | Default     | Description                   |
| ----------------- | --------------------------------- | ----------- | ----------------------------- |
| `appearance`      | `'fill' \| 'outline'`             | `'fill'`    | Form field visual style       |
| `subscriptSizing` | `'fixed' \| 'dynamic'`            | `'fixed'`   | Error/hint spacing behavior   |
| `color`           | `'primary' \| 'accent' \| 'warn'` | `'primary'` | Theme color for controls      |
| `labelPosition`   | `'before' \| 'after'`             | `'after'`   | Label position for checkboxes |
| `disableRipple`   | `boolean`                         | `false`     | Disable ripple effect         |

---

## Type Augmentation

Importing this package automatically extends `@ng-forge/dynamic-forms` with Material-specific field types via TypeScript module augmentation. If you need type safety in a file without importing specific exports, use a bare import:

```typescript
import '@ng-forge/dynamic-forms-material';
```

---

## Complete Form Example

Here's a full registration form showcasing multiple Material Design field types:

<iframe src="http://localhost:4201/#/examples/complete-form" class="example-frame" title="Complete Form Demo"></iframe>

This example demonstrates:

- Text inputs with validation
- Select dropdowns
- Checkboxes and toggles
- Radio buttons
- Date pickers
- Sliders
- Multi-checkbox selections
- Form submission

---

## Field Types Reference

Complete reference for all Material Design field types with comprehensive validation, accessibility features, and Material Design styling.

### Text Input Fields

Text input fields provide user-friendly text entry with Material Design styling.

#### Input

Text input field with HTML5 type support.

**Live Demo:**

<iframe src="http://localhost:4201/#/examples/input" class="example-frame" title="Input Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'email',
  type: 'input',
  label: 'Email Address',
  value: '',
  required: true,
  email: true,
  props: {
    type: 'email',
    appearance: 'outline',
    placeholder: 'Enter your email',
  },
}
```

**Field Properties:**

| Property      | Type               | Description                        |
| ------------- | ------------------ | ---------------------------------- |
| `key`         | `string`           | Unique field identifier (required) |
| `type`        | `'input'`          | Field type (required)              |
| `value`       | `string \| number` | Initial value                      |
| `label`       | `string`           | Field label                        |
| `placeholder` | `string`           | Placeholder text                   |
| `required`    | `boolean`          | Mark field as required             |
| `disabled`    | `boolean`          | Disable the field                  |
| `readonly`    | `boolean`          | Make field read-only               |

**Validation Properties:**

| Property    | Type               | Description                       |
| ----------- | ------------------ | --------------------------------- |
| `email`     | `boolean`          | Email format validation           |
| `minLength` | `number`           | Minimum character length          |
| `maxLength` | `number`           | Maximum character length          |
| `min`       | `number`           | Minimum value (for number inputs) |
| `max`       | `number`           | Maximum value (for number inputs) |
| `pattern`   | `string \| RegExp` | RegEx pattern validation          |

**Props (Material-Specific):**

| Prop              | Type                                                            | Default   | Description               |
| ----------------- | --------------------------------------------------------------- | --------- | ------------------------- |
| `type`            | `'text' \| 'email' \| 'password' \| 'number' \| 'tel' \| 'url'` | `'text'`  | HTML input type           |
| `appearance`      | `'fill' \| 'outline'`                                           | `'fill'`  | Material form field style |
| `hint`            | `string`                                                        | -         | Helper text below input   |
| `subscriptSizing` | `'fixed' \| 'dynamic'`                                          | `'fixed'` | Error/hint spacing        |

#### Textarea

Multi-line text input field with Material Design styling.

**Live Demo:**

<iframe src="http://localhost:4201/#/examples/textarea" class="example-frame" title="Textarea Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'bio',
  type: 'textarea',
  value: '',
  label: 'Biography',
  placeholder: 'Tell us about yourself',
  required: true,
}
```

**Props (Material-Specific):**

| Prop              | Type                                             | Default      | Description               |
| ----------------- | ------------------------------------------------ | ------------ | ------------------------- |
| `appearance`      | `'fill' \| 'outline'`                            | `'outline'`  | Visual style              |
| `rows`            | `number`                                         | `4`          | Number of visible rows    |
| `cols`            | `number`                                         | -            | Number of visible columns |
| `resize`          | `'none' \| 'both' \| 'horizontal' \| 'vertical'` | `'vertical'` | Resize behavior           |
| `subscriptSizing` | `'fixed' \| 'dynamic'`                           | `'fixed'`    | Error/hint sizing         |
| `hint`            | `string`                                         | -            | Help text below field     |

---

### Selection Fields

Selection fields enable users to choose from predefined options.

#### Select

Dropdown selection field. Supports both single and multi-select modes.

**Live Demo:**

<iframe src="http://localhost:4201/#/examples/select" class="example-frame" title="Select Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'country',
  type: 'select',
  value: '',
  label: 'Country',
  required: true,
  options: [
    { value: 'us', label: 'United States' },
    { value: 'uk', label: 'United Kingdom' },
    { value: 'ca', label: 'Canada' },
  ],
}
```

**Props (Material-Specific):**

| Prop              | Type                   | Default     | Description           |
| ----------------- | ---------------------- | ----------- | --------------------- |
| `appearance`      | `'fill' \| 'outline'`  | `'outline'` | Visual style          |
| `multiple`        | `boolean`              | `false`     | Enable multi-select   |
| `hint`            | `string`               | -           | Help text below field |
| `subscriptSizing` | `'fixed' \| 'dynamic'` | `'fixed'`   | Error/hint sizing     |

#### Radio

Radio button group for selecting a single option.

**Live Demo:**

<iframe src="http://localhost:4201/#/examples/radio" class="example-frame" title="Radio Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'size',
  type: 'radio',
  value: '',
  label: 'Select Size',
  required: true,
  options: [
    { value: 'small', label: 'Small' },
    { value: 'medium', label: 'Medium' },
    { value: 'large', label: 'Large' },
  ],
}
```

**Props (Material-Specific):**

| Prop            | Type                              | Default     | Description               |
| --------------- | --------------------------------- | ----------- | ------------------------- |
| `color`         | `'primary' \| 'accent' \| 'warn'` | `'primary'` | Material theme color      |
| `labelPosition` | `'before' \| 'after'`             | `'after'`   | Position of option labels |

#### Checkbox

Boolean checkbox control for single true/false selections.

**Live Demo:**

<iframe src="http://localhost:4201/#/examples/checkbox" class="example-frame" title="Checkbox Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'terms',
  type: 'checkbox',
  value: false,
  label: 'I accept the terms and conditions',
  required: true,
}
```

**Props (Material-Specific):**

| Prop            | Type                              | Default     | Description            |
| --------------- | --------------------------------- | ----------- | ---------------------- |
| `color`         | `'primary' \| 'accent' \| 'warn'` | `'primary'` | Material theme color   |
| `labelPosition` | `'before' \| 'after'`             | `'after'`   | Position of label text |

#### Multi-Checkbox

Multiple checkbox selection field for choosing multiple options.

**Live Demo:**

<iframe src="http://localhost:4201/#/examples/multi-checkbox" class="example-frame" title="Multi-Checkbox Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'interests',
  type: 'multi-checkbox',
  value: [],
  label: 'Select Your Interests',
  required: true,
  options: [
    { value: 'sports', label: 'Sports' },
    { value: 'music', label: 'Music' },
    { value: 'reading', label: 'Reading' },
    { value: 'travel', label: 'Travel' },
  ],
}
```

---

### Interactive Fields

Interactive fields provide advanced user input controls.

#### Toggle

Slide toggle switch for boolean on/off selections.

**Live Demo:**

<iframe src="http://localhost:4201/#/examples/toggle" class="example-frame" title="Toggle Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'notifications',
  type: 'toggle',
  value: false,
  label: 'Enable notifications',
}
```

**Props (Material-Specific):**

| Prop            | Type                              | Default     | Description            |
| --------------- | --------------------------------- | ----------- | ---------------------- |
| `color`         | `'primary' \| 'accent' \| 'warn'` | `'primary'` | Material theme color   |
| `labelPosition` | `'before' \| 'after'`             | `'after'`   | Position of label text |

#### Slider

Numeric slider control for selecting values from a range.

**Live Demo:**

<iframe src="http://localhost:4201/#/examples/slider" class="example-frame" title="Slider Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'volume',
  type: 'slider',
  value: 50,
  label: 'Volume',
  minValue: 0,
  maxValue: 100,
  step: 1,
}
```

**Props (Material-Specific):**

| Prop                            | Type                              | Default     | Description                  |
| ------------------------------- | --------------------------------- | ----------- | ---------------------------- |
| `thumbLabel` / `showThumbLabel` | `boolean`                         | `false`     | Show value tooltip on thumb  |
| `tickInterval`                  | `number \| 'auto'`                | -           | Show tick marks at intervals |
| `color`                         | `'primary' \| 'accent' \| 'warn'` | `'primary'` | Material theme color         |
| `hint`                          | `string`                          | -           | Help text below slider       |

#### Datepicker

Date selection field with Material Design calendar popup.

**Live Demo:**

<iframe src="http://localhost:4201/#/examples/datepicker" class="example-frame" title="Datepicker Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'birthdate',
  type: 'datepicker',
  value: null,
  label: 'Date of Birth',
  required: true,
}
```

**Props (Material-Specific):**

| Prop              | Type                                | Default     | Description                 |
| ----------------- | ----------------------------------- | ----------- | --------------------------- |
| `appearance`      | `'fill' \| 'outline'`               | `'outline'` | Visual style                |
| `color`           | `'primary' \| 'accent' \| 'warn'`   | `'primary'` | Material theme color        |
| `startView`       | `'month' \| 'year' \| 'multi-year'` | `'month'`   | Initial calendar view       |
| `touchUi`         | `boolean`                           | `false`     | Touch-optimized calendar UI |
| `subscriptSizing` | `'fixed' \| 'dynamic'`              | `'fixed'`   | Error/hint sizing           |
| `hint`            | `string`                            | -           | Help text below field       |

---

### Buttons & Actions

Action buttons provide form submission and navigation controls.

#### Submit Button

Form submission button that's automatically disabled when the form is invalid.

**Live Demo:**

<iframe src="http://localhost:4201/#/examples/button" class="example-frame" title="Button Demo"></iframe>

**Basic Usage:**

```typescript
{
  type: 'submit',
  key: 'submit',
  label: 'Create Account',
  props: {
    color: 'primary',
  },
}
```

The submit button automatically:

- Disables when the form is invalid
- Emits a `SubmitEvent` when clicked
- Validates all fields before submission

**Props:**

| Prop    | Type                              | Default     | Description          |
| ------- | --------------------------------- | ----------- | -------------------- |
| `color` | `'primary' \| 'accent' \| 'warn'` | `'primary'` | Material theme color |

#### Navigation Buttons

Navigation buttons for multi-step (paged) forms.

**Basic Usage:**

```typescript
{
  fields: [
    {
      key: 'step1',
      type: 'page',
      fields: [
        { key: 'step1Title', type: 'text', label: 'Step 1', props: { elementType: 'h3' } },
        { key: 'name', type: 'input', value: '', label: 'Name', required: true },
        {
          type: 'next',
          key: 'next',
          label: 'Continue',
          props: { color: 'primary' },
        },
      ],
    },
    {
      key: 'step2',
      type: 'page',
      fields: [
        { key: 'step2Title', type: 'text', label: 'Step 2', props: { elementType: 'h3' } },
        { key: 'email', type: 'input', value: '', label: 'Email', required: true },
        { type: 'previous', key: 'back', label: 'Back' },
        { type: 'submit', key: 'submit', label: 'Submit', props: { color: 'primary' } },
      ],
    },
  ],
}
```

**Button Types:**

- **Next Button**: Navigates to the next page. Automatically disabled when current page has validation errors.
- **Previous Button**: Navigates to the previous page. Always enabled to allow users to go back.

---

## Theming

Material components automatically inherit your Angular Material theme. Customize colors using Material's theming system:

```typescript
// Field with custom color
{
  key: 'agreeToTerms',
  type: 'checkbox',
  label: 'I agree to the terms and conditions',
  props: {
    color: 'accent', // 'primary' | 'accent' | 'warn'
  },
}
```

## Common Props

All Material fields support these common properties:

| Prop              | Type                              | Default     | Description                       |
| ----------------- | --------------------------------- | ----------- | --------------------------------- |
| `appearance`      | `'fill' \| 'outline'`             | `'fill'`    | Form field appearance style       |
| `color`           | `'primary' \| 'accent' \| 'warn'` | `'primary'` | Theme color                       |
| `hint`            | `string`                          | -           | Helper text displayed below field |
| `subscriptSizing` | `'fixed' \| 'dynamic'`            | `'fixed'`   | Error/hint spacing behavior       |

## Accessibility

All Material Design components include:

- Proper ARIA attributes
- Keyboard navigation support
- Screen reader compatibility
- Focus management
- Error announcements

## Next Steps

- Check out [Examples & Patterns](../../../examples/) for real-world use cases
- Learn about [Validation](../../validation/basics/) for form validation
- See [Type Safety](../../advanced/type-safety/basics/) for TypeScript integration
- Explore [Conditional Logic](../../dynamic-behavior/conditional-logic/overview/) for dynamic field behavior

--- ui-libs-integrations/primeng ---

Beautiful PrimeNG field components for ng-forge dynamic forms, built with the PrimeNG design system.

---

## Installation

Install the package and its peer dependencies:

```bash group="install" name="npm"
npm install @ng-forge/dynamic-forms @ng-forge/dynamic-forms-primeng primeng primeicons
```

```bash group="install" name="yarn"
yarn add @ng-forge/dynamic-forms @ng-forge/dynamic-forms-primeng primeng primeicons
```

```bash group="install" name="pnpm"
pnpm add @ng-forge/dynamic-forms @ng-forge/dynamic-forms-primeng primeng primeicons
```

## Quick Start

### 1. Configure Providers

Add PrimeNG field types to your application:

```typescript
// app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideDynamicForm } from '@ng-forge/dynamic-forms';
import { withPrimeNGFields } from '@ng-forge/dynamic-forms-primeng';
import { providePrimeNG } from 'primeng/config';
import Aura from '@primeuix/themes/aura';

export const appConfig: ApplicationConfig = {
  providers: [
    provideDynamicForm(...withPrimeNGFields()),
    providePrimeNG({
      theme: {
        preset: Aura,
      },
    }),
  ],
};
```

### 2. Import Theme & Styles

Add PrimeNG icons to your styles:

```scss name="styles.scss"
@import 'primeicons/primeicons.css';
```

PrimeNG theming is now configured via the provider (see step 1). You can customize the theme preset:

```typescript
import Aura from '@primeuix/themes/aura';
import Lara from '@primeuix/themes/lara';
import Nora from '@primeuix/themes/nora';

providePrimeNG({
  theme: {
    preset: Aura, // or Lara, Nora, etc.
  },
});
```

### 3. Create Your First Form

```typescript
import { Component, signal } from '@angular/core';
import { JsonPipe } from '@angular/common';
import { DynamicForm, type FormConfig } from '@ng-forge/dynamic-forms';

@Component({
  selector: 'app-contact-form',
  imports: [DynamicForm, JsonPipe],
  template: `
    <form [dynamic-form]="config" [(value)]="formValue"></form>
    @let value = formValue();
    <pre>{% raw %}{{ value | json }}{% endraw %}</pre>
  `,
})
export class ContactFormComponent {
  formValue = signal({});

  config = {
    fields: [
      {
        key: 'name',
        type: 'input',
        value: '',
        label: 'Full Name',
        required: true,
        props: {
          variant: 'outlined',
        },
      },
      {
        key: 'email',
        type: 'input',
        value: '',
        label: 'Email',
        required: true,
        email: true,
        props: {
          type: 'email',
          variant: 'outlined',
        },
      },
      {
        key: 'message',
        type: 'textarea',
        value: '',
        label: 'Message',
        required: true,
        minLength: 10,
        props: {
          rows: 4,
        },
      },
      {
        type: 'submit',
        key: 'submit',
        label: 'Send Message',
        props: {
          severity: 'primary',
        },
      },
    ],
  } as const satisfies FormConfig;
}
```

## Configuration Options

Configure default props at the library, form, or field level.

Use `PrimeFormConfig` for type-safe form configurations with PrimeNG-specific props.

### Available Options

| Option     | Type                                                                                            | Default      | Description            |
| ---------- | ----------------------------------------------------------------------------------------------- | ------------ | ---------------------- |
| `size`     | `'small' \| 'large'`                                                                            | -            | Component size         |
| `variant`  | `'outlined' \| 'filled'`                                                                        | `'outlined'` | Input visual style     |
| `severity` | `'primary' \| 'secondary' \| 'success' \| 'info' \| 'warn' \| 'danger' \| 'help' \| 'contrast'` | `'primary'`  | Button color           |
| `text`     | `boolean`                                                                                       | `false`      | Text-only button style |
| `outlined` | `boolean`                                                                                       | `false`      | Outlined button style  |
| `raised`   | `boolean`                                                                                       | `false`      | Raised button style    |
| `rounded`  | `boolean`                                                                                       | `false`      | Rounded button style   |

---

## Type Augmentation

Importing this package automatically extends `@ng-forge/dynamic-forms` with PrimeNG-specific field types via TypeScript module augmentation. If you need type safety in a file without importing specific exports, use a bare import:

```typescript
import '@ng-forge/dynamic-forms-primeng';
```

---

## Complete Form Example

Here's a full registration form showcasing multiple PrimeNG field types:

<iframe src="http://localhost:4202/#/examples/complete-form" class="example-frame" title="Complete Form Demo"></iframe>

This example demonstrates:

- Text inputs with validation
- Select dropdowns with search
- Checkboxes and toggles
- Radio buttons
- Date pickers
- Sliders
- Multi-checkbox selections
- Form submission

---

## Field Types Reference

Complete reference for all PrimeNG field types with comprehensive validation, accessibility features, and PrimeNG styling.

### Text Input Fields

Text input fields provide user-friendly text entry with PrimeNG styling.

#### Input

Text input field with HTML5 type support and PrimeNG styling.

**Live Demo:**

<iframe src="http://localhost:4202/#/examples/input" class="example-frame" title="Input Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'email',
  type: 'input',
  value: '',
  label: 'Email Address',
  required: true,
  email: true,
  props: {
    type: 'email',
    variant: 'outlined',
    placeholder: 'Enter your email',
    hint: 'We will never share your email',
  },
}
```

**Field Properties:**

| Property      | Type               | Description                        |
| ------------- | ------------------ | ---------------------------------- |
| `key`         | `string`           | Unique field identifier (required) |
| `type`        | `'input'`          | Field type (required)              |
| `value`       | `string \| number` | Initial value                      |
| `label`       | `string`           | Field label                        |
| `placeholder` | `string`           | Placeholder text                   |
| `required`    | `boolean`          | Mark field as required             |
| `disabled`    | `boolean`          | Disable the field                  |
| `readonly`    | `boolean`          | Make field read-only               |

**Validation Properties:**

| Property    | Type               | Description                       |
| ----------- | ------------------ | --------------------------------- |
| `email`     | `boolean`          | Email format validation           |
| `minLength` | `number`           | Minimum character length          |
| `maxLength` | `number`           | Maximum character length          |
| `min`       | `number`           | Minimum value (for number inputs) |
| `max`       | `number`           | Maximum value (for number inputs) |
| `pattern`   | `string \| RegExp` | RegEx pattern validation          |

**Props (PrimeNG-Specific):**

| Prop         | Type                                                            | Default      | Description             |
| ------------ | --------------------------------------------------------------- | ------------ | ----------------------- |
| `type`       | `'text' \| 'email' \| 'password' \| 'number' \| 'tel' \| 'url'` | `'text'`     | HTML input type         |
| `variant`    | `'outlined' \| 'filled'`                                        | `'outlined'` | Visual style            |
| `size`       | `'small' \| 'large'`                                            | -            | Input size              |
| `hint`       | `string`                                                        | -            | Helper text below input |
| `styleClass` | `string`                                                        | -            | CSS class for input     |

#### Textarea

Multi-line text input field with PrimeNG styling and auto-resize support.

**Live Demo:**

<iframe src="http://localhost:4202/#/examples/textarea" class="example-frame" title="Textarea Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'bio',
  type: 'textarea',
  value: '',
  label: 'Biography',
  placeholder: 'Tell us about yourself',
  required: true,
  minLength: 50,
  maxLength: 500,
  props: {
    rows: 6,
    autoResize: true,
    hint: 'Maximum 500 characters',
  },
}
```

**Props (PrimeNG-Specific):**

| Prop         | Type      | Default | Description                  |
| ------------ | --------- | ------- | ---------------------------- |
| `rows`       | `number`  | `4`     | Number of visible rows       |
| `autoResize` | `boolean` | `false` | Auto-resize based on content |
| `maxlength`  | `number`  | -       | Maximum character limit      |
| `hint`       | `string`  | -       | Help text below field        |
| `styleClass` | `string`  | -       | CSS class for textarea       |

---

### Selection Fields

Selection fields enable users to choose from predefined options.

#### Select

Dropdown selection field with search capability and virtual scrolling support.

**Live Demo:**

<iframe src="http://localhost:4202/#/examples/select" class="example-frame" title="Select Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'country',
  type: 'select',
  value: '',
  label: 'Country',
  required: true,
  options: [
    { value: 'us', label: 'United States' },
    { value: 'uk', label: 'United Kingdom' },
    { value: 'ca', label: 'Canada' },
    { value: 'au', label: 'Australia' },
  ],
  props: {
    filter: true,
    showClear: true,
    placeholder: 'Select a country',
  },
}
```

**Props (PrimeNG-Specific):**

| Prop          | Type      | Default | Description               |
| ------------- | --------- | ------- | ------------------------- |
| `filter`      | `boolean` | `false` | Enable search/filter      |
| `showClear`   | `boolean` | `false` | Show clear button         |
| `multiple`    | `boolean` | `false` | Enable multiple selection |
| `placeholder` | `string`  | -       | Dropdown placeholder text |
| `hint`        | `string`  | -       | Help text below select    |
| `styleClass`  | `string`  | -       | CSS class for dropdown    |

#### Radio

Radio button group for selecting a single option.

**Live Demo:**

<iframe src="http://localhost:4202/#/examples/radio" class="example-frame" title="Radio Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'size',
  type: 'radio',
  value: '',
  label: 'Select Size',
  required: true,
  options: [
    { value: 'small', label: 'Small' },
    { value: 'medium', label: 'Medium' },
    { value: 'large', label: 'Large' },
  ],
  props: {
    hint: 'Choose your preferred size',
  },
}
```

**Props (PrimeNG-Specific):**

| Prop         | Type     | Default | Description                     |
| ------------ | -------- | ------- | ------------------------------- |
| `hint`       | `string` | -       | Help text displayed below group |
| `styleClass` | `string` | -       | CSS class for radio group       |

#### Checkbox

Boolean checkbox control for single true/false selections.

**Live Demo:**

<iframe src="http://localhost:4202/#/examples/checkbox" class="example-frame" title="Checkbox Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'terms',
  type: 'checkbox',
  value: false,
  label: 'I accept the terms and conditions',
  required: true,
  props: {
    binary: true,
  },
}
```

**Props (PrimeNG-Specific):**

| Prop         | Type      | Default | Description                   |
| ------------ | --------- | ------- | ----------------------------- |
| `binary`     | `boolean` | `true`  | Treat as boolean (true/false) |
| `trueValue`  | `any`     | `true`  | Value when checked            |
| `falseValue` | `any`     | `false` | Value when unchecked          |
| `styleClass` | `string`  | -       | CSS class for checkbox        |

#### Multi-Checkbox

Multiple checkbox selection field for choosing multiple options.

**Live Demo:**

<iframe src="http://localhost:4202/#/examples/multi-checkbox" class="example-frame" title="Multi-Checkbox Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'interests',
  type: 'multi-checkbox',
  value: [],
  label: 'Select Your Interests',
  required: true,
  options: [
    { value: 'sports', label: 'Sports' },
    { value: 'music', label: 'Music' },
    { value: 'reading', label: 'Reading' },
    { value: 'travel', label: 'Travel' },
    { value: 'cooking', label: 'Cooking' },
  ],
  props: {
    hint: 'Select all that apply',
  },
}
```

**Props (PrimeNG-Specific):**

| Prop         | Type     | Default | Description                     |
| ------------ | -------- | ------- | ------------------------------- |
| `hint`       | `string` | -       | Help text displayed below group |
| `styleClass` | `string` | -       | CSS class for checkbox group    |

---

### Interactive Fields

Interactive fields provide advanced user input controls.

#### Toggle

Slide toggle switch (InputSwitch) for boolean on/off selections.

**Live Demo:**

<iframe src="http://localhost:4202/#/examples/toggle" class="example-frame" title="Toggle Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'notifications',
  type: 'toggle',
  value: false,
  label: 'Enable email notifications',
  props: {
    hint: 'Receive updates via email',
  },
}
```

**Props (PrimeNG-Specific):**

| Prop         | Type     | Default | Description            |
| ------------ | -------- | ------- | ---------------------- |
| `hint`       | `string` | -       | Help text below toggle |
| `styleClass` | `string` | -       | CSS class for toggle   |

#### Slider

Numeric slider control for selecting values from a range.

**Live Demo:**

<iframe src="http://localhost:4202/#/examples/slider" class="example-frame" title="Slider Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'volume',
  type: 'slider',
  value: 50,
  label: 'Volume',
  minValue: 0,
  maxValue: 100,
  step: 5,
  props: {
    hint: 'Adjust audio volume',
  },
}
```

**Field Properties:**

| Property   | Type     | Default | Description    |
| ---------- | -------- | ------- | -------------- |
| `minValue` | `number` | `0`     | Minimum value  |
| `maxValue` | `number` | `100`   | Maximum value  |
| `step`     | `number` | `1`     | Increment step |

**Props (PrimeNG-Specific):**

| Prop          | Type                         | Default        | Description                 |
| ------------- | ---------------------------- | -------------- | --------------------------- |
| `orientation` | `'horizontal' \| 'vertical'` | `'horizontal'` | Slider orientation          |
| `range`       | `boolean`                    | `false`        | Enable range mode (2 knobs) |
| `hint`        | `string`                     | -              | Help text below slider      |
| `styleClass`  | `string`                     | -              | CSS class for slider        |

#### Datepicker

Date selection field with calendar popup (p-calendar).

**Live Demo:**

<iframe src="http://localhost:4202/#/examples/datepicker" class="example-frame" title="Datepicker Demo"></iframe>

**Basic Usage:**

```typescript
{
  key: 'birthdate',
  type: 'datepicker',
  value: null,
  label: 'Date of Birth',
  required: true,
  minDate: new Date('1900-01-01'),
  maxDate: new Date(),
  props: {
    dateFormat: 'mm/dd/yy',
    showIcon: true,
    showButtonBar: true,
    hint: 'Select your birth date',
  },
}
```

**Field Properties:**

| Property  | Type                     | Description             |
| --------- | ------------------------ | ----------------------- |
| `minDate` | `Date \| string \| null` | Minimum selectable date |
| `maxDate` | `Date \| string \| null` | Maximum selectable date |

**Props (PrimeNG-Specific):**

| Prop            | Type                                | Default      | Description              |
| --------------- | ----------------------------------- | ------------ | ------------------------ |
| `dateFormat`    | `string`                            | `'mm/dd/yy'` | Date format string       |
| `showIcon`      | `boolean`                           | `false`      | Show calendar icon       |
| `showButtonBar` | `boolean`                           | `false`      | Show today/clear buttons |
| `inline`        | `boolean`                           | `false`      | Display calendar inline  |
| `selectionMode` | `'single' \| 'multiple' \| 'range'` | `'single'`   | Date selection mode      |
| `view`          | `'date' \| 'month' \| 'year'`       | `'date'`     | Initial calendar view    |
| `touchUI`       | `boolean`                           | `false`      | Touch-optimized UI       |
| `hint`          | `string`                            | -            | Help text below field    |
| `styleClass`    | `string`                            | -            | CSS class for datepicker |

---

### Buttons & Actions

Action buttons provide form submission and navigation controls.

#### Submit Button

Form submission button that's automatically disabled when the form is invalid.

**Live Demo:**

<iframe src="http://localhost:4202/#/examples/button" class="example-frame" title="Button Demo"></iframe>

**Basic Usage:**

```typescript
{
  type: 'submit',
  key: 'submit',
  label: 'Create Account',
  props: {
    severity: 'primary',
    icon: 'pi pi-check',
    iconPos: 'right',
  },
}
```

The submit button automatically:

- Disables when the form is invalid
- Emits a `SubmitEvent` when clicked
- Validates all fields before submission

**Props:**

| Prop       | Type                                                                                            | Default     | Description     |
| ---------- | ----------------------------------------------------------------------------------------------- | ----------- | --------------- |
| `severity` | `'primary' \| 'secondary' \| 'success' \| 'info' \| 'warn' \| 'help' \| 'danger' \| 'contrast'` | `'primary'` | Button theme    |
| `outlined` | `boolean`                                                                                       | `false`     | Outlined style  |
| `text`     | `boolean`                                                                                       | `false`     | Text-only style |
| `raised`   | `boolean`                                                                                       | `false`     | Raised style    |
| `rounded`  | `boolean`                                                                                       | `false`     | Rounded style   |
| `icon`     | `string`                                                                                        | -           | Icon class      |
| `iconPos`  | `'left' \| 'right' \| 'top' \| 'bottom'`                                                        | `'left'`    | Icon position   |

#### Navigation Buttons

Navigation buttons for multi-step (paged) forms.

**Basic Usage:**

```typescript
{
  fields: [
    {
      key: 'step1',
      type: 'page',
      fields: [
        { key: 'step1Title', type: 'text', label: 'Personal Information', props: { elementType: 'h3' } },
        { key: 'step1Desc', type: 'text', label: 'Tell us about yourself' },
        { key: 'firstName', type: 'input', value: '', label: 'First Name', required: true },
        { key: 'lastName', type: 'input', value: '', label: 'Last Name', required: true },
        {
          type: 'next',
          key: 'next',
          label: 'Continue',
          props: { severity: 'primary', icon: 'pi pi-arrow-right', iconPos: 'right' },
        },
      ],
    },
    {
      key: 'step2',
      type: 'page',
      fields: [
        { key: 'step2Title', type: 'text', label: 'Contact Information', props: { elementType: 'h3' } },
        { key: 'email', type: 'input', value: '', label: 'Email', required: true, email: true },
        { key: 'phone', type: 'input', value: '', label: 'Phone', props: { type: 'tel' } },
        {
          key: 'navigation',
          type: 'row',
          fields: [
            { type: 'previous', key: 'back', label: 'Back', props: { icon: 'pi pi-arrow-left' } },
            { type: 'submit', key: 'submit', label: 'Complete', props: { severity: 'primary' } },
          ],
        },
      ],
    },
  ],
}
```

**Button Types:**

- **Next Button**: Navigates to the next page. Automatically disabled when current page has validation errors.
- **Previous Button**: Navigates to the previous page. Always enabled to allow users to go back.

#### Custom Action Button

Generic button for custom events. Use this for application-specific actions.

**Basic Usage:**

```typescript
import { FormEvent } from '@ng-forge/dynamic-forms';

// Define your custom event
class SaveDraftEvent implements FormEvent {
  readonly type = 'save-draft' as const;
}

const config = {
  fields: [
    { key: 'title', type: 'input', value: '', label: 'Document Title', required: true },
    { key: 'content', type: 'textarea', value: '', label: 'Content' },
    {
      key: 'actions',
      type: 'row',
      fields: [
        {
          type: 'button',
          key: 'saveDraft',
          label: 'Save as Draft',
          event: SaveDraftEvent,
          props: {
            severity: 'secondary',
            icon: 'pi pi-save',
          },
        },
        {
          type: 'submit',
          key: 'publish',
          label: 'Publish',
          props: {
            severity: 'primary',
            icon: 'pi pi-upload',
          },
        },
      ],
    },
  ],
} as const satisfies FormConfig;
```

Then listen for the event in your component via the `(events)` output:

```typescript
import { Component } from '@angular/core';
import { DynamicForm, FormEvent } from '@ng-forge/dynamic-forms';

@Component({
  imports: [DynamicForm],
  template: `<form [dynamic-form]="config" (events)="onEvent($event)"></form>`,
})
class MyComponent {
  onEvent(event: FormEvent) {
    if (event.type === 'SaveDraft') {
      console.log('Save draft clicked');
      // Handle draft saving logic
    }
  }
}
```

> **Note:** Do not inject `EventBus` in a host component — it is scoped to the form's DI tree and injecting it outside gives a disconnected instance. Use the `(events)` output to observe events, or `EventDispatcher` to dispatch events into the form.

---

## Theming

PrimeNG supports extensive theming through CSS variables and theme presets. Customize your theme using the provider:

```typescript
import { providePrimeNG } from 'primeng/config';
import Aura from '@primeuix/themes/aura';
import Lara from '@primeuix/themes/lara';
import Nora from '@primeuix/themes/nora';

providePrimeNG({
  theme: {
    preset: Aura, // or Lara, Nora, etc.
    options: {
      darkModeSelector: '.dark-mode',
    },
  },
});
```

### Severity Colors

Control button and component colors using the `severity` prop:

```typescript
{
  type: 'submit',
  key: 'submit',
  label: 'Submit',
  props: {
    severity: 'primary', // 'primary' | 'secondary' | 'success' | 'info' | 'warn' | 'help' | 'danger' | 'contrast'
  },
}
```

### Size Variants

Adjust component sizes using the `size` prop:

```typescript
{
  key: 'email',
  type: 'input',
  label: 'Email',
  props: {
    size: 'small', // 'small' | 'large' | undefined (default/medium)
  },
}
```

### Custom Styling

Add custom CSS classes to any component:

```typescript
{
  key: 'email',
  type: 'input',
  label: 'Email',
  props: {
    styleClass: 'my-custom-input',
  },
}
```

For more information, see the [PrimeNG Theming Guide](https://primeng.org/theming).

## Accessibility

All PrimeNG components include:

- Proper ARIA attributes
- Keyboard navigation support
- Screen reader compatibility
- Focus management
- Error announcements

PrimeNG components are designed with accessibility in mind and follow WAI-ARIA standards.

## Next Steps

- Check out [Examples & Patterns](../../../examples/) for real-world use cases
- Learn about [Validation](../../validation/basics/) for form validation
- See [Type Safety](../../advanced/type-safety/basics/) for TypeScript integration
- Explore [Conditional Logic](../../dynamic-behavior/conditional-logic/overview/) for dynamic field behavior

--- validation/advanced ---

Advanced validation techniques including conditional validators, dynamic values, and cross-field validation.

## Validators Array

The `validators` array provides fine-grained control over validation behavior:

```typescript
{
  key: 'discount',
  type: 'input',
  value: 0,
  validators: [{
    type: 'required',
  }, {
    type: 'min',
    value: 0,
  }, {
    type: 'max',
    value: 100,
    when: {
      type: 'fieldValue',
      fieldPath: 'discountType',
      operator: 'equals',
      value: 'percentage',
    },
  }],
}
```

## Conditional Validators

Activate validators only when conditions are met.

### Based on Field Value

```typescript
{
  key: 'discount',
  type: 'input',
  value: 0,
  validators: [{
    type: 'max',
    value: 100,
    when: {
      type: 'fieldValue',
      fieldPath: 'discountType',
      operator: 'equals',
      value: 'percentage',
    },
  }],
}
```

The max validator only applies when `discountType === 'percentage'`.

### Based on Form Value

Validate against the entire form state:

```typescript
{
  key: 'endDate',
  type: 'datepicker',
  value: null,
  validators: [{
    type: 'required',
    when: {
      type: 'formValue',
      expression: 'formValue.hasEndDate === true',
    },
  }],
}
```

## Dynamic Validator Values

Use JavaScript expressions for dynamic validation:

```typescript
{
  key: 'quantity',
  type: 'input',
  value: 0,
  validators: [{
    type: 'max',
    expression: 'formValue.maxQuantity || 100',
  }],
}
```

The max value comes from `formValue.maxQuantity`, defaulting to 100.

## Multiple Conditional Validators

Combine multiple validators with different conditions:

```typescript
{
  key: 'customerId',
  type: 'input',
  value: '',
  validators: [
    {
      type: 'required',
      when: {
        type: 'fieldValue',
        fieldPath: 'customerType',
        operator: 'equals',
        value: 'existing',
      },
    },
    {
      type: 'pattern',
      value: '^[A-Z0-9]{8}$',
      when: {
        type: 'fieldValue',
        fieldPath: 'customerType',
        operator: 'equals',
        value: 'existing',
      },
    },
  ],
}
```

## Cross-Field Validation

For validators that need to compare multiple fields (like password confirmation or date ranges), use custom validators.

**Quick example using expressions:**

```typescript
{
  key: 'confirmPassword',
  type: 'input',
  validators: [{
    type: 'custom',
    expression: 'fieldValue === formValue.password',
    kind: 'passwordMismatch',
  }],
  validationMessages: {
    passwordMismatch: 'Passwords must match',
  },
}
```

See **[Custom Validators](../custom-validators)** for complete documentation on:

- Expression-based validators (simple, inline expressions)
- Function-based validators (complex, reusable logic)
- Cross-field validation patterns
- FieldContext API for accessing other field values
- Async validators and HTTP validators

## Complex Conditional Logic

Combine multiple conditions with AND/OR logic:

```typescript
{
  key: 'businessEmail',
  type: 'input',
  value: '',
  validators: [{
    type: 'required',
    when: {
      type: 'and',
      conditions: [
        {
          type: 'fieldValue',
          fieldPath: 'accountType',
          operator: 'equals',
          value: 'business',
        },
        {
          type: 'fieldValue',
          fieldPath: 'hasTeam',
          operator: 'equals',
          value: true,
        },
      ],
    },
  }],
}
```

## Complete Examples

### Conditional Business Form

```typescript
const config = {
  fields: [
    {
      key: 'accountType',
      type: 'radio',
      value: 'personal',
      options: [
        { value: 'personal', label: 'Personal' },
        { value: 'business', label: 'Business' },
      ],
    },
    {
      key: 'companyName',
      type: 'input',
      value: '',
      validators: [
        {
          type: 'required',
          when: {
            type: 'fieldValue',
            fieldPath: 'accountType',
            operator: 'equals',
            value: 'business',
          },
        },
        {
          type: 'minLength',
          value: 2,
          when: {
            type: 'fieldValue',
            fieldPath: 'accountType',
            operator: 'equals',
            value: 'business',
          },
        },
      ],
    },
    {
      key: 'taxId',
      type: 'input',
      value: '',
      validators: [
        {
          type: 'required',
          when: {
            type: 'fieldValue',
            fieldPath: 'accountType',
            operator: 'equals',
            value: 'business',
          },
        },
        {
          type: 'pattern',
          value: '^[0-9]{2}-[0-9]{7}$',
          when: {
            type: 'fieldValue',
            fieldPath: 'accountType',
            operator: 'equals',
            value: 'business',
          },
        },
      ],
    },
  ],
} as const satisfies FormConfig;
```

### Dynamic Validation Form

Form where validation rules change based on selections:

```typescript
const config = {
  fields: [
    {
      key: 'discountType',
      type: 'select',
      value: '',
      options: [
        { value: 'percentage', label: 'Percentage' },
        { value: 'fixed', label: 'Fixed Amount' },
      ],
    },
    {
      key: 'discountValue',
      type: 'input',
      value: 0,
      required: true,
      validators: [
        {
          type: 'min',
          value: 0,
        },
        {
          type: 'max',
          value: 100,
          when: {
            type: 'fieldValue',
            fieldPath: 'discountType',
            operator: 'equals',
            value: 'percentage',
          },
        },
        {
          type: 'max',
          expression: 'formValue.orderTotal || 1000',
          when: {
            type: 'fieldValue',
            fieldPath: 'discountType',
            operator: 'equals',
            value: 'fixed',
          },
        },
      ],
      props: { type: 'number' },
    },
  ],
} as const satisfies FormConfig;
```

## Best Practices

**Use shorthand when possible:**

```typescript
// ✅ Good - Simple and clear
{ required: true, email: true }

// ❌ Avoid - Unnecessarily complex
{ validators: [{ type: 'required' }, { type: 'email' }] }
```

**Combine shorthand with validators array:**

```typescript
// ✅ Good - Best of both
{
  required: true,
  email: true,
  validators: [{
    type: 'pattern',
    value: '@company\\.com$',
    when: { /* condition */ },
  }],
}
```

**Keep conditions simple:**

```typescript
// ✅ Good - Easy to understand
when: {
  type: 'fieldValue',
  fieldPath: 'accountType',
  operator: 'equals',
  value: 'business',
}

// ❌ Avoid - Overly complex
when: {
  type: 'and',
  conditions: [/* 5 nested conditions */],
}
```

## Related

- **[Validation Basics](../basics/)** - Shorthand validators
- **[Validation Reference](../reference/)** - Complete API
- **[Conditional Logic](../../dynamic-behavior/conditional-logic/overview/)** - Field behavior changes
- **[Examples](../../examples/)** - Real-world patterns

--- validation/basics ---

Dynamic Forms provides powerful, type-safe validation that integrates directly with Angular's signal forms. Start with simple shorthand validators and progress to advanced conditional validation as your needs grow.

## Signal Forms Integration

Dynamic Forms validation maps directly to Angular's signal forms validators:

```typescript
// Your configuration
{ key: 'email', type: 'input', value: '', required: true, email: true }

// Becomes
import { required, email } from '@angular/forms/signals';
required(fieldPath);
email(fieldPath);
```

This tight integration means:

- **Zero overhead** - Direct signal forms API usage
- **Familiar patterns** - Same validators you know
- **Full type safety** - TypeScript inference throughout

## Which Validation Approach Should I Use?

Choose based on your validation complexity:

### Shorthand Validators

**Use when:** Simple, always-active validation

```typescript
{
  key: 'email',
  type: 'input',
  value: '',
  required: true,
  email: true,
  minLength: 5,
}
```

**Benefits:**

- Concise and readable
- Perfect for common validations
- Type-safe with full IntelliSense

### Validators Array

**Use when:** Conditional validation or custom messages

```typescript
{
  key: 'discount',
  type: 'input',
  value: 0,
  validators: [{
    type: 'max',
    value: 100,
    when: {
      type: 'fieldValue',
      fieldPath: 'discountType',
      operator: 'equals',
      value: 'percentage',
    },
  }],
}
```

**Benefits:**

- Conditional validation
- Custom error messages
- Dynamic validator values

### Logic Array

**Use when:** Changing field behavior (hidden/required/disabled)

```typescript
{
  key: 'taxId',
  type: 'input',
  value: '',
  logic: [{
    type: 'required',
    condition: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'equals',
      value: 'business',
    },
  }],
}
```

**Benefits:**

- Dynamic field behavior
- Conditional required fields
- See [Conditional Logic](../../dynamic-behavior/conditional-logic/overview/) for details

## Shorthand Validators

### required

Mark a field as mandatory:

```typescript
{
  key: 'name',
  type: 'input',
  value: '',
  required: true,
}
```

### email

Validate email format:

```typescript
{
  key: 'email',
  type: 'input',
  value: '',
  required: true,
  email: true,
}
```

### minLength / maxLength

Validate string length:

```typescript
{
  key: 'username',
  type: 'input',
  value: '',
  minLength: 3,
  maxLength: 20,
}
```

### min / max

Validate numeric range:

```typescript
{
  key: 'age',
  type: 'input',
  value: null,
  min: 18,
  max: 120,
  props: { type: 'number' },
}
```

### pattern

Validate with regular expressions:

```typescript
{
  key: 'zipCode',
  type: 'input',
  value: '',
  pattern: '^[0-9]{5}$', // 5-digit US ZIP code
}
```

## Combining Validators

Stack multiple validators on the same field:

```typescript
{
  key: 'password',
  type: 'input',
  value: '',
  required: true,
  minLength: 8,
  maxLength: 128,
  pattern: '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)',
  props: { type: 'password' },
}
```

All validators must pass for the field to be valid.

## Validation Messages

### Default Messages

Each validator has a built-in error message:

```typescript
{
  required: true;
} // → "This field is required"
{
  email: true;
} // → "Please enter a valid email address"
{
  minLength: 8;
} // → "Minimum length is 8 characters"
```

### Custom Messages

Override default messages for better UX:

```typescript
{
  key: 'email',
  type: 'input',
  value: '',
  required: true,
  email: true,
  validationMessages: {
    required: 'Email address is required',
    email: 'Please enter a valid email address',
  },
}
```

### Dynamic Messages

Use signals or observables for i18n:

```typescript
{
  key: 'email',
  type: 'input',
  value: '',
  required: true,
  validationMessages: {
    required: this.transloco.selectTranslate('validation.required'),
    email: this.transloco.selectTranslate('validation.email'),
  },
}
```

## Quick Examples

### User Registration

```typescript
const config = {
  fields: [
    {
      key: 'username',
      type: 'input',
      value: '',
      required: true,
      minLength: 3,
      maxLength: 20,
      pattern: '^[a-zA-Z0-9_]+$',
      validationMessages: {
        required: 'Username is required',
        minLength: 'Username must be at least 3 characters',
        maxLength: 'Username cannot exceed 20 characters',
        pattern: 'Username can only contain letters, numbers, and underscores',
      },
    },
    {
      key: 'email',
      type: 'input',
      value: '',
      required: true,
      email: true,
      validationMessages: {
        required: 'Email is required',
        email: 'Please enter a valid email address',
      },
    },
    {
      key: 'password',
      type: 'input',
      value: '',
      required: true,
      minLength: 8,
      pattern: '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)',
      validationMessages: {
        required: 'Password is required',
        minLength: 'Password must be at least 8 characters',
        pattern: 'Password must include uppercase, lowercase, and a number',
      },
      props: { type: 'password' },
    },
  ],
} as const satisfies FormConfig;
```

## When Validation Runs

Validation occurs:

- **On blur** - When user leaves a field
- **On change** - As user types (after first blur)
- **On submit** - When form is submitted

Invalid fields prevent form submission and display error messages.

## Next Steps

- **[Validation Advanced](../advanced/)** - Conditional validation, dynamic values
- **[Validation Reference](../reference/)** - Complete validator API
- **[Conditional Logic](../../dynamic-behavior/conditional-logic/overview/)** - Dynamic field behavior
- **[Examples](../../examples/)** - Real-world validation patterns

--- validation/custom-validators ---

Custom validation functions for complex validation logic that goes beyond built-in validators.

## Overview

ng-forge supports four types of custom validators:

1. **Declarative HTTP** (`type: 'http'`) - Validate against an HTTP endpoint with no function registration
2. **CustomValidator** - Synchronous validators with access to FieldContext
3. **AsyncCustomValidator** - Async validators using Angular's resource API
4. **HttpCustomValidator** (function-based) - HTTP validators with full programmatic control

**Key Principle:** Validators should focus on validation logic, NOT presentation. Return only the error `kind` and configure messages at field level for proper i18n support.

## Live Demo

Try the interactive example below to see both expression-based and function-based validators in action:

<iframe src="http://localhost:4201/#/examples/expression-validators-demo" class="example-frame" title="Expression Validators Demo"></iframe>

## Message Resolution (STRICT)

All error messages MUST be explicitly configured. The framework enforces this strictly:

1. **Field-level `validationMessages[kind]`** (highest priority - per-field customization)
2. **Form-level `defaultValidationMessages[kind]`** (fallback for common messages)
3. **No message configured = Console warning + error NOT displayed**

**Important:** Validator-returned messages are NOT used as fallbacks. This enforces proper separation of concerns and i18n patterns.

You can define messages at the form level for common validation errors:

```typescript
{
  defaultValidationMessages: {
    noSpaces: 'Spaces are not allowed',
    passwordMismatch: 'Passwords must match'
  },
  fields: [/* ... */]
}
```

## Two Validator Patterns

ng-forge supports two patterns for custom validators:

1. **Function-based** - Register reusable validator functions (best for complex logic, reusability)
2. **Expression-based** - Inline JavaScript expressions (best for simple, one-off validations)

## Expression-Based Validators

For simple validation logic, use inline JavaScript expressions without registering functions.

### Basic Example

```typescript
{
  key: 'confirmPassword',
  type: 'input',
  value: '',
  validators: [{
    type: 'custom',
    expression: 'fieldValue === formValue.password',
    kind: 'passwordMismatch',
  }],
  validationMessages: {
    passwordMismatch: 'Passwords must match',
  },
}
```

**How it works:**

- `fieldValue` - Current field's value
- `formValue` - Entire form value object
- Expression returns `true` = validation passes
- Expression returns `false` = validation fails with the specified `kind`

### Available Context

Expression-based validators have access to:

- **`fieldValue`** - Current field value
- **`formValue`** - Complete form value object (e.g., `formValue.password`, `formValue.email`)
- **`fieldPath`** - Current field path
- Custom functions registered in `customFnConfig.customFunctions`

### Safe Member Access

**Built-in null/undefined handling**: Member access is safe by default - no manual null checks needed!

```typescript
// ✅ Works safely even when nested values are null/undefined
{
  expression: 'fieldValue !== formValue.user.profile.firstName',
  kind: 'invalidNested',
}

// ❌ Unnecessary - Don't do this
{
  expression: '!formValue.user || !formValue.user.profile || !formValue.user.profile.firstName || fieldValue !== formValue.user.profile.firstName',
  kind: 'invalidNested',
}

// ✅ Better - Safe by default
{
  expression: '!formValue.user.profile.firstName || fieldValue !== formValue.user.profile.firstName',
  kind: 'invalidNested',
}
```

Accessing properties on `null` or `undefined` returns `undefined` instead of throwing errors, making expressions cleaner and more maintainable.

### Common Expression Patterns

**Password confirmation:**

```typescript
{
  expression: 'fieldValue === formValue.password',
  kind: 'passwordMismatch',
}
```

**Date range validation:**

```typescript
{
  expression: 'new Date(fieldValue) > new Date(formValue.startDate)',
  kind: 'endDateBeforeStart',
}
```

**Conditional required:**

```typescript
{
  expression: 'formValue.requiresApproval ? fieldValue?.length > 0 : true',
  kind: 'approvalRequired',
}
```

**Numeric comparison:**

```typescript
{
  expression: 'fieldValue >= formValue.minAge && fieldValue <= formValue.maxAge',
  kind: 'ageOutOfRange',
}
```

**Deeply nested field validation:**

```typescript
{
  // Safe to access deeply nested properties
  expression: 'fieldValue.toLowerCase() !== formValue.user.address.city.toLowerCase()',
  kind: 'invalidAddress',
}
```

### Security

Expressions use **secure AST-based parsing**. Only safe JavaScript operations are allowed.

## Function-Based Validators

Best for validation that needs field value and access to other fields via FieldContext.

### Basic Example

```typescript
import { CustomValidator } from '@ng-forge/dynamic-forms';

// ✅ RECOMMENDED: Return only kind
const noSpaces: CustomValidator = (ctx) => {
  const value = ctx.value();
  if (typeof value === 'string' && value.includes(' ')) {
    return { kind: 'noSpaces' }; // No hardcoded message
  }
  return null;
};

// Register and configure message
const config = {
  fields: [
    {
      key: 'username',
      type: 'input',
      validators: [{ type: 'custom', functionName: 'noSpaces' }],
      validationMessages: {
        noSpaces: 'Spaces are not allowed', // Or Observable/Signal for i18n
      },
    },
  ],
  customFnConfig: {
    validators: {
      noSpaces,
    },
  },
};
```

### FieldContext API

The `FieldContext` API provides access to:

- **`ctx.value()`** - Current field value (signal)
- **`ctx.state`** - Field state (errors, touched, dirty, etc.)
- **`ctx.valueOf(path)`** - Access other field values (PUBLIC API for cross-field validation)
- **`ctx.stateOf(path)`** - Access other field states
- **`ctx.field`** - Current field tree

### Cross-Field Validation

Use `ctx.valueOf()` to access other field values for comparison validators:

```typescript
import { CustomValidator } from '@ng-forge/dynamic-forms';

const greaterThanMin: CustomValidator = (ctx) => {
  const value = ctx.value();
  const minValue = ctx.valueOf('minAge');

  if (minValue !== undefined && value <= minValue) {
    return { kind: 'notGreaterThanMin' };
  }
  return null;
};

// Note: Custom validators return only 'kind'. Built-in validators (min, max, etc.)
// automatically include params for interpolation (e.g., {{min}}, {{max}}, etc.)
const config = {
  fields: [
    { key: 'minAge', type: 'input', value: 0 },
    {
      key: 'maxAge',
      type: 'input',
      value: 0,
      validators: [
        {
          type: 'custom',
          functionName: 'greaterThanMin',
        },
      ],
      validationMessages: {
        notGreaterThanMin: 'Maximum age must be greater than minimum age',
      },
    },
  ],
  customFnConfig: {
    validators: { greaterThanMin },
  },
};
```

**Common Cross-Field Patterns:**

- Password confirmation matching
- Date range validation (start < end)
- Numeric range validation (min < max)
- Conditional required fields

### Password Confirmation Example

```typescript
const passwordMatch: CustomValidator = (ctx) => {
  const confirmPassword = ctx.value();
  const password = ctx.valueOf('password');

  if (!confirmPassword || !password) {
    return null; // Let required validator handle empty case
  }

  if (password !== confirmPassword) {
    return { kind: 'passwordMismatch' };
  }
  return null;
};

// In field config:
{
  key: 'confirmPassword',
  type: 'input',
  validators: [{ type: 'custom', functionName: 'passwordMatch' }],
  validationMessages: {
    passwordMismatch: 'Passwords do not match'
  }
}
```

## Async Validators (Resource-based)

> **Deprecation notice:** The old `type: 'customAsync'` still works but is deprecated. Use `type: 'async'` instead.

Async validators use Angular's resource API for database lookups or complex async operations.

### Basic Example

```typescript
import { AsyncCustomValidator } from '@ng-forge/dynamic-forms';
import { inject } from '@angular/core';
import { rxResource } from '@angular/core/rxjs-interop';
import { of } from 'rxjs';
import { UserService } from './user.service';

const checkUsernameAvailable: AsyncCustomValidator = {
  // Extract params from field context
  params: (ctx) => ({ username: ctx.value() }),

  // Create resource with params signal
  factory: (params) => {
    const userService = inject(UserService);
    return rxResource({
      request: params,
      loader: ({ request }) => {
        if (!request?.username) return of(null);
        return userService.checkAvailability(request.username);
      },
    });
  },

  // Map result to validation error
  onSuccess: (result, ctx) => {
    if (!result) return null;
    return result.available ? null : { kind: 'usernameTaken' };
  },

  // Handle errors gracefully
  onError: (error, ctx) => {
    console.error('Availability check failed:', error);
    return null; // Don't block form on network errors
  },
};

const config = {
  fields: [
    {
      key: 'username',
      type: 'input',
      validators: [{ type: 'async', functionName: 'checkUsernameAvailable' }],
      validationMessages: {
        usernameTaken: 'This username is already taken',
      },
    },
  ],
  customFnConfig: {
    asyncValidators: {
      checkUsernameAvailable,
    },
  },
};
```

**Key Benefits:**

- Automatic loading states via resource API
- Angular manages resource lifecycle
- Reactive - refetches when params change
- Integrates with Signal Forms validation state

### Structure

```typescript
interface AsyncCustomValidator<TValue, TParams, TResult> {
  // Function that receives field context and returns resource params
  readonly params: (ctx: FieldContext<TValue>, config?: Record<string, unknown>) => TParams;

  // Function that creates a ResourceRef from the params signal
  readonly factory: (params: Signal<TParams | undefined>) => ResourceRef<TResult | undefined>;

  // Map successful resource result to validation errors
  readonly onSuccess?: (result: TResult, ctx: FieldContext<TValue>) => ValidationError | ValidationError[] | null;

  // Handle resource errors
  readonly onError?: (error: unknown, ctx: FieldContext<TValue>) => ValidationError | ValidationError[] | null;
}
```

## Declarative HTTP Validators

The simplest way to validate against an HTTP endpoint. No function registration required — configure the request and response mapping inline.

### Basic Example

```typescript
{
  key: 'username',
  type: 'input',
  validators: [
    {
      type: 'http',
      http: {
        url: '/api/users/check-availability',
        method: 'GET',
        queryParams: {
          username: 'fieldValue', // fieldValue refers to the current field
        },
      },
      responseMapping: {
        validWhen: 'response.available', // Truthy = valid
        errorKind: 'usernameTaken',
      },
    },
  ],
  validationMessages: {
    usernameTaken: 'This username is already taken',
  },
}
```

**Key points:**

- `fieldValue` is available as an expression in `params`, `queryParams`, and `body` (refers to the current field's value)
- Use `params` with `:key` URL placeholders for path parameters (e.g. `url: '/api/users/:id'` + `params: { id: 'fieldValue' }`)
- `validWhen` is evaluated with `{ response }` in scope — truthy means validation passed
- **Fail-closed:** if the HTTP request errors, the validator returns `{ kind: errorKind }` by default (prevents submission on network failure)

### POST with Body Expressions

```typescript
{
  type: 'http',
  http: {
    url: '/api/validate-email',
    method: 'POST',
    body: {
      email: 'fieldValue',
    },
    evaluateBodyExpressions: true,
  },
  responseMapping: {
    validWhen: 'response.valid',
    errorKind: 'emailInvalid',
  },
}
```

### Error Message Interpolation

Use `errorParams` to include response data in validation messages:

```typescript
{
  type: 'http',
  http: {
    url: '/api/users/check-availability',
    queryParams: { username: 'fieldValue' },
  },
  responseMapping: {
    validWhen: 'response.available',
    errorKind: 'usernameTaken',
    errorParams: {
      suggestion: 'response.suggestion', // Maps to {{suggestion}} in the message
    },
  },
}
// Message: 'Username is taken. Try {{suggestion}}'
```

### HttpValidationResponseMapping Interface

```typescript
interface HttpValidationResponseMapping {
  /** Expression evaluated with { response }. Truthy = valid (no error). */
  validWhen: string;

  /** Error kind returned when validWhen is falsy — maps to validationMessages. */
  errorKind: string;

  /**
   * Optional parameters for message interpolation.
   * Keys become {{paramName}} placeholders. Values are expressions evaluated with { response }.
   */
  errorParams?: Record<string, string>;
}
```

**When to use declarative vs function-based:**

| Scenario                                        | Use                                              |
| ----------------------------------------------- | ------------------------------------------------ |
| Standard availability check                     | Declarative (`type: 'http'` + `responseMapping`) |
| Need `inject()` for Angular services            | Function-based (`HttpCustomValidator`)           |
| Conditional request (skip based on field state) | Function-based (`HttpCustomValidator`)           |
| Custom error handling (fail-open on error)      | Function-based (`HttpCustomValidator`)           |

## HTTP Validators (Function-Based)

> **Deprecation notice:** The old `type: 'customHttp'` still works but is deprecated. Use `type: 'http'` with `functionName` instead.

Function-based HTTP validators give you full programmatic control over request construction and response handling.

### Basic Example

```typescript
import { HttpCustomValidator } from '@ng-forge/dynamic-forms';

const checkEmailDomain: HttpCustomValidator = {
  // Build HTTP request from context
  request: (ctx) => {
    const email = ctx.value();
    if (!email?.includes('@')) return undefined; // Skip if invalid

    const domain = email.split('@')[1];
    return {
      url: `/api/validate-domain`,
      method: 'POST',
      body: { domain },
      headers: { 'Content-Type': 'application/json' },
    };
  },

  // NOTE: Inverted logic - onSuccess checks if response indicates INVALID
  // We're validating, not fetching data!
  onSuccess: (response, ctx) => {
    // Assuming API returns { valid: boolean }
    return response.valid ? null : { kind: 'invalidDomain' };
  },

  onError: (error, ctx) => {
    console.error('Domain validation failed:', error);
    return null; // Don't block form on network errors
  },
};

const config = {
  fields: [
    {
      key: 'email',
      type: 'input',
      validators: [{ type: 'http', functionName: 'checkEmailDomain' }],
      validationMessages: {
        invalidDomain: 'This email domain is not allowed',
      },
    },
  ],
  customFnConfig: {
    httpValidators: {
      checkEmailDomain,
    },
  },
};
```

**Key Benefits:**

- Automatic request cancellation when field changes
- Built-in debouncing via resource API
- Prevents race conditions
- Optimized for HTTP-specific validation

**Important:** HTTP validators use "inverted logic" - `onSuccess` should return an error if validation fails, not if the HTTP request succeeds. You're checking validation status, not fetching data.

### Structure

```typescript
interface HttpCustomValidator<TValue, TResult> {
  // Build HTTP request from field context
  readonly request: (ctx: FieldContext<TValue>) => HttpResourceRequest | string | undefined;

  // Map successful response to validation error
  readonly onSuccess?: (result: TResult, ctx: FieldContext<TValue>) => ValidationError | ValidationError[] | null;

  // Handle HTTP errors
  readonly onError?: (error: unknown, ctx: FieldContext<TValue>) => ValidationError | ValidationError[] | null;
}

interface HttpResourceRequest {
  url: string;
  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  body?: any;
  headers?: Record<string, string | string[]>;
}
```

## Conditional Custom Validators

Apply validators conditionally using the `when` property with a `ConditionalExpression`:

```typescript
const businessEmailValidator: CustomValidator = (ctx) => {
  const value = ctx.value();
  const domain = value?.split('@')[1];

  const freeEmailDomains = ['gmail.com', 'yahoo.com', 'hotmail.com'];

  if (domain && freeEmailDomains.includes(domain.toLowerCase())) {
    return { kind: 'requireBusinessEmail' };
  }
  return null;
};

const config = {
  fields: [
    {
      key: 'accountType',
      type: 'select',
      value: 'personal',
      options: [
        { value: 'personal', label: 'Personal' },
        { value: 'business', label: 'Business' },
      ],
    },
    {
      key: 'email',
      type: 'input',
      validators: [
        {
          type: 'custom',
          functionName: 'businessEmailValidator',
          // Only apply when account type is "business"
          when: {
            type: 'fieldValue',
            fieldPath: 'accountType',
            operator: 'equals',
            value: 'business',
          },
        },
      ],
      validationMessages: {
        requireBusinessEmail: 'Please use a business email address',
      },
    },
  ],
  customFnConfig: {
    validators: { businessEmailValidator },
  },
};
```

The validator is only active when the `when` condition evaluates to `true`, allowing dynamic validation based on form state. See [Conditional Logic](../../dynamic-behavior/conditional-logic/overview/) for all expression types and operators.

## Common Validation Patterns

### Email Domain Validation

```typescript
const emailDomainValidator: CustomValidator = (ctx) => {
  const blockedDomains = ['tempmail.com', 'throwaway.email'];
  const email = ctx.value();
  const domain = email?.split('@')[1];

  if (domain && blockedDomains.includes(domain)) {
    return { kind: 'blockedDomain' };
  }
  return null;
};
```

### Age Validation

```typescript
const ageValidator: CustomValidator = (ctx) => {
  const birthDate = ctx.value();
  const age = calculateAge(birthDate);

  if (age < 18) {
    return { kind: 'tooYoung' };
  }
  return null;
};
```

### Conditional Required

```typescript
const conditionalRequiredValidator: CustomValidator = (ctx) => {
  const value = ctx.value();
  const employmentStatus = ctx.valueOf('employmentStatus');

  // Company name required if employed
  if (employmentStatus === 'employed' && !value) {
    return { kind: 'required' };
  }
  return null;
};
```

### Date Range Validation

```typescript
const dateRangeValidator: CustomValidator = (ctx) => {
  const endDate = ctx.value();
  const startDate = ctx.valueOf('startDate');

  if (startDate && endDate && startDate > endDate) {
    return { kind: 'invalidDateRange' };
  }
  return null;
};
```

## Multiple Errors

Validators can return multiple errors for cross-field validation:

```typescript
const validateDateRange: CustomValidator = (ctx) => {
  const errors: ValidationError[] = [];

  const startDate = ctx.valueOf('startDate');
  const endDate = ctx.valueOf('endDate');

  if (!startDate) errors.push({ kind: 'startDateRequired' });
  if (!endDate) errors.push({ kind: 'endDateRequired' });
  if (startDate && endDate && startDate > endDate) {
    errors.push({ kind: 'invalidDateRange' });
  }

  return errors.length > 0 ? errors : null;
};
```

## Validation Messages

### Field-Level Messages

```typescript
{
  key: 'username',
  validators: [{ type: 'custom', functionName: 'noSpaces' }],
  validationMessages: {
    noSpaces: 'Spaces are not allowed'
  }
}
```

### Form-Level Default Messages

```typescript
{
  defaultValidationMessages: {
    noSpaces: 'Spaces are not allowed',
    passwordMismatch: 'Passwords must match',
    usernameTaken: 'This username is already taken'
  },
  fields: [/* ... */]
}
```

### Dynamic Messages with i18n

```typescript
import { inject } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';

{
  key: 'username',
  validators: [{ type: 'custom', functionName: 'noSpaces' }],
  validationMessages: {
    noSpaces: inject(TranslateService).get('VALIDATION.NO_SPACES')
  }
}
```

### Parameterized Messages

Messages can interpolate params from ValidatorConfig using Angular template syntax (double curly braces around the param name).

**Syntax:** To interpolate a param, wrap its name in double curly braces (same syntax as Angular templates).

**Example:** To access `params.label`, write the param name `label` wrapped in double curly braces in your message string.

```typescript
{
  validators: [
    {
      type: 'custom',
      functionName: 'lessThanField',
      params: { field: 'minAge', label: 'Minimum Age' }
    }
  ],
  validationMessages: {
    // Interpolate params.label using double curly braces
    notLessThan: 'Must be less than {{label}}'
  }
}
```

The validation message will render as **"Must be less than Minimum Age"** by interpolating the `label` param value.

## Type Safety

All validator types are fully typed. While validators can optionally use generic type parameters for stricter typing, the simple form without generics works well for most cases:

```typescript
// Simple form - works for most cases
const noSpaces: CustomValidator = (ctx) => {
  const value = ctx.value();
  if (typeof value === 'string' && value.includes(' ')) {
    return { kind: 'noSpaces' };
  }
  return null;
};

// With type parameter - for stricter typing (advanced)
const strictNoSpaces: CustomValidator<string> = (ctx) => {
  const value = ctx.value(); // Type: string
  // TypeScript knows value is always string
  return value.includes(' ') ? { kind: 'noSpaces' } : null;
};

// Async validators with type parameters (advanced)
const checkUsername: AsyncCustomValidator<string, { username: string }, { available: boolean }> = {
  params: (ctx) => ({ username: ctx.value() }),
  factory: (params) => {
    /* ... */
  },
  onSuccess: (result, ctx) => {
    result.available; // Type: boolean
    return result.available ? null : { kind: 'usernameTaken' };
  },
};

// HTTP validators with type parameters (advanced)
const checkDomain: HttpCustomValidator<string, { valid: boolean }> = {
  request: (ctx) => ({
    /* ... */
  }),
  onSuccess: (response, ctx) => {
    response.valid; // Type: boolean
    return response.valid ? null : { kind: 'invalidDomain' };
  },
};
```

**Note:** When registering validators in `customFnConfig.validators`, use the simple form without type parameters to avoid TypeScript compatibility issues.

## Best Practices

1. **Separation of Concerns**: Return only error `kind`, configure messages separately
2. **i18n Support**: Use Observable/Signal for validation messages
3. **Graceful Degradation**: Handle async/HTTP errors without blocking the form
4. **Cross-Field Validation**: Use `ctx.valueOf()` for accessing related fields
5. **Type Safety**: Leverage TypeScript generics for type-safe validation
6. **Message Priority**: Use field-level messages for customization, form-level for common errors
7. **Conditional Validation**: Use `when` property with `ConditionalExpression` for dynamic validators
8. **Inverted Logic**: HTTP validators check validity, not data fetching success

## Related Documentation

- [Validation Basics](../basics/) - Core validation concepts
- [Validation Reference](../reference/) - Standard validation rules
- [Type Safety](../../advanced/type-safety/basics/) - TypeScript integration

--- validation/reference ---

Complete reference for all validators, conditional expressions, and validation configuration options.

## All Validator Types

### required

Field must have a value.

```typescript
// Shorthand
{ required: true }

// Explicit
{
  validators: [{
    type: 'required',
  }],
}
```

### email

Must be a valid email format.

```typescript
// Shorthand
{ email: true }

// Explicit
{
  validators: [{
    type: 'email',
  }],
}
```

### minLength

Minimum string length.

```typescript
// Shorthand
{ minLength: 8 }

// Explicit
{
  validators: [{
    type: 'minLength',
    value: 8,
  }],
}
```

### maxLength

Maximum string length.

```typescript
// Shorthand
{ maxLength: 20 }

// Explicit
{
  validators: [{
    type: 'maxLength',
    value: 20,
  }],
}
```

### min

Minimum numeric value.

```typescript
// Shorthand
{ min: 0 }

// Explicit
{
  validators: [{
    type: 'min',
    value: 0,
  }],
}
```

### max

Maximum numeric value.

```typescript
// Shorthand
{ max: 100 }

// Explicit
{
  validators: [{
    type: 'max',
    value: 100,
  }],
}
```

### pattern

Regular expression validation.

```typescript
// Shorthand
{ pattern: '^[0-9]{5}$' }

// Explicit
{
  validators: [{
    type: 'pattern',
    value: '^[0-9]{5}$',
  }],
}
```

## Conditional Expressions

Validators support a `when` property for conditional validation. See **[Conditional Logic](../../dynamic-behavior/conditional-logic/overview/)** for the complete reference on:

- All operators (`equals`, `notEquals`, `greater`, `less`, `contains`, `matches`, etc.)
- Expression types (`fieldValue`, `formValue` (deprecated), `javascript`, `custom`)
- Combining conditions with `and`/`or` logic

**Quick example:**

```typescript
{
  validators: [{
    type: 'required',
    when: {
      type: 'fieldValue',
      fieldPath: 'accountType',
      operator: 'equals',
      value: 'business',
    },
  }],
}
```

## ValidatorConfig Types

ValidatorConfig is a discriminated union type with five variants:

```typescript
// Built-in validators (required, email, min, max, etc.)
interface BuiltInValidatorConfig {
  type: 'required' | 'email' | 'min' | 'max' | 'minLength' | 'maxLength' | 'pattern';
  value?: number | string | RegExp;
  expression?: string;
  when?: ConditionalExpression;
}

// Custom synchronous validators
interface CustomValidatorConfig {
  type: 'custom';
  functionName?: string;
  params?: Record<string, unknown>;
  expression?: string;
  kind?: string;
  errorParams?: Record<string, string>;
  when?: ConditionalExpression;
}

// Async validators (for debounced validation, database lookups)
interface AsyncValidatorConfig {
  // 'async' is preferred; 'customAsync' is deprecated and emits a warning in dev mode
  type: 'async' | 'customAsync';
  functionName: string;
  params?: Record<string, unknown>;
  when?: ConditionalExpression;
}

// Function-based HTTP validators (requires a registered function)
interface FunctionHttpValidatorConfig {
  // 'http' is preferred; 'customHttp' is deprecated and emits a warning in dev mode
  type: 'http' | 'customHttp';
  functionName: string;
  params?: Record<string, unknown>;
  when?: ConditionalExpression;
}

// Declarative HTTP validators (fully JSON-serializable, no function registration)
interface DeclarativeHttpValidatorConfig {
  type: 'http';
  http: HttpRequestConfig;
  responseMapping: HttpValidationResponseMapping;
  when?: ConditionalExpression;
}

type ValidatorConfig =
  | BuiltInValidatorConfig
  | CustomValidatorConfig
  | AsyncValidatorConfig
  | FunctionHttpValidatorConfig
  | DeclarativeHttpValidatorConfig;
```

> **Deprecation notes:**
>
> - `type: 'customAsync'` is deprecated. Use `type: 'async'` instead.
> - `type: 'customHttp'` is deprecated. Use `type: 'http'` instead.
> - `FunctionHttpValidatorConfig` and `DeclarativeHttpValidatorConfig` both use `type: 'http'`. They are discriminated by property presence: `functionName` indicates function-based, `http` + `responseMapping` indicates declarative.

### HttpRequestConfig

Used by `DeclarativeHttpValidatorConfig` to define the HTTP request:

```typescript
interface HttpRequestConfig {
  url: string;
  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'; // defaults to 'GET'
  queryParams?: Record<string, string>; // values are expressions
  body?: Record<string, unknown>;
  evaluateBodyExpressions?: boolean; // when true, top-level string values in body are evaluated as expressions
  headers?: Record<string, string>;
}
```

### HttpValidationResponseMapping

Used by `DeclarativeHttpValidatorConfig` to interpret the HTTP response:

```typescript
interface HttpValidationResponseMapping {
  validWhen: string; // expression evaluated with { response } scope; truthy = valid
  errorKind: string; // error kind for validationMessages lookup
  errorParams?: Record<string, string>; // parameter expressions evaluated against { response }
}
```

## ConditionalExpression Types

`ConditionalExpression` is a discriminated union of six condition types. Each variant only allows the properties relevant to its type, providing compile-time safety against invalid property combinations.

```typescript
// Compare a specific field's value
interface FieldValueCondition {
  type: 'fieldValue';
  fieldPath: string;
  operator: ComparisonOperator;
  value?: unknown;
}

// Compare the entire form value (deprecated — use FieldValueCondition or JavascriptCondition instead)
interface FormValueCondition {
  type: 'formValue';
  operator: ComparisonOperator;
  value?: unknown;
}

// Invoke a registered custom function by name
interface CustomCondition {
  type: 'custom';
  expression: string; // registered function name
}

// Evaluate a JavaScript expression via the secure AST-based parser
interface JavascriptCondition {
  type: 'javascript';
  expression: string; // has access to formValue, fieldValue, externalData, etc.
}

// Logical AND — all sub-conditions must be true
interface AndCondition {
  type: 'and';
  conditions: ConditionalExpression[];
}

// Logical OR — at least one sub-condition must be true
interface OrCondition {
  type: 'or';
  conditions: ConditionalExpression[];
}

type ComparisonOperator =
  | 'equals'
  | 'notEquals'
  | 'greater'
  | 'less'
  | 'greaterOrEqual'
  | 'lessOrEqual'
  | 'contains'
  | 'startsWith'
  | 'endsWith'
  | 'matches';

type ConditionalExpression = FieldValueCondition | FormValueCondition | CustomCondition | JavascriptCondition | AndCondition | OrCondition;
```

> **Deprecation note:** `FormValueCondition` (`type: 'formValue'`) is deprecated. Use `FieldValueCondition` for specific field checks, or `JavascriptCondition` with an expression for complex form-level comparisons.

## Validation Messages

### Per-Field Messages

```typescript
{
  key: 'email',
  type: 'input',
  value: '',
  required: true,
  email: true,
  validationMessages: {
    required: 'Email is required',
    email: 'Invalid email format',
  },
}
```

### Dynamic Messages (i18n)

```typescript
{
  key: 'email',
  type: 'input',
  value: '',
  required: true,
  validationMessages: {
    required: this.transloco.selectTranslate('validation.required'),
    email: this.transloco.selectTranslate('validation.email'),
  },
}
```

## Common Patterns

### Email Validation

```typescript
{
  key: 'email',
  type: 'input',
  value: '',
  required: true,
  email: true,
  validationMessages: {
    required: 'Email is required',
    email: 'Please enter a valid email address',
  },
}
```

### Password Requirements

```typescript
{
  key: 'password',
  type: 'input',
  value: '',
  required: true,
  minLength: 8,
  maxLength: 128,
  pattern: '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])',
  validationMessages: {
    required: 'Password is required',
    minLength: 'Password must be at least 8 characters',
    pattern: 'Password must include uppercase, lowercase, number, and special character',
  },
  props: { type: 'password' },
}
```

### Numeric Range

```typescript
{
  key: 'age',
  type: 'input',
  value: null,
  required: true,
  min: 18,
  max: 120,
  validationMessages: {
    required: 'Age is required',
    min: 'Must be at least 18 years old',
    max: 'Please enter a valid age',
  },
  props: { type: 'number' },
}
```

### ZIP Code

```typescript
{
  key: 'zipCode',
  type: 'input',
  value: '',
  required: true,
  pattern: '^[0-9]{5}(-[0-9]{4})?$',
  validationMessages: {
    required: 'ZIP code is required',
    pattern: 'Must be 5 digits or 5+4 format (e.g., 12345 or 12345-6789)',
  },
}
```

### Phone Number

```typescript
{
  key: 'phone',
  type: 'input',
  value: '',
  pattern: '^\\+?[1-9]\\d{1,14}$',
  validationMessages: {
    pattern: 'Please enter a valid phone number (E.164 format preferred)',
  },
  props: { type: 'tel' },
}
```

### URL

```typescript
{
  key: 'website',
  type: 'input',
  value: '',
  pattern: '^https?:\\/\\/.+',
  validationMessages: {
    pattern: 'Please enter a valid URL starting with http:// or https://',
  },
  props: { type: 'url' },
}
```

## Related

- **[Validation Basics](../basics/)** - Getting started with validation
- **[Validation Advanced](../advanced/)** - Conditional validators
- **[Conditional Logic](../../dynamic-behavior/conditional-logic/overview/)** - Field behavior changes
- **[Type Safety](../../advanced/type-safety/basics/)** - TypeScript integration
